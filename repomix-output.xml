This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/analysis_parts/ai.py
backend/analysis_parts/clustering.py
backend/analysis_parts/economics.py
backend/analysis_service.py
backend/auth_service.py
backend/bidder_engine.py
backend/bot_service.py
backend/celery_app.py
backend/clickhouse_models.py
backend/database.py
backend/dependencies.py
backend/docker-entrypoint.sh
backend/Dockerfile
backend/forecasting.py
backend/main.py
backend/migrate.py
backend/msedgedriver
backend/parser_parts/__init__.py
backend/parser_parts/basket.py
backend/parser_parts/browser.py
backend/parser_parts/config.py
backend/parser_parts/product.py
backend/parser_parts/proxy.py
backend/parser_parts/search.py
backend/parser_service.py
backend/requirements.txt
backend/routers/admin.py
backend/routers/ai.py
backend/routers/bidder.py
backend/routers/finance.py
backend/routers/monitoring.py
backend/routers/payments.py
backend/routers/seo.py
backend/routers/users.py
backend/tasks/__init__.py
backend/tasks/bidder.py
backend/tasks/finance.py
backend/tasks/monitoring.py
backend/tasks/seo.py
backend/tasks/utils.py
backend/wb_api_service.py
backend/wb_api/__init__.py
backend/wb_api/base.py
backend/wb_api/content.py
backend/wb_api/promotion.py
backend/wb_api/statistics.py
docker-compose.yml
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/src/App.jsx
frontend/src/components/CostEditModal.jsx
frontend/src/components/HistoryModule.jsx
frontend/src/components/StoriesBar.jsx
frontend/src/components/TabNav.jsx
frontend/src/components/TariffCard.jsx
frontend/src/config.js
frontend/src/index.css
frontend/src/main.jsx
frontend/src/pages/AdminPage.jsx
frontend/src/pages/AIAnalysisPage.jsx
frontend/src/pages/BidderPage.jsx
frontend/src/pages/DashboardPage.jsx
frontend/src/pages/FinancePage.jsx
frontend/src/pages/MonitorPage.jsx
frontend/src/pages/ProfilePage.jsx
frontend/src/pages/ScannerPage.jsx
frontend/src/pages/SeoGeneratorPage.jsx
frontend/src/pages/SeoTrackerPage.jsx
frontend/src/pages/SupplyPage.jsx
frontend/tailwind.config.js
frontend/vercel.json
package.json
PROJECT_DESCRIPTION.md
proxy_ext/proxy_auth_plugin.zip
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
.env
backend/proxy_ext/
venv/
backend/__pycache__/
node_modules/
*.png
</file>

<file path="backend/analysis_parts/ai.py">
import os
import re
import json
import logging
import requests
from typing import Dict, Any

logger = logging.getLogger("Analysis-AI")

class AIModule:
    def __init__(self):
        self.ai_api_key = os.getenv("AI_API_KEY", "") 
        self.ai_url = "https://api.artemox.com/v1/chat/completions"

    def clean_ai_text(self, text: str) -> str:
        if not text: return ""
        text = re.sub(r'\*\*(.*?)\*\*', r'\1', text) 
        text = re.sub(r'#+\s?', '', text)
        text = text.replace("`", "")
        return text.strip()

    def _clean_recursive(self, data):
        if isinstance(data, dict):
            return {k: self._clean_recursive(v) for k, v in data.items()}
        elif isinstance(data, list):
            return [self._clean_recursive(i) for i in data]
        elif isinstance(data, str):
            return self.clean_ai_text(data)
        else:
            return data

    def _call_ai(self, prompt: str, fallback_json: dict, temperature: float = 0.7):
        try:
            payload = {
                "model": "deepseek-chat", 
                "messages": [{"role": "user", "content": prompt}],
                "temperature": temperature
            }
            headers = {"Authorization": f"Bearer {self.ai_api_key}", "Content-Type": "application/json"}
            resp = requests.post(self.ai_url, json=payload, headers=headers, timeout=90) 
            if resp.status_code != 200:
                logger.error(f"AI API Error: {resp.text}")
                return fallback_json
            
            result = resp.json()
            content = result['choices'][0]['message']['content']
            try:
                # Очистка Markdown-блоков кода
                content = re.sub(r'^```json\s*', '', content, flags=re.MULTILINE)
                content = re.sub(r'^```\s*', '', content, flags=re.MULTILINE)
                content = content.strip()

                json_match = re.search(r'\{[\s\S]*\}', content)
                if json_match:
                    parsed = json.loads(json_match.group(0))
                    # Рекурсивная очистка
                    return self._clean_recursive(parsed)
                else: 
                    logger.warning(f"No JSON found in AI response: {content[:100]}...")
                    return fallback_json
            except Exception as e:
                logger.error(f"JSON Parse Error: {e}")
                return fallback_json
        except Exception as e:
            logger.error(f"AI Connection Error: {e}")
            return fallback_json

    def analyze_reviews_with_ai(self, reviews: list, product_name: str) -> Dict[str, Any]:
        """
        Комплексный анализ отзывов с использованием DeepSeek-V3.
        1. ABSA (Aspect-Based Sentiment Analysis).
        2. Психографическое профилирование.
        """
        if not reviews: 
            return {
                "aspects": [], 
                "audience_stats": {"rational": 0, "emotional": 0, "skeptic": 0},
                "global_summary": "Нет данных для анализа",
                "flaws": ["Нет отзывов"], 
                "strategy": ["Соберите первые отзывы"]
            }

        reviews_text = ""
        for r in reviews[:40]:
            clean_text = r['text'].replace('\n', ' ').strip()
            if len(clean_text) > 5:
                text = f"- {clean_text} (Оценка: {r['rating']})\n"
                if len(reviews_text) + len(text) < 4000: 
                    reviews_text += text
                else: 
                    break
        
        prompt = f"""
        Роль: Ты Lead Data Analyst в E-commerce. Твоя специализация — ABSA и Психография.
        
        Товар: "{product_name}".
        Отзывы покупателей:
        {reviews_text}

        Выполни глубокий анализ по двум направлениям:

        НАПРАВЛЕНИЕ 1: Аспектный анализ (ABSA)
        - Выдели ключевые аспекты (Aspect = Entity + Attribute).
        - Оцени каждый аспект по шкале Valence (Тональность) от 1.00 (Крайний негатив) до 9.00 (Восхищение).
        - Найди цитату (Snippet) и дай совет (Actionable Advice).

        НАПРАВЛЕНИЕ 2: Психографическое профилирование аудитории
        - Определи, к какому типу относится большинство авторов отзывов:
          A. Rational (Рациональный): Факты, цифры, срок службы.
          B. Emotional (Эмоциональный): Стиль, восторг, упаковка, "вау-эффект".
          C. Skeptic (Скептик): Сомнения, поиск брака, проверка гарантий.
        - Рассчитай примерный процент (%) каждого типа в выборке.
        - На основе ДОМИНИРУЮЩЕГО типа сгенерируй рекомендацию для инфографики (Infographic Tip).

        Формат ответа (СТРОГО JSON):
        {{
            "aspects": [
                {{
                    "aspect": "Название аспекта",
                    "sentiment_score": 2.5,
                    "snippet": "цитата",
                    "actionable_advice": "совет"
                }}
            ],
            "audience_stats": {{
                "rational_percent": 30,
                "emotional_percent": 50,
                "skeptic_percent": 20
            }},
            "dominant_type": "Emotional",
            "infographic_recommendation": "Текст рекомендации...",
            "global_summary": "Общее резюме (1 предложение)"
        }}
        """
        
        fallback = {
            "aspects": [],
            "audience_stats": {"rational_percent": 33, "emotional_percent": 33, "skeptic_percent": 34},
            "dominant_type": "Mixed",
            "infographic_recommendation": "Проверьте качество контента",
            "global_summary": "Ошибка анализа нейросети",
            "flaws": ["Ошибка API"],
            "strategy": ["Повторите попытку"]
        }
        
        ai_response = self._call_ai(prompt, fallback, temperature=0.5)
        
        # Post-Processing
        aspects = ai_response.get("aspects", [])
        
        negative_aspects = sorted(
            [a for a in aspects if a.get('sentiment_score', 5) < 4.5], 
            key=lambda x: x['sentiment_score']
        )
        ai_response["flaws"] = [f"{a['aspect']}: {a['snippet'][:50]}..." for a in negative_aspects[:5]]
        
        positive_strategies = [a['actionable_advice'] for a in aspects if a.get('sentiment_score', 0) < 7.5]
        ai_response["strategy"] = positive_strategies[:7] if positive_strategies else ["Масштабируйте продажи"]

        if not ai_response["flaws"]:
            ai_response["flaws"] = ["Критических проблем не выявлено"]

        return ai_response

    def generate_product_content(self, keywords: list, tone: str, title_len: int = 100, desc_len: int = 1000):
        """
        GEO-Optimized Generation (Generative Engine Optimization).
        Создает контент, оптимизированный для AI-поисковиков (Perplexity, SGE, Yandex GPT).
        Включает структурированные данные и FAQ.
        """
        kw_str = ", ".join(keywords)
        prompt = f"""
        Роль: Ты профессиональный SEO-копирайтер уровня Senior, специализирующийся на GEO (Generative Engine Optimization).
        Твоя задача — создать контент для Wildberries, который легко считывается AI-алгоритмами и ранжируется в SGE.

        Входные данные:
        - Ключевые слова: {kw_str}
        - Тон (Tone of Voice): {tone}
        - Лимит заголовка: ~{title_len} симв.
        - Лимит описания: ~{desc_len} симв.

        Требования к структуре (GEO Standards):
        1. Extractability: Используй маркированные списки и четкие сущности.
        2. Authority: Добавь таблицу характеристик для сравнения.
        3. User Intent: Добавь блок FAQ (3-5 вопросов), закрывающий боли Рационалов, Эмоционалов и Скептиков.

        Верни ответ СТРОГО в формате JSON:
        {{
            "title": "Продающий заголовок с вхождением топ ключей",
            "description": "Основной текст описания с LSI-фразами и структурированными списками...",
            "structured_features": {{
                "Материал": "...",
                "Назначение": "...",
                "Особенность": "..."
            }},
            "faq": [
                {{ "question": "Вопрос клиента", "answer": "Экспертный ответ" }},
                {{ "question": "Вопрос про гарантию", "answer": "Ответ про надежность" }}
            ]
        }}
        """
        
        fallback = {
            "title": "Ошибка генерации", 
            "description": "Не удалось сгенерировать текст", 
            "structured_features": {}, 
            "faq": []
        }
        
        return self._call_ai(prompt, fallback, temperature=0.7)
</file>

<file path="backend/analysis_parts/clustering.py">
import logging
from typing import List, Dict, Any

logger = logging.getLogger("Analysis-Clustering")

# Lazy Loading pattern to prevent crash if libs are missing
try:
    from sentence_transformers import SentenceTransformer
    from sklearn.cluster import KMeans
    ML_AVAILABLE = True
except ImportError:
    ML_AVAILABLE = False

class ClusteringModule:
    def __init__(self):
        self._embedder = None

    def _get_embedder(self):
        """Singleton pattern for heavy BERT model"""
        if not ML_AVAILABLE:
            raise ImportError("Install 'sentence-transformers' and 'scikit-learn'")
        if self._embedder is None:
            logger.info("Loading BERT model for clustering...")
            # Using a lightweight model suitable for CPU
            self._embedder = SentenceTransformer('all-MiniLM-L6-v2')
        return self._embedder

    def cluster_keywords(self, keywords: List[str]) -> Dict[str, Any]:
        """
        Кластеризация ключевых слов по семантической близости (BERT + K-Means).
        Позволяет группировать запросы по интенту (смыслу), а не просто по вхождению слов.
        """
        if not keywords:
            return {"status": "error", "message": "Empty keywords list"}
        
        if not ML_AVAILABLE:
            return {
                "status": "error", 
                "message": "ML libraries missing. Install sentence-transformers & scikit-learn."
            }

        try:
            model = self._get_embedder()
            
            # 1. Векторизация (Embeddings)
            embeddings = model.encode(keywords)
            
            # 2. Определение оптимального числа кластеров
            # Эвристика: ~5 ключей на кластер, минимум 2 кластера (если ключей > 5)
            n_clusters = max(2, len(keywords) // 5)
            if len(keywords) < 5:
                n_clusters = 1
            
            # 3. Кластеризация K-Means
            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
            kmeans.fit(embeddings)
            labels = kmeans.labels_
            
            # 4. Группировка результатов
            clusters = {}
            for keyword, label in zip(keywords, labels):
                lbl_str = str(label)
                if lbl_str not in clusters:
                    clusters[lbl_str] = []
                clusters[lbl_str].append(keyword)
            
            # 5. Нейминг кластеров (берем самое короткое слово как название темы)
            named_clusters = []
            for _, kw_list in clusters.items():
                topic_name = min(kw_list, key=len) # Самое короткое слово ~ тема
                named_clusters.append({
                    "topic": topic_name,
                    "keywords": kw_list,
                    "count": len(kw_list)
                })
                
            return {
                "status": "success",
                "clusters": named_clusters,
                "total_keywords": len(keywords),
                "n_clusters": n_clusters
            }

        except Exception as e:
            logger.error(f"Clustering failed: {e}")
            return {"status": "error", "message": str(e)}
</file>

<file path="backend/analysis_parts/economics.py">
import math
import numpy as np
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession

from database import ProductCost
from clickhouse_models import ch_service

logger = logging.getLogger("Analysis-Economics")

class EconomicsModule:
    
    def calculate_supply_metrics(
        self, 
        current_stock: int, 
        sales_history: List[Dict[str, Any]], 
        forecast_data: Optional[Dict[str, Any]] = None,
        lead_time_days: int = 7,  # Среднее время поставки
        lead_time_sigma: int = 2, # Отклонение времени поставки (дней)
        service_level_z: float = 1.65 # Z-score для 95% уровня сервиса
    ) -> Dict[str, Any]:
        """
        Расчет точки заказа (ROP) и страхового запаса (Safety Stock).
        """
        # 1. Определяем спрос (Demand)
        if forecast_data and forecast_data.get("status") == "success":
            avg_daily_demand = forecast_data.get("daily_avg_forecast", 0)
            forecast_points = forecast_data.get("forecast_points", [])
            demand_during_lead_time = sum([p['yhat'] for p in forecast_points[:lead_time_days]])
        else:
            if not sales_history:
                return {"status": "error", "message": "No data"}
            values = [x['qty'] for x in sales_history if x['qty'] > 0]
            if not values:
                return {"status": "error", "message": "Zero sales"}
            avg_daily_demand = np.mean(values)
            demand_during_lead_time = avg_daily_demand * lead_time_days

        # 2. Считаем стандартное отклонение спроса (sigma_Demand)
        if sales_history:
            hist_values = [x['qty'] for x in sales_history]
            sigma_demand = np.std(hist_values) if len(hist_values) > 1 else 0
        else:
            sigma_demand = 0

        # 3. Расчет Safety Stock
        term1 = lead_time_days * (sigma_demand ** 2)
        term2 = (avg_daily_demand ** 2) * (lead_time_sigma ** 2)
        safety_stock = service_level_z * math.sqrt(term1 + term2)
        
        # 4. Расчет ROP
        rop = demand_during_lead_time + safety_stock
        
        # 5. Интерпретация
        days_left = current_stock / avg_daily_demand if avg_daily_demand > 0 else 999
        
        safety_stock = int(math.ceil(safety_stock))
        rop = int(math.ceil(rop))
        days_left = int(days_left)
        
        status = "ok"
        recommendation = "Запаса достаточно"
        
        if current_stock <= 0:
            status = "out_of_stock"
            recommendation = "Товара нет в наличии!"
        elif current_stock < safety_stock:
            status = "critical"
            recommendation = "Срочно пополнить! (Ниже страхового запаса)"
        elif current_stock < rop:
            status = "warning"
            recommendation = f"Пора заказывать (Ниже точки заказа {rop} шт)"
            
        return {
            "status": status,
            "recommendation": recommendation,
            "metrics": {
                "safety_stock": safety_stock,
                "rop": rop,
                "days_left": days_left,
                "avg_daily_demand": round(avg_daily_demand, 1),
                "demand_lead_time": round(demand_during_lead_time, 1),
                "current_stock": current_stock
            },
            "inputs": {
                "lead_time": lead_time_days,
                "service_level": "95%"
            }
        }

    async def get_pnl_data(self, user_id: int, date_from: datetime, date_to: datetime, db: AsyncSession) -> List[Dict[str, Any]]:
        ch_query = """
        SELECT 
            toDate(sale_dt) as report_date,
            nm_id,
            sumIf(retail_price_withdisc_rub, doc_type_name = 'Продажа') as gross_sales,
            sumIf(retail_price_withdisc_rub, doc_type_name = 'Возврат') as returns_sum,
            countIf(doc_type_name = 'Продажа') as qty_sold,
            countIf(doc_type_name = 'Возврат') as qty_returned,
            sum(ppvz_sales_commission) as commission,
            sum(delivery_rub) as logistics,
            sum(penalty) as penalties,
            sum(additional_payment) as adjustments
        FROM wb_analytics.realization_reports
        WHERE supplier_id = %(uid)s 
          AND sale_dt >= %(start)s 
          AND sale_dt <= %(end)s
        GROUP BY report_date, nm_id
        ORDER BY report_date ASC
        """
        
        params = {'uid': user_id, 'start': date_from, 'end': date_to}
        
        try:
            ch_client = ch_service.get_client()
            result = ch_client.query(ch_query, parameters=params)
            rows = result.result_rows
        except Exception as e:
            logger.error(f"ClickHouse Query Error: {e}")
            return []

        if not rows: return []

        unique_skus = list(set([row[1] for row in rows]))
        stmt = select(ProductCost).where(ProductCost.user_id == user_id, ProductCost.sku.in_(unique_skus))
        cogs_result = await db.execute(stmt)
        costs_map = {c.sku: c.cost_price for c in cogs_result.scalars().all()}

        daily_pnl = {}
        for row in rows:
            r_date, sku, gross_sales, returns_sum, qty_sold, qty_returned, commission, logistics, penalties, adjustments = row
            gross_sales, returns_sum = float(gross_sales), float(returns_sum)
            qty_sold, qty_returned = int(qty_sold), int(qty_returned)
            commission, logistics, penalties, adjustments = float(commission), float(logistics), float(penalties), float(adjustments)

            unit_cost = costs_map.get(sku, 0)
            total_cogs = (qty_sold * unit_cost) - (qty_returned * unit_cost)

            date_str = r_date.strftime("%Y-%m-%d")
            if date_str not in daily_pnl:
                daily_pnl[date_str] = {
                    "date": date_str, "gross_sales": 0.0, "net_sales": 0.0, "cogs": 0.0,
                    "commission": 0.0, "logistics": 0.0, "penalties": 0.0, "marketing": 0.0, 
                    "cm1": 0.0, "cm2": 0.0, "cm3": 0.0
                }
            d = daily_pnl[date_str]
            d["gross_sales"] += gross_sales
            d["net_sales"] += (gross_sales - returns_sum) 
            d["cogs"] += total_cogs
            d["commission"] += commission
            d["logistics"] += logistics
            d["penalties"] += (penalties + adjustments)
        
        final_output = []
        for date_str, metrics in sorted(daily_pnl.items()):
            metrics["cm1"] = metrics["net_sales"] - metrics["cogs"]
            metrics["cm2"] = metrics["cm1"] - metrics["commission"] - metrics["logistics"] - metrics["penalties"]
            metrics["cm3"] = metrics["cm2"] - metrics["marketing"]
            for k, v in metrics.items():
                if isinstance(v, float): metrics[k] = round(v, 2)
            final_output.append(metrics)
        return final_output

    def calculate_metrics(self, raw_data: dict):
        if raw_data.get("status") == "error": return raw_data
        p = raw_data.get("prices", {})
        wallet = p.get("wallet_purple", 0)
        standard = p.get("standard_black", 0)
        base = p.get("base_crossed", 0)
        benefit = standard - wallet if standard > wallet else 0
        discount_pct = round(((base - wallet) / base * 100), 1) if base > 0 else 0
        raw_data["metrics"] = {
            "wallet_benefit": benefit,
            "total_discount_percent": discount_pct,
            "is_favorable": discount_pct > 45
        }
        return raw_data

    def calculate_transit_benefit(self, volume_liters: int):
        koledino_direct_cost = volume_liters * 30 * 1 
        kazan_transit_cost = 1500 + (volume_liters * 20 * 0) 
        benefit = koledino_direct_cost - kazan_transit_cost
        return {
            "direct_cost": koledino_direct_cost,
            "transit_cost": kazan_transit_cost,
            "benefit": benefit,
            "is_profitable": benefit > 0,
            "recommendation": "Используйте транзит через Казань" if benefit > 0 else "Прямая поставка выгоднее"
        }
</file>

<file path="backend/analysis_service.py">
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
from sqlalchemy.ext.asyncio import AsyncSession

# Import decomposed parts
from analysis_parts.ai import AIModule
from analysis_parts.economics import EconomicsModule
from analysis_parts.clustering import ClusteringModule
from clickhouse_models import ch_service

logger = logging.getLogger("AI-Service")

class AnalysisService:
    """
    Facade class that aggregates functional modules:
    - AIModule (LLM interactions)
    - EconomicsModule (Calculations & P&L)
    - ClusteringModule (ML)
    """
    def __init__(self):
        self.ai = AIModule()
        self.economics = EconomicsModule()
        self.clustering = ClusteringModule()
        
        try:
            ch_service.connect()
        except Exception as e:
            logger.warning(f"ClickHouse init failed (will retry on usage): {e}")

    # --- Delegations to ClusteringModule ---
    def cluster_keywords(self, keywords: List[str]) -> Dict[str, Any]:
        return self.clustering.cluster_keywords(keywords)

    # --- Delegations to EconomicsModule ---
    def calculate_supply_metrics(
        self, 
        current_stock: int, 
        sales_history: List[Dict[str, Any]], 
        forecast_data: Optional[Dict[str, Any]] = None,
        lead_time_days: int = 7,
        lead_time_sigma: int = 2,
        service_level_z: float = 1.65
    ) -> Dict[str, Any]:
        return self.economics.calculate_supply_metrics(
            current_stock, sales_history, forecast_data, 
            lead_time_days, lead_time_sigma, service_level_z
        )

    async def get_pnl_data(self, user_id: int, date_from: datetime, date_to: datetime, db: AsyncSession) -> List[Dict[str, Any]]:
        return await self.economics.get_pnl_data(user_id, date_from, date_to, db)

    def calculate_metrics(self, raw_data: dict):
        return self.economics.calculate_metrics(raw_data)

    def calculate_transit_benefit(self, volume_liters: int):
        return self.economics.calculate_transit_benefit(volume_liters)

    # --- Delegations to AIModule ---
    def clean_ai_text(self, text: str) -> str:
        return self.ai.clean_ai_text(text)

    def analyze_reviews_with_ai(self, reviews: list, product_name: str) -> Dict[str, Any]:
        return self.ai.analyze_reviews_with_ai(reviews, product_name)

    def generate_product_content(self, keywords: list, tone: str, title_len: int = 100, desc_len: int = 1000):
        return self.ai.generate_product_content(keywords, tone, title_len, desc_len)

# Singleton Instance
analysis_service = AnalysisService()
</file>

<file path="backend/auth_service.py">
import hmac
import hashlib
from urllib.parse import parse_qsl

class AuthService:
    def __init__(self, bot_token: str):
        self.bot_token = bot_token

    def validate_init_data(self, init_data: str) -> bool:
        if not self.bot_token: return True # Debug skip if no token
        try:
            parsed_data = dict(parse_qsl(init_data))
            if 'hash' not in parsed_data: return False
            
            received_hash = parsed_data.pop('hash')
            # Сортировка ключей обязательна по доке Telegram
            data_check_string = "\n".join(f"{k}={v}" for k, v in sorted(parsed_data.items()))

            secret_key = hmac.new(b"WebAppData", self.bot_token.encode(), hashlib.sha256).digest()
            calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()

            return calculated_hash == received_hash
        except: return False
</file>

<file path="backend/bidder_engine.py">
import time
from typing import Optional, Tuple

class PIDController:
    """
    Advanced PID Controller for Real-Time Bidding.
    Features:
    - Anti-Windup (Clamping)
    - Deadband (Dead zone)
    - Derivative Kick Prevention (Derivative on Measurement)
    - Output limiting (Min/Max Bid)
    """
    def __init__(
        self, 
        kp: float, 
        ki: float, 
        kd: float, 
        target_pos: int, 
        min_bid: int, 
        max_bid: int,
        deadband: int = 1
    ):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.target_pos = target_pos
        self.min_bid = min_bid
        self.max_bid = max_bid
        self.deadband = deadband

        # State (usually loaded from external storage in stateless systems)
        self._prev_error = 0.0
        self._integral = 0.0
        self._prev_measurement: Optional[float] = None

    def load_state(self, integral: float, prev_measurement: Optional[float]):
        """Load state from Redis/DB"""
        self._integral = integral
        self._prev_measurement = prev_measurement

    def get_state(self) -> Tuple[float, Optional[float]]:
        """Export state to save in Redis/DB"""
        return self._integral, self._prev_measurement

    def update(self, current_pos: int, current_bid: int, dt: float) -> int:
        """
        Calculates new bid based on position error.
        
        :param current_pos: Current position in auction (1, 2, 3...)
        :param current_bid: Current bid amount (Rubles)
        :param dt: Time delta in seconds since last update
        :return: New calculated bid
        """
        if dt <= 0:
            return current_bid

        # 1. Error Calculation
        # Note: In auction, lower position (1) is better. 
        # If target is 1 and current is 5, error = 5 - 1 = 4 (positive error means we need to increase bid)
        # If target is 5 and current is 1, error = 1 - 5 = -4 (negative error means we can decrease bid)
        error = current_pos - self.target_pos

        # 2. Deadband Check
        if abs(error) <= self.deadband:
            return current_bid

        # 3. Proportional Term
        p_term = self.kp * error

        # 4. Integral Term with Anti-Windup (Clamping)
        # We only accumulate if the output is not saturated, or if the error opposes the saturation
        self._integral += self.ki * error * dt
        
        # Clamp Integral directly to avoid infinite accumulation
        # Heuristic: Integral part shouldn't exceed 50% of the bid range swing
        integral_limit = (self.max_bid - self.min_bid) * 0.5
        self._integral = max(-integral_limit, min(self._integral, integral_limit))

        i_term = self._integral

        # 5. Derivative Term (Derivative on Measurement)
        # Prevents "Kick" when target changes, smooths the output
        if self._prev_measurement is None:
            self._prev_measurement = current_pos
            
        # d(Error)/dt = d(SetPoint - Measurement)/dt = - d(Measurement)/dt (assuming SetPoint is constant)
        derivative = (current_pos - self._prev_measurement) / dt
        d_term = -self.kd * derivative
        
        self._prev_measurement = current_pos

        # 6. Calculate Output
        # Base the change on the P-I-D output
        adjustment = p_term + i_term + d_term
        
        # New Bid = Current Bid + Adjustment
        # We cast to int because bids are usually integers
        new_bid = int(current_bid + adjustment)

        # 7. Output Limiting
        if new_bid < self.min_bid:
            new_bid = self.min_bid
        elif new_bid > self.max_bid:
            new_bid = self.max_bid

        return new_bid
</file>

<file path="backend/bot_service.py">
import os
import logging
import aiohttp
import json

logger = logging.getLogger("BotService")

class BotService:
    def __init__(self):
        self.token = os.getenv("BOT_TOKEN")
        self.api_url = f"https://api.telegram.org/bot{self.token}"

    async def send_message(self, chat_id: int, text: str):
        """Отправка простого текстового сообщения"""
        if not self.token: return
        
        url = f"{self.api_url}/sendMessage"
        payload = {"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
        
        async with aiohttp.ClientSession() as session:
            try:
                await session.post(url, json=payload)
            except Exception as e:
                logger.error(f"Failed to send message to {chat_id}: {e}")

    async def create_invoice_link(self, title: str, description: str, payload: str, amount_stars: int):
        """
        Создание ссылки на оплату в Telegram Stars.
        amount_stars: количество звезд (XTR).
        """
        if not self.token: return None
        
        url = f"{self.api_url}/createInvoiceLink"
        data = {
            "title": title,
            "description": description,
            "payload": payload,
            "provider_token": "", # Для Stars это поле должно быть пустым
            "currency": "XTR",
            "prices": [{"label": "Report", "amount": amount_stars}] # Amount в минимальных единицах, для Stars 1 = 1 Star
        }
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(url, json=data) as resp:
                    res = await resp.json()
                    if res.get("ok"):
                        return res["result"]
                    else:
                        logger.error(f"Invoice error: {res}")
                        return None
            except Exception as e:
                logger.error(f"Create invoice error: {e}")
                return None

bot_service = BotService()
</file>

<file path="backend/celery_app.py">
import os
from celery import Celery
from celery.schedules import crontab

REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379/0")

# Обновляем include, указывая новые модули
celery_app = Celery(
    "wb_bot_worker",
    broker=REDIS_URL,
    backend=REDIS_URL,
    include=[
        'tasks.monitoring',
        'tasks.seo',
        'tasks.finance',
        'tasks.bidder'
    ] 
)

celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="Europe/Moscow",
    enable_utc=True,
    broker_connection_retry_on_startup=True,
    broker_connection_max_retries=None,
    broker_transport_options={
        "visibility_timeout": 3600,
        "health_check_interval": 10,
        "socket_timeout": 15,
        "socket_connect_timeout": 15,
        "socket_keepalive": True,
    },
    worker_prefetch_multiplier=1, 
    task_acks_late=True,
    beat_schedule={
        "update-monitored-items-hourly": {
            "task": "update_all_monitored_items",
            "schedule": crontab(minute=0), 
        },
        "check-new-orders-every-10m": {
            "task": "check_new_orders",
            "schedule": 600.0, 
        },
        "bidder-producer-every-5m": {
            "task": "bidder_producer_task",
            "schedule": 300.0,
        },
        "train-forecasts-daily": {
            "task": "train_forecasting_models",
            "schedule": crontab(hour=3, minute=0),
        }
    }
)
</file>

<file path="backend/clickhouse_models.py">
import os
import logging
import clickhouse_connect
from datetime import datetime

logger = logging.getLogger("ClickHouse")

class ClickHouseService:
    def __init__(self):
        self.host = os.getenv("CLICKHOUSE_HOST", "clickhouse")
        self.port = int(os.getenv("CLICKHOUSE_PORT", 8123))
        self.user = os.getenv("CLICKHOUSE_USER", "default")
        self.password = os.getenv("CLICKHOUSE_PASSWORD", "")
        self.database = os.getenv("CLICKHOUSE_DB", "wb_analytics")
        self.client = None

    def connect(self):
        """Establishes connection to ClickHouse and ensures DB exists."""
        try:
            self.client = clickhouse_connect.get_client(
                host=self.host,
                port=self.port,
                username=self.user,
                password=self.password,
                connect_timeout=10
            )
            # Create DB if not exists
            self.client.command(f"CREATE DATABASE IF NOT EXISTS {self.database}")
            self.init_schema()
            logger.info("✅ ClickHouse connected and schema initialized.")
        except Exception as e:
            logger.error(f"❌ ClickHouse connection failed: {e}")
            raise e

    def get_client(self):
        if not self.client:
            self.connect()
        return self.client

    def init_schema(self):
        """
        Defines the High-Performance OLAP Schema.
        Mirrors WB API v5 /supplier/reportDetailByPeriod.
        Engine: ReplacingMergeTree for deduplication/updates based on rrd_id.
        """
        schema_sql = f"""
        CREATE TABLE IF NOT EXISTS {self.database}.realization_reports (
            -- Identity & Meta
            rrd_id UInt64, -- Unique row ID from WB
            realizationreport_id UInt64, -- Report ID
            supplier_id UInt64, -- Internal User ID (Tenancy)
            
            -- Dimensions (LowCardinality for compression)
            gi_id UInt64,
            subject_name LowCardinality(String), -- Category
            nm_id UInt64, -- SKU
            brand_name LowCardinality(String),
            sa_name String, -- Article
            ts_name String, -- Size
            barcode String,
            doc_type_name LowCardinality(String), -- 'Продажа', 'Возврат'
            office_name LowCardinality(String), -- Warehouse
            supplier_oper_name LowCardinality(String),
            site_country LowCardinality(String),
            
            -- Dates
            create_dt DateTime,
            order_dt DateTime,
            sale_dt DateTime,
            rr_dt DateTime,
            
            -- Metrics (Decimal for Money)
            quantity UInt32,
            retail_price Decimal(18, 2),
            retail_amount Decimal(18, 2),
            sale_percent UInt16,
            commission_percent Decimal(10, 2),
            retail_price_withdisc_rub Decimal(18, 2), -- Actual Revenue
            delivery_amount UInt32,
            return_amount UInt32,
            delivery_rub Decimal(18, 2), -- Logistics Cost
            gi_box_type_name LowCardinality(String),
            product_discount_for_report Decimal(10, 2),
            supplier_promo Decimal(10, 2),
            rid UInt64,
            ppvz_spp_prc Decimal(10, 2),
            ppvz_kvw_prc_base Decimal(10, 2),
            ppvz_kvw_prc Decimal(10, 2),
            sup_rating_prc_up Decimal(10, 2),
            is_kgvp_v2 UInt8,
            ppvz_sales_commission Decimal(18, 2), -- WB Commission
            ppvz_for_pay Decimal(18, 2),
            ppvz_reward Decimal(18, 2),
            acquiring_fee Decimal(18, 2),
            acquiring_bank String,
            ppvz_vw Decimal(18, 2),
            ppvz_vw_nds Decimal(18, 2),
            ppvz_office_id UInt64,
            penalty Decimal(18, 2), -- Fines
            additional_payment Decimal(18, 2),
            rebill_logistic_cost Decimal(18, 2),
            
            -- Versioning
            inserted_at DateTime DEFAULT now()
        ) 
        ENGINE = ReplacingMergeTree(inserted_at)
        ORDER BY (supplier_id, toDate(sale_dt), nm_id, rrd_id)
        TTL sale_dt + INTERVAL 3 YEAR;
        """
        self.client.command(schema_sql)

    def insert_reports(self, reports: list):
        """Batch insert raw reports."""
        if not reports:
            return
        
        # Ensure we use the connected client
        client = self.get_client()
        
        # Columns must match the Create Table order/structure
        # In production, use Pandas DataFrame for faster inserts, but here we use native list
        # We assume 'reports' is a list of dictionaries matching the DB columns
        try:
            client.insert(
                f"{self.database}.realization_reports",
                reports,
                column_names=[k for k in reports[0].keys()]
            )
        except Exception as e:
            logger.error(f"ClickHouse Insert Error: {e}")
            raise e

# Singleton instance
ch_service = ClickHouseService()
</file>

<file path="backend/database.py">
import os
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, BigInteger, Text, Float
from sqlalchemy.orm import sessionmaker, declarative_base, relationship
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy import create_engine
from datetime import datetime

# Настройки подключения
DATABASE_URL_ASYNC = os.getenv("DATABASE_URL", "postgresql+asyncpg://postgres:wb_secret_password@db:5432/wb_monitor")

# Для синхронного драйвера (Celery/Migrate)
if "+asyncpg" in DATABASE_URL_ASYNC:
    DATABASE_URL_SYNC = DATABASE_URL_ASYNC.replace("+asyncpg", "")
else:
    DATABASE_URL_SYNC = DATABASE_URL_ASYNC

# 1. Асинхронный движок (FastAPI)
engine_async = create_async_engine(DATABASE_URL_ASYNC, echo=False)
AsyncSessionLocal = sessionmaker(bind=engine_async, class_=AsyncSession, expire_on_commit=False)

# 2. Синхронный движок (Celery)
engine_sync = create_engine(DATABASE_URL_SYNC, echo=False)
SyncSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine_sync)

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    telegram_id = Column(BigInteger, unique=True, index=True)
    username = Column(String, nullable=True)
    first_name = Column(String, nullable=True)
    is_admin = Column(Boolean, default=False)
    subscription_plan = Column(String, default="free")
    
    # Поля API WB
    wb_api_token = Column(String, nullable=True)
    last_order_check = Column(DateTime, nullable=True)
    
    # SaaS поля
    subscription_expires_at = Column(DateTime, nullable=True)
    is_recurring = Column(Boolean, default=False)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Связи
    items = relationship("MonitoredItem", back_populates="owner", cascade="all, delete-orphan")
    history = relationship("SearchHistory", back_populates="user", cascade="all, delete-orphan")
    costs = relationship("ProductCost", back_populates="user", cascade="all, delete-orphan")
    seo_keywords = relationship("SeoPosition", back_populates="user", cascade="all, delete-orphan")
    bidder_logs = relationship("BidderLog", back_populates="user", cascade="all, delete-orphan")
    bidder_settings = relationship("BidderSettings", back_populates="user", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="user", cascade="all, delete-orphan")

class Payment(Base):
    __tablename__ = "payments"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    
    provider_payment_id = Column(String, index=True)
    amount = Column(Integer)
    currency = Column(String, default="RUB")
    status = Column(String)
    plan_id = Column(String)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    confirmed_at = Column(DateTime, nullable=True)

    user = relationship("User", back_populates="payments")

class ProductCost(Base):
    __tablename__ = "product_costs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    sku = Column(BigInteger, index=True)
    cost_price = Column(Integer, default=0)
    updated_at = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User", back_populates="costs")

class MonitoredItem(Base):
    __tablename__ = "monitored_items"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    sku = Column(BigInteger, index=True)
    name = Column(String, nullable=True)
    brand = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    owner = relationship("User", back_populates="items")
    prices = relationship("PriceHistory", back_populates="item", cascade="all, delete-orphan")

class PriceHistory(Base):
    __tablename__ = "price_history"
    id = Column(Integer, primary_key=True, index=True)
    item_id = Column(Integer, ForeignKey("monitored_items.id"))
    wallet_price = Column(Integer)
    standard_price = Column(Integer)
    base_price = Column(Integer)
    recorded_at = Column(DateTime, default=datetime.utcnow)
    item = relationship("MonitoredItem", back_populates="prices")

class SearchHistory(Base):
    __tablename__ = "search_history"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    sku = Column(BigInteger)
    request_type = Column(String) 
    title = Column(String)
    result_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    user = relationship("User", back_populates="history")

class SeoPosition(Base):
    __tablename__ = "seo_positions"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    sku = Column(BigInteger)
    keyword = Column(String)
    position = Column(Integer, default=0)
    last_check = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User", back_populates="seo_keywords")

class BidderSettings(Base):
    """
    Настройки автобиддера для конкретной кампании.
    """
    __tablename__ = "bidder_settings"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    campaign_id = Column(BigInteger, unique=True, index=True)
    
    is_active = Column(Boolean, default=False)
    target_pos = Column(Integer, default=1)   # Целевая позиция
    max_bid = Column(Integer, default=500)    # Максимальная ставка (RUB)
    min_bid = Column(Integer, default=125)    # Минимальная ставка
    
    # Safety Layers
    target_cpa = Column(Integer, default=0)   # Целевая цена действия (0 = выкл)
    max_cpm = Column(Integer, default=2000)   # Хард лимит CPM
    strategy = Column(String, default="pid")  # 'pid', 'shadowing', 'fixed'
    
    updated_at = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User", back_populates="bidder_settings")

class BidderLog(Base):
    __tablename__ = "bidder_logs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    campaign_id = Column(BigInteger, index=True)
    
    current_pos = Column(Integer)
    target_pos = Column(Integer)
    
    previous_bid = Column(Integer)
    calculated_bid = Column(Integer)
    
    saved_amount = Column(Integer, default=0)
    
    action = Column(String) # 'update', 'safe_mode', 'paused', 'low_ctr', 'cpa_guard'
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User", back_populates="bidder_logs")

async def init_db():
    async with engine_async.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session
</file>

<file path="backend/dependencies.py">
import os
import json
import logging
import redis
from urllib.parse import parse_qsl
from fastapi import Header, Query, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text
from sqlalchemy.exc import IntegrityError

from database import get_db, User
from auth_service import AuthService
from celery_app import REDIS_URL

logger = logging.getLogger("Dependencies")

# Настройки
auth_manager = AuthService(os.getenv("BOT_TOKEN", ""))
SUPER_ADMIN_IDS = [901378787]

# Redis Client (Singleton for DI)
try:
    r_client = redis.from_url(REDIS_URL, decode_responses=True)
except Exception as e:
    logger.error(f"Redis connect error in dependencies: {e}")
    r_client = None

def get_redis_client():
    return r_client

async def get_current_user(
    x_tg_data: str = Header(None, alias="X-TG-Data"),
    x_tg_data_query: str = Query(None, alias="x_tg_data"),
    db: AsyncSession = Depends(get_db)
) -> User:
    token = x_tg_data if x_tg_data else x_tg_data_query
    user_data_dict = None

    if token:
        if auth_manager.validate_init_data(token):
            try:
                parsed = dict(parse_qsl(token))
                if 'user' in parsed: 
                    user_data_dict = json.loads(parsed['user'])
            except Exception as e: 
                logger.error(f"Auth parse error: {e}")
        else:
             # Fallback для локальной разработки
             try:
                parsed = dict(parse_qsl(token))
                if 'user' in parsed: 
                    user_data_dict = json.loads(parsed['user'])
             except:
                 pass

    # Fallback для отладки
    if not user_data_dict and os.getenv("DEBUG_MODE", "False") == "True":
         user_data_dict = {"id": 901378787, "username": "debug_user", "first_name": "Debug"}

    if not user_data_dict:
        raise HTTPException(status_code=401, detail="Unauthorized")

    tg_id = user_data_dict.get('id')
    if not tg_id:
        raise HTTPException(status_code=401, detail="Invalid user data")

    # 1. Сначала пробуем найти
    stmt = select(User).where(User.telegram_id == tg_id)
    result = await db.execute(stmt)
    user = result.scalars().first()

    is_super = tg_id in SUPER_ADMIN_IDS

    if not user:
        # 2. Если нет - пробуем создать через RAW SQL с ON CONFLICT DO NOTHING
        # Это предотвращает ошибку "duplicate key value violates unique constraint" в логах Postgres
        # и устраняет состояние гонки.
        try:
            username = user_data_dict.get('username')
            first_name = user_data_dict.get('first_name')
            plan = "business" if is_super else "free"
            is_adm = is_super
            
            # Используем text() для raw query (надежнее всего для upsert в данной конфигурации)
            insert_query = text("""
                INSERT INTO users (telegram_id, username, first_name, is_admin, subscription_plan, created_at)
                VALUES (:tg_id, :username, :first_name, :is_admin, :plan, NOW())
                ON CONFLICT (telegram_id) DO NOTHING
            """)
            
            await db.execute(insert_query, {
                "tg_id": tg_id,
                "username": username,
                "first_name": first_name,
                "is_admin": is_adm,
                "plan": plan
            })
            await db.commit()
            
            # 3. Достаем юзера заново (он точно есть теперь)
            result = await db.execute(stmt)
            user = result.scalars().first()
            
        except Exception as e:
            await db.rollback()
            logger.error(f"User creation error: {e}")
            raise HTTPException(status_code=500, detail="Database error")
            
    # Если юзер уже был, обновляем админские права если нужно
    if user and is_super and (not user.is_admin or user.subscription_plan != "business"):
        user.is_admin = True
        user.subscription_plan = "business"
        db.add(user)
        await db.commit()
    
    return user
</file>

<file path="backend/docker-entrypoint.sh">
#!/bin/bash
set -e

# Функция ожидания доступности порта (простая реализация на bash)
wait_for_port() {
  local host="$1"
  local port="$2"
  local timeout=30
  local start_time=$(date +%s)

  echo "⏳ Waiting for $host:$port..."
  while ! nc -z "$host" "$port" >/dev/null 2>&1; do
    sleep 1
    local current_time=$(date +%s)
    if (( current_time - start_time > timeout )); then
      echo "❌ Timeout waiting for $host:$port"
      return 1
    fi
  done
  echo "✅ $host:$port is available"
}

# Ждем базу данных (хост db, порт 5432)
# Используем python-скрипт или просто попытку миграции для надежности,
# но здесь просто запускаем миграцию, она сама упадет/повторит если что.

echo "🚀 Running migrations..."
python migrate.py

# Запускаем основную команду (переданную из Dockerfile или docker-compose)
echo "🔥 Starting command: $@"
exec "$@"
</file>

<file path="backend/Dockerfile">
FROM python:3.9-slim

# 1. Установка системных утилит, ШРИФТОВ, Edge и netcat (для entrypoint)
RUN apt-get update && apt-get install -y \
    wget gnupg unzip curl fontconfig fonts-dejavu libpq-dev gcc netcat-openbsd \
    && curl -sSL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > /usr/share/keyrings/microsoft.gpg \
    && echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main" > /etc/apt/sources.list.d/microsoft-edge.list \
    && apt-get update && apt-get install -y microsoft-edge-stable \
    && apt-get clean

# 2. Драйвер (предполагаем, что файл лежит рядом с Dockerfile)
COPY msedgedriver /usr/local/bin/msedgedriver
RUN chmod +x /usr/local/bin/msedgedriver

# 3. Настройка окружения
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 4. Копируем код
COPY . .

# 5. Копируем и настраиваем Entrypoint
COPY docker-entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/docker-entrypoint.sh

EXPOSE 8000

# Используем Entrypoint для преднастройки (миграций) перед запуском
ENTRYPOINT ["docker-entrypoint.sh"]

# Команда по умолчанию (если не переопределена в docker-compose)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="backend/forecasting.py">
import logging
import pandas as pd
from prophet import Prophet
from typing import List, Dict, Any, Optional

logger = logging.getLogger("ForecastingService")

# Отключаем лишний шум от Prophet/Stan
logging.getLogger("cmdstanpy").setLevel(logging.ERROR)
logging.getLogger("prophet").setLevel(logging.ERROR)

def forecast_demand(
    sales_history: List[Dict[str, Any]], 
    horizon_days: int = 30
) -> Dict[str, Any]:
    """
    Прогнозирование спроса с использованием Facebook Prophet.
    
    :param sales_history: Список словарей [{'date': 'YYYY-MM-DD', 'qty': int}, ...]
    :param horizon_days: Горизонт прогноза в днях
    :return: Словарь с прогнозом и метриками качества
    """
    if not sales_history or len(sales_history) < 14:
        # Если истории слишком мало (< 2 недель), возвращаем наивный прогноз или ошибку
        return {
            "status": "error", 
            "message": "Not enough data (min 14 days required)"
        }

    try:
        # 1. Подготовка данных для Prophet (ds, y)
        df = pd.DataFrame(sales_history)
        df['ds'] = pd.to_datetime(df['date'])
        df['y'] = df['qty']
        
        # Убираем выбросы (простейшая фильтрация отрицательных продаж, если это возвраты)
        # В идеале возвраты надо обрабатывать отдельно, но для MVP считаем чистые продажи
        df = df[df['y'] >= 0]

        # 2. Инициализация и настройка модели
        # weekly_seasonality=True: для ритейла важно (выходные vs будни)
        # daily_seasonality=False: у нас данные по дням
        m = Prophet(
            daily_seasonality=False,
            weekly_seasonality=True,
            yearly_seasonality='auto', # Включится автоматически, если данных > 1 года
            interval_width=0.95, # Доверительный интервал 95%
        )

        # 3. Добавление праздников РФ
        m.add_country_holidays(country_name='RU')

        # 4. Обучение
        m.fit(df)

        # 5. Создание фрейма для прогноза
        future = m.make_future_dataframe(periods=horizon_days)
        
        # 6. Прогноз
        forecast = m.predict(future)

        # 7. Пост-обработка результатов
        # Нам нужны только будущие значения (последние horizon_days)
        future_forecast = forecast.tail(horizon_days)
        
        # Prophet может выдавать отрицательные значения (yhat < 0) при падении тренда,
        # но спрос не может быть отрицательным. Клиппим нулем.
        result_points = []
        total_forecast_sum = 0.0

        for _, row in future_forecast.iterrows():
            yhat = max(0, row['yhat'])
            yhat_lower = max(0, row['yhat_lower'])
            yhat_upper = max(0, row['yhat_upper'])
            
            result_points.append({
                "date": row['ds'].strftime("%Y-%m-%d"),
                "yhat": round(yhat, 2),
                "yhat_lower": round(yhat_lower, 2),
                "yhat_upper": round(yhat_upper, 2)
            })
            total_forecast_sum += yhat

        return {
            "status": "success",
            "forecast_points": result_points,
            "total_forecast_qty": round(total_forecast_sum, 0),
            "daily_avg_forecast": round(total_forecast_sum / horizon_days, 2)
        }

    except Exception as e:
        logger.error(f"Prophet forecasting failed: {e}")
        return {"status": "error", "message": str(e)}
</file>

<file path="backend/main.py">
import logging
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_cache import FastAPICache
from fastapi_cache.backends.redis import RedisBackend
from redis import asyncio as aioredis
from dotenv import load_dotenv

from celery_app import REDIS_URL
from routers import users, finance, monitoring, seo, ai, payments, admin, bidder

load_dotenv()
logger = logging.getLogger("API")

app = FastAPI(title="WB Analytics Platform")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Подключение роутеров
app.include_router(users.router)
app.include_router(finance.router)
app.include_router(monitoring.router)
app.include_router(seo.router)
app.include_router(ai.router)
app.include_router(payments.router)
app.include_router(admin.router)
app.include_router(bidder.router) # Новый роутер

@app.on_event("startup")
async def on_startup(): 
    try:
        r = aioredis.from_url(REDIS_URL, encoding="utf8", decode_responses=True)
        FastAPICache.init(RedisBackend(r), prefix="fastapi-cache")
        logger.info("✅ Redis cache initialized successfully")
    except Exception as e:
        logger.error(f"❌ Failed to initialize Redis cache: {e}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="backend/migrate.py">
import logging
import time
import os
from sqlalchemy import text
from sqlalchemy.exc import OperationalError
from database import engine_sync, Base

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("DB_Migration")

def wait_for_db(retries=30, delay=2):
    """Ожидание готовности базы данных к подключениям"""
    logger.info("⏳ Ожидание готовности БД...")
    for i in range(retries):
        try:
            with engine_sync.connect() as conn:
                conn.execute(text("SELECT 1"))
            logger.info("✅ Database is ready.")
            return True
        except OperationalError as e:
            logger.warning(f"⏳ Database not ready yet (Attempt {i+1}/{retries})... Error: {e}")
            time.sleep(delay)
        except Exception as e:
            logger.error(f"❌ Unexpected error connecting to DB: {e}")
            time.sleep(delay)
    return False

def migrate():
    # Читаем флаг из environment. По умолчанию True, но в docker-compose для воркеров ставим False
    run_migrations = os.getenv("RUN_MIGRATIONS", "true").lower() == "true"
    
    logger.info(f"🚀 Старт проверки БД (Режим мигратора: {run_migrations})...")
    
    if not wait_for_db():
        logger.error("❌ Не удалось подключиться к БД. Выход.")
        return

    if not run_migrations:
        logger.info("✋ Я воркер, миграции не запускаю. Просто жду БД. Готов к работе.")
        return

    # Только API (или тот, у кого RUN_MIGRATIONS=true) создает таблицы
    try:
        logger.info("🛠 Создание/проверка таблиц...")
        Base.metadata.create_all(bind=engine_sync)
        logger.info("✅ Структура таблиц проверена/создана.")
    except Exception as e:
        logger.error(f"❌ Ошибка создания таблиц: {e}")
        return

    # Альтеры для существующих таблиц (защищенные try-except)
    try:
        with engine_sync.connect() as conn:
            trans = conn.begin()
            try:
                conn.execute(text("ALTER TABLE users ADD COLUMN IF NOT EXISTS wb_api_token VARCHAR"))
                conn.execute(text("ALTER TABLE users ADD COLUMN IF NOT EXISTS last_order_check TIMESTAMP WITHOUT TIME ZONE"))
                trans.commit()
                logger.info("✅ Альтеры колонок применены.")
            except Exception:
                trans.rollback()
                # Игнорируем ошибки "already exists" молча, чтобы не пугать в логах
                pass
    except Exception as e:
         logger.error(f"❌ Ошибка подключения для альтеров: {e}")

    logger.info("🎉 Миграция завершена успешно!")

if __name__ == "__main__":
    migrate()
</file>

<file path="backend/parser_parts/__init__.py">
# Parser Parts Module
</file>

<file path="backend/parser_parts/basket.py">
import aiohttp
import asyncio
from typing import Optional, Dict, Any

class BasketFinder:
    @staticmethod
    def _calc_basket_static(sku: int) -> str:
        vol = sku // 100000
        if 0 <= vol <= 143: return "01"
        if 144 <= vol <= 287: return "02"
        if 288 <= vol <= 431: return "03"
        if 432 <= vol <= 719: return "04"
        if 720 <= vol <= 1007: return "05"
        if 1008 <= vol <= 1061: return "06"
        if 1062 <= vol <= 1115: return "07"
        if 1116 <= vol <= 1169: return "08"
        if 1170 <= vol <= 1313: return "09"
        if 1314 <= vol <= 1601: return "10"
        if 1602 <= vol <= 1655: return "11"
        if 1656 <= vol <= 1919: return "12"
        if 1920 <= vol <= 2045: return "13"
        if 2046 <= vol <= 2189: return "14"
        if 2190 <= vol <= 2405: return "15"
        if 2406 <= vol <= 2621: return "16"
        if 2622 <= vol <= 2837: return "17"
        return "18"

    async def _check_url(self, session, url, host, sku):
        try:
            async with session.get(url, timeout=1.5) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    vol = url.split('vol')[1].split('/')[0]
                    part = url.split('part')[1].split('/')[0]
                    data['image_url'] = f"https://basket-{host}.wbbasket.ru/vol{vol}/part{part}/{sku}/images/c246x328/1.webp"
                    return data
        except:
            pass
        return None

    async def find_card_json(self, sku: int) -> Optional[Dict[str, Any]]:
        """Поиск card.json brute-force методом (до 50 корзины)"""
        vol = sku // 100000
        part = sku // 1000
        
        calc_host = self._calc_basket_static(sku)
        
        # Приоритет: расчетный хост -> новые хосты (18-50) -> старые (1-17)
        hosts_priority = [calc_host] + [f"{i:02d}" for i in range(18, 51)] + [f"{i:02d}" for i in range(1, 18)]
        hosts = list(dict.fromkeys(hosts_priority)) 

        async with aiohttp.ClientSession() as session:
            # Батчинг запросов по 15 штук
            for i in range(0, len(hosts), 15):
                batch = hosts[i:i+15]
                tasks = []
                for host in batch:
                    url = f"https://basket-{host}.wbbasket.ru/vol{vol}/part{part}/{sku}/info/ru/card.json"
                    tasks.append(self._check_url(session, url, host, sku))
                
                results = await asyncio.gather(*tasks)
                for res in results:
                    if res: return res
        return None
</file>

<file path="backend/parser_parts/browser.py">
import os
import re
from selenium import webdriver
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.edge.options import Options as EdgeOptions
from selenium.webdriver.common.by import By
from .config import logger, get_random_ua
from .proxy import ProxyManager

class BrowserManager:
    def __init__(self):
        self.headless = os.getenv("HEADLESS", "True").lower() == "true"
        self.proxy_manager = ProxyManager()

    def init_driver(self):
        edge_options = EdgeOptions()
        if self.headless: 
            edge_options.add_argument("--headless=new")
        
        edge_options.add_argument("--no-sandbox")
        edge_options.add_argument("--disable-dev-shm-usage")
        edge_options.add_argument("--disable-gpu")
        edge_options.add_argument("--disable-blink-features=AutomationControlled")
        edge_options.add_argument("--window-size=1920,1080")
        
        # Установка прокси расширения
        plugin_path = self.proxy_manager.create_proxy_auth_extension()
        if plugin_path:
            edge_options.add_extension(plugin_path)
            
        edge_options.add_argument(f"user-agent={get_random_ua()}")
        
        try:
            driver_bin = '/usr/local/bin/msedgedriver'
            service = EdgeService(executable_path=driver_bin)
            driver = webdriver.Edge(service=service, options=edge_options)
            driver.set_page_load_timeout(120)
            return driver
        except Exception as e:
            logger.error(f"Driver Init Error: {e}")
            raise e

    @staticmethod
    def extract_price(driver, selector):
        try:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            for el in elements:
                text = el.get_attribute('textContent')
                if not text: continue
                text = text.replace('\xa0', '').replace('&nbsp;', '').replace(' ', '').replace('₽', '')
                digits = re.sub(r'[^\d]', '', text)
                if digits: return int(digits)
        except: pass
        return 0
</file>

<file path="backend/parser_parts/config.py">
import os
import sys
import logging
import random
from dotenv import load_dotenv

load_dotenv()

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | [%(name)s] %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger("WB-Parser")
logging.getLogger('WDM').setLevel(logging.ERROR)

# Гео-зоны для поиска
GEO_ZONES = {
    "moscow": "-1257786",
    "spb": "-1257262",
    "kazan": "-1255942",
    "krasnodar": "-1257233",
    "novosibirsk": "-1257493"
}

# User Agents для ротации
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15"
]

def get_random_ua():
    return random.choice(USER_AGENTS)
</file>

<file path="backend/parser_parts/product.py">
import os
import time
import random
import logging
import json
import re
import sys
import requests
import asyncio
import aiohttp
import zipfile
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
from selenium import webdriver
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.edge.options import Options as EdgeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

load_dotenv()

# Настройка логгера
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | [%(name)s] %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger("ProductParser")
logging.getLogger('WDM').setLevel(logging.ERROR)

# Константы для Geo Tracking
GEO_ZONES = {
    "moscow": "-1257786",
    "spb": "-1257262",
    "kazan": "-1255942",
    "krasnodar": "-1257233",
    "novosibirsk": "-1257493"
}

class ProductParser:
    """
    Восстановленная логика парсинга Wildberries (Legacy/Stable).
    Использует перебор корзин для поиска card.json и Selenium для цен.
    """
    def __init__(self):
        self.headless = os.getenv("HEADLESS", "True").lower() == "true"
        self.proxy_user = os.getenv("PROXY_USER")
        self.proxy_pass = os.getenv("PROXY_PASS")
        self.proxy_host = os.getenv("PROXY_HOST")
        self.proxy_port = os.getenv("PROXY_PORT")
        
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        ]

    # --- ЛОГИКА ПОИСКА КОРЗИН (Legacy/Core) ---
    
    def _calc_basket_static(self, sku: int) -> str:
        vol = sku // 100000
        if 0 <= vol <= 143: return "01"
        if 144 <= vol <= 287: return "02"
        if 288 <= vol <= 431: return "03"
        if 432 <= vol <= 719: return "04"
        if 720 <= vol <= 1007: return "05"
        if 1008 <= vol <= 1061: return "06"
        if 1062 <= vol <= 1115: return "07"
        if 1116 <= vol <= 1169: return "08"
        if 1170 <= vol <= 1313: return "09"
        if 1314 <= vol <= 1601: return "10"
        if 1602 <= vol <= 1655: return "11"
        if 1656 <= vol <= 1919: return "12"
        if 1920 <= vol <= 2045: return "13"
        if 2046 <= vol <= 2189: return "14"
        if 2190 <= vol <= 2405: return "15"
        if 2406 <= vol <= 2621: return "16"
        if 2622 <= vol <= 2837: return "17"
        return "18"

    async def _find_card_json(self, sku: int):
        """Поиск card.json brute-force методом (до 50 корзины)"""
        vol = sku // 100000
        part = sku // 1000
        
        calc_host = self._calc_basket_static(sku)
        
        # Приоритет: расчетный хост, затем популярные, затем все остальные
        hosts_priority = [calc_host] + [f"{i:02d}" for i in range(1, 20)] + [f"{i:02d}" for i in range(20, 51)]
        hosts = list(dict.fromkeys(hosts_priority)) 

        async with aiohttp.ClientSession() as session:
            # Батчинг запросов по 15 штук
            for i in range(0, len(hosts), 15):
                batch = hosts[i:i+15]
                tasks = []
                for host in batch:
                    url = f"https://basket-{host}.wbbasket.ru/vol{vol}/part{part}/{sku}/info/ru/card.json"
                    tasks.append(self._check_url(session, url, host))
                
                results = await asyncio.gather(*tasks)
                for res in results:
                    if res: return res
        return None

    async def _check_url(self, session, url, host):
        try:
            async with session.get(url, timeout=1.5) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    vol = url.split('vol')[1].split('/')[0]
                    part = url.split('part')[1].split('/')[0]
                    sku = url.split('/')[5]
                    data['image_url'] = f"https://basket-{host}.wbbasket.ru/vol{vol}/part{part}/{sku}/images/c246x328/1.webp"
                    return data
        except: pass
        return None

    # --- SELENIUM SETUP ---
    def _create_proxy_auth_extension(self, user, pw, host, port):
        folder_path = "proxy_ext"
        if not os.path.exists(folder_path): os.makedirs(folder_path)
        manifest_json = json.dumps({"version": "1.0.0", "manifest_version": 2, "name": "Edge Proxy", "permissions": ["proxy", "tabs", "unlimitedStorage", "storage", "<all_urls>", "webRequest", "webRequestBlocking"], "background": {"scripts": ["background.js"]}})
        session_id = ''.join(random.choices("abcdefghijklmnopqrstuvwxyz0123456789", k=10))
        auth_user = f"{user}-session-{session_id};country-ru"
        background_js = """
        var config = { mode: "fixed_servers", rules: { singleProxy: { scheme: "http", host: "%s", port: parseInt(%s) }, bypassList: ["localhost"] } };
        chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});
        chrome.webRequest.onAuthRequired.addListener(function(details) { return { authCredentials: { username: "%s", password: "%s" } }; }, {urls: ["<all_urls>"]}, ['blocking']);
        """ % (host, port, auth_user, pw)
        extension_path = os.path.join(folder_path, "proxy_auth_plugin.zip")
        with zipfile.ZipFile(extension_path, 'w') as zp:
            zp.writestr("manifest.json", manifest_json)
            zp.writestr("background.js", background_js)
        return extension_path

    def _init_driver(self):
        edge_options = EdgeOptions()
        if self.headless: edge_options.add_argument("--headless=new")
        edge_options.add_argument("--no-sandbox")
        edge_options.add_argument("--disable-dev-shm-usage")
        edge_options.add_argument("--disable-gpu")
        edge_options.add_argument("--disable-blink-features=AutomationControlled")
        
        if self.proxy_host:
            plugin_path = self._create_proxy_auth_extension(self.proxy_user, self.proxy_pass, self.proxy_host, self.proxy_port)
            edge_options.add_extension(plugin_path)
            
        edge_options.add_argument("--window-size=1920,1080")
        ua = random.choice(self.user_agents)
        edge_options.add_argument(f"user-agent={ua}")
        
        try:
            driver_bin = '/usr/local/bin/msedgedriver'
            service = EdgeService(executable_path=driver_bin)
            driver = webdriver.Edge(service=service, options=edge_options)
        except Exception as e:
            logger.error(f"Driver Init Error: {e}")
            raise e
        driver.set_page_load_timeout(120)
        return driver

    def _extract_price(self, driver, selector):
        try:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            for el in elements:
                text = el.get_attribute('textContent')
                if not text: continue
                text = text.replace('\xa0', '').replace('&nbsp;', '').replace(' ', '').replace('₽', '')
                digits = re.sub(r'[^\d]', '', text)
                if digits: return int(digits)
        except: pass
        return 0

    # --- МЕТОДЫ ДЛЯ API / ROUTER ---

    async def get_review_stats(self, sku: int):
        """
        Метод для 'Check' этапа на фронтенде. 
        Возвращает метаданные и РЕАЛЬНОЕ кол-во отзывов из card.json.
        """
        logger.info(f"--- CHECK STATS SKU: {sku} ---")
        try:
            card_data = await self._find_card_json(sku)
            if not card_data: 
                return {"status": "error", "message": "Товар не найден (card.json not found)"}
            
            # Извлекаем кол-во отзывов
            feedbacks_count = card_data.get('feedbacks') or card_data.get('feedbackCount') or 0
            
            return {
                "sku": sku,
                "name": card_data.get('imt_name') or card_data.get('subj_name'),
                "image": card_data.get('image_url'),
                "total_reviews": feedbacks_count, # Это значение пойдет в Max ползунка
                "status": "success"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    def get_product_data(self, sku: int):
        """Парсинг цен (оставлен для совместимости с task)"""
        # (Код парсинга цен Selenium, идентичный вашему, для краткости опущен, 
        # но так как я должен вернуть полный файл - вставляю полную версию из вашего примера)
        logger.info(f"--- ПАРСИНГ ЦЕН SKU: {sku} ---")
        static_info = {"name": f"Товар {sku}", "brand": "WB", "image": ""}
        total_qty = 0

        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            data = loop.run_until_complete(self._find_card_json(sku))
            loop.close()
            
            if data:
                static_info["name"] = data.get('imt_name') or data.get('subj_name')
                static_info["brand"] = data.get('selling', {}).get('brand_name')
                static_info["image"] = data.get('image_url')
                
                sizes = data.get('sizes', [])
                for size in sizes:
                    stocks = size.get('stocks', [])
                    for s in stocks: total_qty += s.get('qty', 0)
        except Exception as e:
            logger.warning(f"Static fail: {e}")

        for attempt in range(1, 4):
            driver = None
            try:
                driver = self._init_driver()
                url = f"https://www.wildberries.ru/catalog/{sku}/detail.aspx?targetUrl=GP"
                driver.get(url)
                time.sleep(15) 
                driver.execute_script("window.scrollTo(0, 400);")
                try:
                    WebDriverWait(driver, 15).until(EC.presence_of_element_located((By.CSS_SELECTOR, ".price-block__wallet-price, .price-block__final-price, [class*='walletPrice']")))
                except: pass

                try:
                    p_json = driver.execute_script("return window.staticModel ? JSON.stringify(window.staticModel) : null;")
                    if p_json:
                        d = json.loads(p_json)
                        price = d.get('price') or (d['products'][0] if 'products' in d else {})
                        wallet = int(price.get('clientPriceU', 0)/100) or int(price.get('totalPrice', 0)/100)
                        if wallet > 0:
                            return {
                                "id": sku, "name": static_info["name"], "brand": static_info["brand"],
                                "image": static_info["image"], "stock_qty": total_qty,
                                "prices": {"wallet_purple": wallet, "standard_black": int(price.get('salePriceU',0)/100), "base_crossed": int(price.get('priceU',0)/100)},
                                "status": "success"
                            }
                except: pass
                wallet = self._extract_price(driver, ".price-block__wallet-price, [class*='walletPrice']")
                standard = self._extract_price(driver, ".price-block__final-price, [class*='priceBlockFinal']")
                base = self._extract_price(driver, ".price-block__old-price, [class*='priceBlockOld']")
                if wallet == 0 and standard > 0: wallet = standard
                if wallet > 0:
                    return {"id": sku, "name": static_info["name"], "brand": static_info["brand"], "image": static_info["image"], "stock_qty": total_qty, "prices": {"wallet_purple": wallet, "standard_black": standard, "base_crossed": base}, "status": "success"}
            except Exception as e:
                logger.error(f"Price attempt {attempt} error: {e}")
            finally:
                if driver: driver.quit()
        return {"id": sku, "status": "error", "message": "Failed to parse prices after retries"}

    def get_full_product_info(self, sku: int, limit: int = 50):
        """
        Основной метод парсинга отзывов.
        Восстановлен из вашего файла.
        """
        logger.info(f"--- АНАЛИЗ ОТЗЫВОВ SKU: {sku} (Limit: {limit}) ---")
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            static_data = loop.run_until_complete(self._find_card_json(sku))
            loop.close()

            if not static_data: return {"status": "error", "message": "Card not found"}
            root_id = static_data.get('root') or static_data.get('root_id') or static_data.get('imt_id')
            if not root_id: return {"status": "error", "message": "Root ID not found"}

            # Эндпоинты из старого файла
            endpoints = [
                f"https://feedbacks1.wb.ru/feedbacks/v1/{root_id}",
                f"https://feedbacks2.wb.ru/feedbacks/v1/{root_id}",
                f"https://feedbacks-api.wildberries.ru/api/v1/feedbacks?isAnswered=false&take={limit}&skip=0&nmId={sku}&imtId={root_id}"
            ]
            
            feed_data = None
            headers = {"User-Agent": random.choice(self.user_agents)}
            
            for url in endpoints:
                try:
                    r = requests.get(url, headers=headers, timeout=10)
                    if r.status_code == 200:
                        feed_data = r.json()
                        break
                except: continue
            
            if not feed_data: return {"status": "error", "message": "API отзывов недоступен"}

            raw_feedbacks = feed_data.get('feedbacks') or feed_data.get('data', {}).get('feedbacks') or []
            valuation = feed_data.get('valuation') or feed_data.get('data', {}).get('valuation', 0)
            
            reviews = []
            for f in raw_feedbacks:
                txt = f.get('text', '')
                if txt:
                    reviews.append({"text": txt, "rating": f.get('productValuation', 5)})
                if len(reviews) >= limit: break
            
            return {
                "sku": sku,
                "image": static_data.get('image_url'),
                "rating": float(valuation),
                "reviews": reviews,
                "reviews_count": len(reviews),
                "status": "success"
            }

        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def get_seo_data(self, sku: int):
        # (Код SEO из вашего файла)
        logger.info(f"--- SEO PARSE SKU: {sku} ---")
        try:
            card_data = await self._find_card_json(sku)
            if not card_data: return {"status": "error", "message": "Card not found"}
            keywords = []
            name = card_data.get('imt_name') or card_data.get('subj_name')
            if name: keywords.append(name)
            subj = card_data.get('subj_name')
            if subj and subj != name: keywords.append(subj)
            options = card_data.get('options', [])
            if not options:
                grouped = card_data.get('grouped_options', [])
                for group in grouped:
                    if group.get('options'): options.extend(group.get('options'))
            stop_values = ['нет', 'да', 'отсутствует', 'без рисунка', 'китай', 'россия', '0', '1', '2', '3']
            for opt in options:
                val = str(opt.get('value', '')).strip()
                name_param = str(opt.get('name', '')).lower()
                if not val or val.lower() in stop_values or len(val) < 2: continue 
                if val.isdigit() and "год" not in name_param: continue
                if "состав" in name_param or "назначение" in name_param or "рисунок" in name_param or "фактура" in name_param:
                    parts = re.split(r'[,/]', val)
                    for p in parts: keywords.append(p.strip())
                else: keywords.append(val)
            clean_keywords = []
            seen = set()
            for k in keywords:
                k_clean = re.sub(r'[^\w\s-]', '', k).strip()
                if k_clean and k_clean.lower() not in seen:
                    seen.add(k_clean.lower())
                    clean_keywords.append(k_clean)
            return {"sku": sku, "name": name, "image": card_data.get('image_url'), "keywords": clean_keywords[:40], "status": "success"}
        except Exception as e:
            logger.error(f"SEO Parse Error: {e}")
            return {"status": "error", "message": str(e)}
</file>

<file path="backend/parser_parts/proxy.py">
import os
import json
import random
import zipfile
from typing import Optional
from .config import logger

class ProxyManager:
    def __init__(self):
        self.user = os.getenv("PROXY_USER")
        self.password = os.getenv("PROXY_PASS")
        self.host = os.getenv("PROXY_HOST")
        self.port = os.getenv("PROXY_PORT")

    def get_aiohttp_proxy(self, rotate: bool = False) -> Optional[str]:
        """
        Формирует строку прокси для aiohttp.
        Если rotate=True, добавляет session-ID к юзернейму (для резистентных прокси).
        """
        if self.host and self.port:
            if self.user and self.password:
                user_str = self.user
                if rotate:
                    # Генерируем случайную сессию для ротации IP
                    session_id = ''.join(random.choices("abcdefghijklmnopqrstuvwxyz0123456789", k=8))
                    user_str = f"{user_str}-session-{session_id}"
                return f"http://{user_str}:{self.password}@{self.host}:{self.port}"
            return f"http://{self.host}:{self.port}"
        return None

    def create_proxy_auth_extension(self) -> Optional[str]:
        """Создает ZIP-расширение для Chrome/Edge для авторизации прокси."""
        if not self.host or not self.port or not self.user:
            return None

        folder_path = "proxy_ext"
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
            
        manifest_json = json.dumps({
            "version": "1.0.0",
            "manifest_version": 2,
            "name": "Edge Proxy",
            "permissions": [
                "proxy", "tabs", "unlimitedStorage", "storage", 
                "<all_urls>", "webRequest", "webRequestBlocking"
            ],
            "background": {"scripts": ["background.js"]}
        })
        
        session_id = ''.join(random.choices("abcdefghijklmnopqrstuvwxyz0123456789", k=10))
        auth_user = f"{self.user}-session-{session_id};country-ru"
        
        background_js = """
        var config = { mode: "fixed_servers", rules: { singleProxy: { scheme: "http", host: "%s", port: parseInt(%s) }, bypassList: ["localhost"] } };
        chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});
        chrome.webRequest.onAuthRequired.addListener(function(details) { return { authCredentials: { username: "%s", password: "%s" } }; }, {urls: ["<all_urls>"]}, ['blocking']);
        """ % (self.host, self.port, auth_user, self.password)
        
        extension_path = os.path.join(folder_path, "proxy_auth_plugin.zip")
        try:
            with zipfile.ZipFile(extension_path, 'w') as zp:
                zp.writestr("manifest.json", manifest_json)
                zp.writestr("background.js", background_js)
            return extension_path
        except Exception as e:
            logger.error(f"Failed to create proxy extension: {e}")
            return None
</file>

<file path="backend/parser_parts/search.py">
import re
import time
import random
import asyncio
import aiohttp
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from .config import logger, GEO_ZONES, get_random_ua
from .proxy import ProxyManager
from .browser import BrowserManager

class SearchParser:
    def __init__(self):
        self.proxy_manager = ProxyManager()
        self.browser_manager = BrowserManager()

    async def get_search_position_v2(self, query: str, target_sku: int, dest: str = GEO_ZONES["moscow"]):
        """Гибридный поиск: API -> Fallback to Selenium"""
        target_sku = int(target_sku)
        url = "https://search.wb.ru/exactmatch/ru/common/v7/search"
        params = {
            "ab_testing": "false", "appType": "1", "curr": "rub", "dest": dest, 
            "query": query, "resultset": "catalog", "sort": "popular", 
            "spp": "30", "suppressSpellcheck": "false"
        }
        
        max_retries = 3
        api_failed = False
        
        for attempt in range(max_retries):
            proxy_url = self.proxy_manager.get_aiohttp_proxy(rotate=True)
            headers = {"User-Agent": get_random_ua(), "Accept": "*/*"}
            
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, params=params, headers=headers, proxy=proxy_url, timeout=12) as resp:
                        if resp.status == 429:
                            logger.warning(f"API 429 (Att {attempt+1}).")
                            await asyncio.sleep(random.uniform(2, 4))
                            continue
                            
                        if resp.status != 200:
                            logger.warning(f"API Bad Status {resp.status}. Switching to fallback.")
                            api_failed = True
                            break
                        
                        data = await resp.json()
                        products = data.get("data", {}).get("products") or data.get("products", [])
                        
                        if not products:
                            logger.warning("API returned empty products list. Switching to Fallback.")
                            api_failed = True
                            break

                        organic_counter = 0
                        
                        for index, item in enumerate(products):
                            item_id = int(item.get("id", 0))
                            is_ad = bool(item.get("log") or item.get("adId") or item.get("cpm"))
                            
                            if not is_ad: organic_counter += 1
                            
                            if item_id == target_sku:
                                return {
                                    "organic_pos": organic_counter if not is_ad else 0,
                                    "ad_pos": (index + 1) if is_ad else 0,
                                    "is_boosted": is_ad,
                                    "total_pos": index + 1
                                }
                        
                        # Если не нашли - значит позиция 0
                        return {"organic_pos": 0, "ad_pos": 0, "is_boosted": False}

            except Exception as e:
                logger.error(f"API Connection Error: {e}")
                await asyncio.sleep(1)
                continue
        
        logger.info("API attempts exhausted or failed. Executing Selenium Fallback.")
        return await self._get_search_position_selenium_fallback(query, target_sku)

    async def _get_search_position_selenium_fallback(self, query: str, target_sku: int):
        logger.info(f"⚡ FALLBACK: Starting Selenium Search for '{query}'...")
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, self._run_selenium_search_sync, query, target_sku)
        except Exception as e:
            logger.error(f"Selenium Fallback Error: {e}")
            return {"organic_pos": 0, "ad_pos": 0, "is_boosted": False}

    def _run_selenium_search_sync(self, query: str, target_sku: int):
        driver = None
        try:
            driver = self.browser_manager.init_driver()
            url = f"https://www.wildberries.ru/catalog/0/search.aspx?search={query}"
            driver.get(url)
            
            try:
                WebDriverWait(driver, 25).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, ".product-card, .product-card__wrapper"))
                )
                time.sleep(3)
            except:
                logger.warning("Selenium: Timeout waiting for cards")
                return {"organic_pos": 0, "ad_pos": 0, "is_boosted": False}

            cards = driver.find_elements(By.CSS_SELECTOR, ".product-card__wrapper, .product-card")
            organic_counter = 0
            
            for i, card in enumerate(cards):
                try:
                    link = card.find_element(By.TAG_NAME, "a")
                    href = link.get_attribute("href")
                    match = re.search(r'catalog/(\d+)/detail', href)
                    if not match: continue
                    
                    sku_found = int(match.group(1))
                    text_content = card.get_attribute("textContent").lower()
                    is_ad = "реклама" in text_content
                    
                    if not is_ad: organic_counter += 1
                        
                    if sku_found == int(target_sku):
                        logger.info(f"✅ Selenium Found SKU {target_sku} at pos {i+1}")
                        return {
                            "organic_pos": organic_counter if not is_ad else 0,
                            "ad_pos": (i + 1) if is_ad else 0,
                            "is_boosted": is_ad,
                            "total_pos": i + 1
                        }
                    
                    if i > 100: break
                except: continue

            return {"organic_pos": 0, "ad_pos": 0, "is_boosted": False}
        except Exception as e:
            logger.error(f"Selenium Sync Error: {e}")
            return {"organic_pos": 0, "ad_pos": 0, "is_boosted": False}
        finally:
            if driver:
                try: driver.quit()
                except: pass
</file>

<file path="backend/parser_service.py">
import asyncio
from parser_parts.config import GEO_ZONES, logger
from parser_parts.product import ProductParser
from parser_parts.search import SearchParser

# Re-export GEO_ZONES for compatibility
__all__ = ["parser_service", "GEO_ZONES"]

class SeleniumWBParser:
    """
    Фасад для микросервиса парсинга Wildberries.
    Делегирует задачи специализированным модулям в parser_parts.
    """
    def __init__(self):
        self.product_parser = ProductParser()
        self.search_parser = SearchParser()

    def get_product_data(self, sku: int):
        """Парсинг цен и остатков (Sync wrapper for Celery)"""
        return self.product_parser.get_product_data(sku)

    def get_full_product_info(self, sku: int, limit: int = 50):
        """Парсинг отзывов и деталей"""
        return self.product_parser.get_full_product_info(sku, limit)

    async def get_seo_data(self, sku: int):
        """Парсинг ключевых слов (Async)"""
        return await self.product_parser.get_seo_data(sku)

    async def get_search_position_v2(self, query: str, target_sku: int, dest: str = GEO_ZONES["moscow"]):
        """Гибридный поиск позиции (Async)"""
        return await self.search_parser.get_search_position_v2(query, target_sku, dest)

    def get_search_position(self, query: str, target_sku: int):
        """Legacy Sync Wrapper для поиска"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            result = loop.run_until_complete(self.get_search_position_v2(query, target_sku))
            loop.close()
            return result["organic_pos"] if result["organic_pos"] > 0 else (result["ad_pos"] if result["ad_pos"] > 0 else 0)
        except Exception as e:
            logger.error(f"Legacy Search Error: {e}")
            return 0

# Singleton Instance
parser_service = SeleniumWBParser()
</file>

<file path="backend/requirements.txt">
fastapi
uvicorn
selenium
webdriver-manager
python-dotenv
celery
redis
sqlalchemy
asyncpg
psycopg2-binary
aiohttp
requests
fpdf2
fastapi-cache2
beautifulsoup4
pydantic
pydantic-settings
greenlet
clickhouse-connect
pandas
prophet
holidays
numpy
scipy
sentence-transformers
scikit-learn
plotly
matplotlib
httpx
aiodns
</file>

<file path="backend/routers/admin.py">
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from database import get_db, User, MonitoredItem
from dependencies import get_current_user

router = APIRouter(prefix="/api/admin", tags=["Admin"])

@router.get("/stats")
async def get_admin_stats(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if not user.is_admin: raise HTTPException(403, "Forbidden")
    users = (await db.execute(select(func.count(User.id)))).scalar()
    items = (await db.execute(select(func.count(MonitoredItem.id)))).scalar()
    return {"total_users": users, "total_items_monitored": items, "server_status": "Online (v2.0)"}
</file>

<file path="backend/routers/ai.py">
import os
import io
import json
import logging
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from fpdf import FPDF

from database import get_db, User, SearchHistory
from dependencies import get_current_user
from tasks import analyze_reviews_task, get_status
# Импортируем парсер напрямую для синхронного чек-запроса (или через task, если нужно асинхронно, но тут быстро)
from parser_parts.product import ProductParser

logger = logging.getLogger("AI-Router")
router = APIRouter(prefix="/api", tags=["AI"])

# Инициализируем парсер один раз (или можно внутри функции)
product_parser = ProductParser()

@router.get("/ai/check/{sku}")
async def check_product_reviews(sku: int, user: User = Depends(get_current_user)):
    """
    Быстрый чек товара: возвращает название, фото и доступное кол-во отзывов.
    Нужен для настройки ползунка на фронте перед запуском анализа.
    """
    try:
        # Используем быстрый метод получения стат данных
        info = await product_parser.get_review_stats(sku)
        if info.get("status") == "error":
            raise HTTPException(404, info.get("message"))
        return info
    except Exception as e:
        logger.error(f"Check error: {e}")
        raise HTTPException(500, f"Ошибка проверки товара: {str(e)}")

@router.post("/ai/analyze/{sku}")
async def start_ai_analysis(
    sku: int, 
    limit: int = Query(100, ge=10, description="Max reviews to parse"),
    user: User = Depends(get_current_user)
):
    # limit теперь приходит точный, выбранный пользователем на основе реального кол-ва
    task = analyze_reviews_task.delay(sku, limit, user.id)
    return {"status": "accepted", "task_id": task.id}

@router.get("/ai/result/{task_id}")
def get_ai_result(task_id: str):
    return get_status(task_id)

@router.get("/report/ai-pdf/{sku}")
async def generate_ai_pdf(sku: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if user.subscription_plan == "free":
        raise HTTPException(403, "Upgrade to PRO")

    stmt = select(SearchHistory).where(
        SearchHistory.user_id == user.id, 
        SearchHistory.sku == sku, 
        SearchHistory.request_type == 'ai'
    ).order_by(SearchHistory.created_at.desc()).limit(1)
    
    history_item = (await db.execute(stmt)).scalars().first()
    
    if not history_item or not history_item.result_json:
        raise HTTPException(404, "Анализ не найден. Сначала запустите AI анализ.")

    try:
        data = json.loads(history_item.result_json)
    except:
        raise HTTPException(500, "Ошибка данных анализа")

    ai_data = data.get('ai_analysis', {})
    if not ai_data:
        raise HTTPException(500, "Некорректная структура данных")

    pdf = FPDF()
    pdf.add_page()

    # Шрифт (заглушка для примера, в проде нужны реальные пути)
    font_path = '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf'
    font_bold_path = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'
    font_family = 'Arial' 
    
    try:
        if os.path.exists(font_path):
            pdf.add_font('DejaVu', '', font_path, uni=True)
            if os.path.exists(font_bold_path):
                pdf.add_font('DejaVu', 'B', font_bold_path, uni=True)
            font_family = 'DejaVu'
        else:
             local_font = "fonts/DejaVuSans.ttf"
             if os.path.exists(local_font):
                 pdf.add_font('DejaVu', '', local_font, uni=True)
                 font_family = 'DejaVu'
    except Exception as e:
        logger.error(f"Font error: {e}")

    pdf.set_font(font_family, '', 14)
    pdf.set_font_size(20)
    pdf.cell(0, 10, txt=f"AI Report: {sku}", ln=1, align='C')
    pdf.set_font_size(12)
    
    product_name = data.get('product_name', 'Product')[:50]
    pdf.cell(0, 10, txt=f"Product: {product_name}...", ln=1, align='C')
    pdf.ln(5)

    if ai_data.get('global_summary'):
        pdf.set_font(font_family, '', 12)
        pdf.cell(0, 10, txt="Резюме:", ln=1)
        pdf.set_font(font_family, '', 10)
        epw = pdf.w - 2 * pdf.l_margin
        pdf.multi_cell(epw, 8, txt=str(ai_data['global_summary']))
        pdf.ln(5)

    if ai_data.get('audience_stats'):
        stats = ai_data['audience_stats']
        pdf.set_font(font_family, '', 12)
        pdf.cell(0, 10, txt="Аудитория:", ln=1)
        pdf.set_font(font_family, '', 10)
        pdf.cell(0, 8, txt=f"- Рационалы: {stats.get('rational_percent')}%", ln=1)
        pdf.cell(0, 8, txt=f"- Эмоционалы: {stats.get('emotional_percent')}%", ln=1)
        pdf.cell(0, 8, txt=f"- Скептики: {stats.get('skeptic_percent')}%", ln=1)
        pdf.ln(5)
        
        if ai_data.get('infographic_recommendation'):
            epw = pdf.w - 2 * pdf.l_margin
            pdf.multi_cell(epw, 8, txt=f"Совет для инфографики: {ai_data['infographic_recommendation']}")
            pdf.ln(5)

    if ai_data.get('aspects'):
        pdf.set_font(font_family, '', 12)
        pdf.cell(0, 10, txt="Ключевые аспекты:", ln=1)
        pdf.set_font(font_family, '', 10)
        epw = pdf.w - 2 * pdf.l_margin
        for asp in ai_data['aspects'][:10]: 
            score = asp.get('sentiment_score', 0)
            pdf.cell(0, 8, txt=f"{asp.get('aspect')} ({score}/9.0)", ln=1)
            pdf.set_font_size(8)
            snippet = str(asp.get('snippet', ''))
            pdf.multi_cell(epw, 5, txt=f"Цитата: {snippet}")
            pdf.ln(2)
            pdf.set_font_size(10)
    
    if ai_data.get('strategy'):
        pdf.ln(5)
        pdf.set_font(font_family, '', 12)
        pdf.cell(0, 10, txt="Стратегия роста:", ln=1)
        pdf.set_font(font_family, '', 10)
        epw = pdf.w - 2 * pdf.l_margin
        for s in ai_data['strategy']:
            text_line = f"- {str(s)}"
            pdf.set_x(pdf.l_margin)
            try:
                pdf.multi_cell(epw, 8, txt=text_line)
            except Exception as e:
                logger.error(f"PDF Render error: {e}")
                pdf.cell(0, 8, txt="- (Ошибка отображения текста)", ln=1)

    pdf_content = pdf.output(dest='S')
    if isinstance(pdf_content, str):
        pdf_bytes = pdf_content.encode('latin-1') 
    else:
        pdf_bytes = pdf_content

    return StreamingResponse(
        io.BytesIO(pdf_bytes), 
        media_type='application/pdf', 
        headers={'Content-Disposition': f'attachment; filename="ai_analysis_{sku}.pdf"'}
    )
</file>

<file path="backend/routers/bidder.py">
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc
from datetime import datetime, timedelta
from pydantic import BaseModel

from database import get_db, User, BidderLog, BidderSettings
from dependencies import get_current_user
from wb_api_service import wb_api_service

router = APIRouter(prefix="/api/bidder", tags=["Bidder"])

class CampaignSettingsUpdate(BaseModel):
    campaign_id: int
    is_active: bool
    target_pos: int
    max_bid: int
    min_bid: int
    target_cpa: int
    strategy: str = "pid"

@router.get("/campaigns")
async def get_my_campaigns(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if not user.wb_api_token:
        raise HTTPException(400, "WB API token not connected")
    try:
        # 1. Fetch live campaigns from WB
        campaigns = await wb_api_service.get_advert_campaigns(user.wb_api_token)
        
        # 2. Fetch our local settings
        camp_ids = [c['id'] for c in campaigns]
        settings_res = await db.execute(select(BidderSettings).where(BidderSettings.campaign_id.in_(camp_ids)))
        settings_map = {s.campaign_id: s for s in settings_res.scalars().all()}
        
        # 3. Merge data
        result = []
        for c in campaigns:
            s = settings_map.get(c['id'])
            c['bidder_enabled'] = s.is_active if s else False
            c['target_pos'] = s.target_pos if s else 1
            c['strategy'] = s.strategy if s else 'pid'
            result.append(c)
            
        return result
    except Exception as e:
        # Return empty list on error to prevent UI crash
        return []

@router.get("/settings/{campaign_id}")
async def get_campaign_settings(campaign_id: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    stmt = select(BidderSettings).where(BidderSettings.campaign_id == campaign_id, BidderSettings.user_id == user.id)
    settings = (await db.execute(stmt)).scalars().first()
    
    if not settings:
        return {
            "campaign_id": campaign_id, "is_active": False,
            "target_pos": 1, "max_bid": 500, "min_bid": 125,
            "target_cpa": 0, "strategy": "pid"
        }
    return settings

@router.post("/settings")
async def save_campaign_settings(req: CampaignSettingsUpdate, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    stmt = select(BidderSettings).where(BidderSettings.campaign_id == req.campaign_id, BidderSettings.user_id == user.id)
    settings = (await db.execute(stmt)).scalars().first()
    
    if settings:
        settings.is_active = req.is_active
        settings.target_pos = req.target_pos
        settings.max_bid = req.max_bid
        settings.min_bid = req.min_bid
        settings.target_cpa = req.target_cpa
        settings.strategy = req.strategy
        settings.updated_at = datetime.utcnow()
    else:
        settings = BidderSettings(
            user_id=user.id,
            campaign_id=req.campaign_id,
            is_active=req.is_active,
            target_pos=req.target_pos,
            max_bid=req.max_bid,
            min_bid=req.min_bid,
            target_cpa=req.target_cpa,
            strategy=req.strategy
        )
        db.add(settings)
    
    await db.commit()
    return {"status": "saved", "is_active": req.is_active}

@router.get("/stats/{campaign_id}")
async def get_campaign_stats(campaign_id: int, user: User = Depends(get_current_user)):
    if not user.wb_api_token: raise HTTPException(400, "No Token")
    try:
        stats = await wb_api_service.get_advert_stats(user.wb_api_token, campaign_id)
        info = await wb_api_service.get_current_bid_info(user.wb_api_token, campaign_id)
        return {"stats": stats, "current": info}
    except:
        raise HTTPException(503, "WB Advert API Unavailable")

@router.get("/logs")
async def get_bidder_logs(campaign_id: int = None, limit: int = 20, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    stmt = select(BidderLog).where(BidderLog.user_id == user.id)
    if campaign_id: stmt = stmt.where(BidderLog.campaign_id == campaign_id)
    stmt = stmt.order_by(desc(BidderLog.timestamp)).limit(limit)
    logs = (await db.execute(stmt)).scalars().all()
    
    return [{
        "time": l.timestamp.strftime("%H:%M"),
        "full_date": l.timestamp.isoformat(),
        "campaign_id": l.campaign_id,
        "action": l.action,
        "bid": l.calculated_bid,
        "pos": l.current_pos,
        "saved": l.saved_amount,
        "msg": f"Pos {l.current_pos} -> {l.target_pos} | Bid {l.calculated_bid} ({l.action})"
    } for l in logs]

@router.get("/dashboard")
async def get_bidder_dashboard(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    yesterday = datetime.utcnow() - timedelta(days=1)
    stmt = select(BidderLog).where(BidderLog.user_id == user.id, BidderLog.timestamp >= yesterday)
    logs = (await db.execute(stmt)).scalars().all()
    total_saved = sum([l.saved_amount for l in logs if l.saved_amount > 0])
    
    active_stmt = select(BidderSettings).where(BidderSettings.user_id == user.id, BidderSettings.is_active == True)
    active_count = len((await db.execute(active_stmt)).scalars().all())

    return {
        "total_budget_saved": total_saved,
        "campaigns_active": active_count,
        "logs_count_24h": len(logs)
    }
</file>

<file path="backend/routers/finance.py">
import json
from datetime import datetime
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from database import get_db, User, ProductCost
from dependencies import get_current_user, get_redis_client
from wb_api_service import wb_api_service
from analysis_service import analysis_service

router = APIRouter(prefix="/api", tags=["Finance"])

class CostUpdateRequest(BaseModel):
    cost_price: int
    logistics: Optional[int] = 50
    commission_percent: Optional[float] = 25.0

class TransitCalcRequest(BaseModel):
    volume: int 
    destination: str = "Koledino"

@router.get("/internal/stats")
async def get_internal_stats(user: User = Depends(get_current_user)):
    if not user.wb_api_token:
        return {"orders_today": {"sum": 0, "count": 0}, "stocks": {"total_quantity": 0}}
    try:
        return await wb_api_service.get_dashboard_stats(user.wb_api_token)
    except:
        return {"orders_today": {"sum": 0, "count": 0}, "stocks": {"total_quantity": 0}}

@router.get("/internal/stories")
async def get_stories(user: User = Depends(get_current_user)):
    stories = []
    
    orders_sum = 0
    stocks_qty = 0
    
    if user.wb_api_token:
        try:
            stats = await wb_api_service.get_dashboard_stats(user.wb_api_token)
            orders_sum = stats.get('orders_today', {}).get('sum', 0)
            stocks_qty = stats.get('stocks', {}).get('total_quantity', 0)
            
            stories.append({
                "id": 1, 
                "title": "Продажи", 
                "val": f"{orders_sum // 1000}k ₽" if orders_sum > 1000 else f"{orders_sum} ₽",
                "subtitle": "Сегодня",
                "color": "bg-emerald-500"
            })
        except:
             stories.append({
                "id": 1, "title": "API Error", "val": "Fail", "color": "bg-red-500", "subtitle": "Connection"
            })
    else:
        stories.append({
            "id": 1, "title": "API", "val": "Подключи", "color": "bg-slate-400", "subtitle": "Нет данных"
        })

    if user.subscription_plan == "free":
        stories.append({
            "id": 2, "title": "Биддер", "val": "OFF", "color": "bg-purple-500", "subtitle": "Upgrade"
        })
    else:
        stories.append({
            "id": 2, "title": "Биддер", "val": "Active", "color": "bg-purple-500", "subtitle": "Safe Mode"
        })

    if user.wb_api_token:
        stories.append({
            "id": 3, "title": "Склад", "val": f"{stocks_qty}", "color": "bg-blue-500", "subtitle": "Всего шт."
        })

    return stories

@router.get("/internal/products")
async def get_my_products_finance(
    user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)
):
    if not user.wb_api_token: 
        return []
    
    try:
        stocks = await wb_api_service.get_my_stocks(user.wb_api_token)
        if not stocks: 
            return []
    except Exception:
        return []
    
    sku_map = {}
    for s in stocks:
        sku = s.get('nmId')
        if sku not in sku_map:
            sku_map[sku] = {
                "sku": sku, 
                "quantity": 0, 
                "price": s.get('Price', 0), 
                "discount": s.get('Discount', 0)
            }
        sku_map[sku]['quantity'] += s.get('quantity', 0)
    
    skus = list(sku_map.keys())
    
    # Загружаем настройки расходов из БД
    costs_res = await db.execute(select(ProductCost).where(ProductCost.user_id == user.id, ProductCost.sku.in_(skus)))
    costs_map = {c.sku: c for c in costs_res.scalars().all()}
    
    result = []
    r_client = get_redis_client()

    for sku, data in sku_map.items():
        cost_obj = costs_map.get(sku)
        
        # Используем настройки пользователя или дефолтные значения
        cost_price = cost_obj.cost_price if cost_obj else 0
        logistics_val = cost_obj.logistics if cost_obj else 50
        commission_pct = cost_obj.commission_percent if cost_obj else 25.0
        
        selling_price = data['price'] * (1 - data['discount']/100)
        
        commission = selling_price * (commission_pct / 100.0)
        
        profit = selling_price - commission - logistics_val - cost_price
        roi = round((profit / cost_price * 100), 1) if cost_price > 0 else 0
        margin = int(profit / selling_price * 100) if selling_price > 0 else 0
        
        supply_data = None
        if r_client:
            cached_forecast = r_client.get(f"forecast:{user.id}:{sku}")
            if cached_forecast:
                try:
                    forecast_json = json.loads(cached_forecast)
                    supply_data = analysis_service.calculate_supply_metrics(
                        current_stock=data['quantity'],
                        sales_history=[],
                        forecast_data=forecast_json
                    )
                except: pass
        
        if not supply_data:
            supply_data = {
                "status": "unknown",
                "recommendation": "Мало данных",
                "metrics": {
                    "safety_stock": 0, "rop": 0, "days_left": 0, 
                    "avg_daily_demand": 0, "current_stock": data['quantity']
                }
            }

        result.append({
            "sku": sku,
            "quantity": data['quantity'],
            "price": int(selling_price),
            "cost_price": cost_price,
            "logistics": logistics_val,
            "commission_percent": commission_pct,
            "unit_economy": {
                "profit": int(profit),
                "roi": roi,
                "margin": margin
            },
            "supply": supply_data
        })
        
    return result

@router.post("/internal/cost/{sku}")
async def set_product_cost(
    sku: int, 
    req: CostUpdateRequest, 
    user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)
):
    stmt = select(ProductCost).where(ProductCost.user_id == user.id, ProductCost.sku == sku)
    cost_obj = (await db.execute(stmt)).scalars().first()
    
    if cost_obj:
        cost_obj.cost_price = req.cost_price
        cost_obj.logistics = req.logistics
        cost_obj.commission_percent = req.commission_percent
        cost_obj.updated_at = datetime.utcnow()
    else:
        cost_obj = ProductCost(
            user_id=user.id, 
            sku=sku, 
            cost_price=req.cost_price,
            logistics=req.logistics,
            commission_percent=req.commission_percent
        )
        db.add(cost_obj)
    
    await db.commit()
    return {"status": "saved", "data": req.dict()}

@router.get("/internal/coefficients")
async def get_supply_coefficients(user: User = Depends(get_current_user)):
    if not user.wb_api_token:
        return []
    try:
        data = await wb_api_service.get_warehouse_coeffs(user.wb_api_token)
        return data if data else []
    except:
        return []

@router.post("/internal/transit_calc")
async def calculate_transit(req: TransitCalcRequest, user: User = Depends(get_current_user)):
    return await wb_api_service.calculate_transit(req.volume, req.destination)
</file>

<file path="backend/routers/monitoring.py">
import os
import io
import logging
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, delete
from fpdf import FPDF

from database import get_db, User, MonitoredItem, PriceHistory
from dependencies import get_current_user
from tasks import parse_and_save_sku, get_status

logger = logging.getLogger("Monitoring")
router = APIRouter(prefix="/api", tags=["Monitoring"])

@router.post("/monitor/add/{sku}")
async def add_to_monitor(sku: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    limits = {"free": 3, "pro": 50, "business": 500}
    limit = limits.get(user.subscription_plan, 3)
    
    count_stmt = select(func.count()).select_from(MonitoredItem).where(MonitoredItem.user_id == user.id)
    current = (await db.execute(count_stmt)).scalar() or 0
    
    if current >= limit:
        raise HTTPException(403, f"Лимит тарифа исчерпан ({limit} шт)")

    stmt = select(MonitoredItem).where(MonitoredItem.user_id == user.id, MonitoredItem.sku == sku)
    if (await db.execute(stmt)).scalars().first(): 
        return {"status": "exists", "message": "Товар уже в списке"}

    new_item = MonitoredItem(user_id=user.id, sku=sku, name="Загрузка...", brand="...")
    db.add(new_item)
    await db.commit()
    
    task = parse_and_save_sku.delay(sku, user.id)
    return {"status": "accepted", "task_id": task.id}

@router.get("/monitor/list")
async def get_my_items(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    stmt = select(MonitoredItem).where(MonitoredItem.user_id == user.id).order_by(MonitoredItem.id.desc())
    items = (await db.execute(stmt)).scalars().all()
    
    data = []
    for i in items:
        last_price_stmt = select(PriceHistory).where(PriceHistory.item_id == i.id).order_by(PriceHistory.recorded_at.desc()).limit(1)
        lp = (await db.execute(last_price_stmt)).scalars().first()
        
        data.append({
            "id": i.id, "sku": i.sku, "name": i.name, "brand": i.brand,
            "prices": [{"wallet_price": lp.wallet_price, "standard_price": lp.standard_price}] if lp else []
        })
    return data

@router.delete("/monitor/delete/{sku}")
async def delete_item(sku: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    stmt = delete(MonitoredItem).where(MonitoredItem.user_id == user.id, MonitoredItem.sku == sku)
    await db.execute(stmt)
    await db.commit()
    return {"status": "deleted"}

@router.get("/monitor/history/{sku}")
async def get_history(sku: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    item = (await db.execute(select(MonitoredItem).where(MonitoredItem.user_id == user.id, MonitoredItem.sku == sku))).scalars().first()
    if not item: raise HTTPException(404, "Item not found in your list")
    
    history = (await db.execute(select(PriceHistory).where(PriceHistory.item_id == item.id).order_by(PriceHistory.recorded_at.asc()))).scalars().all()
    
    return {
        "sku": sku, 
        "name": item.name, 
        "history": [{"date": h.recorded_at.strftime("%d.%m %H:%M"), "wallet": h.wallet_price, "standard": h.standard_price, "base": h.base_price} for h in history]
    }

@router.get("/monitor/status/{task_id}")
def get_status_endpoint(task_id: str): 
    """
    Получение статуса задачи.
    Синхронный обработчик (def) для корректной работы с синхронным Celery backend.
    """
    return get_status(task_id)

@router.get("/report/pdf/{sku}")
async def generate_pdf(sku: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if user.subscription_plan == "free":
        raise HTTPException(403, "Upgrade to PRO")

    item = (await db.execute(select(MonitoredItem).where(MonitoredItem.user_id == user.id, MonitoredItem.sku == sku))).scalars().first()
    if not item: raise HTTPException(404, "Item not found")

    history = (await db.execute(select(PriceHistory).where(PriceHistory.item_id == item.id).order_by(PriceHistory.recorded_at.desc()).limit(100))).scalars().all()

    pdf = FPDF()
    pdf.add_page()
    
    font_path = '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf'
    try:
        if os.path.exists(font_path):
            pdf.add_font('DejaVu', '', font_path, uni=True)
            pdf.set_font('DejaVu', '', 14)
        else:
             local_font = "fonts/DejaVuSans.ttf"
             if os.path.exists(local_font):
                 pdf.add_font('DejaVu', '', local_font, uni=True)
                 pdf.set_font('DejaVu', '', 14)
             else:
                 pdf.set_font("Arial", size=12)
    except Exception as e:
        logger.error(f"Font loading error: {e}")
        pdf.set_font("Arial", size=12)

    pdf.cell(0, 10, txt=f"Report: {sku}", ln=1, align='C')
    pdf.ln(5)
    
    pdf.set_font_size(10)
    pdf.cell(60, 10, "Date", 1)
    pdf.cell(40, 10, "Wallet", 1)
    pdf.cell(40, 10, "Regular", 1)
    pdf.ln()

    for h in history:
        pdf.cell(60, 10, h.recorded_at.strftime("%Y-%m-%d %H:%M"), 1)
        pdf.cell(40, 10, f"{h.wallet_price}", 1)
        pdf.cell(40, 10, f"{h.standard_price}", 1)
        pdf.ln()

    pdf_content = pdf.output(dest='S')
    if isinstance(pdf_content, str):
        pdf_bytes = pdf_content.encode('latin-1') 
    else:
        pdf_bytes = pdf_content

    return StreamingResponse(
        io.BytesIO(pdf_bytes), 
        media_type='application/pdf', 
        headers={'Content-Disposition': f'attachment; filename="wb_report_{sku}.pdf"'}
    )
</file>

<file path="backend/routers/payments.py">
import os
import json
import logging
import uuid
import base64
import httpx
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from database import get_db, User, Payment
from dependencies import get_current_user
from bot_service import bot_service

logger = logging.getLogger("Payments")
router = APIRouter(prefix="/api", tags=["Payments"])

YOOKASSA_SHOP_ID = os.getenv("YOOKASSA_SHOP_ID")
YOOKASSA_SECRET_KEY = os.getenv("YOOKASSA_SECRET_KEY")

class StarsPaymentRequest(BaseModel):
    plan_id: str
    amount: int

class YooPaymentRequest(BaseModel):
    plan_id: str

@router.post("/payment/stars_link")
async def create_stars_link(req: StarsPaymentRequest, user: User = Depends(get_current_user)):
    title = f"Подписка {req.plan_id.upper()}"
    desc = f"Активация тарифа {req.plan_id} на 1 месяц"
    payload = json.dumps({"user_id": user.id, "plan": req.plan_id})
    
    link = await bot_service.create_invoice_link(title, desc, payload, req.amount)
    if not link:
        raise HTTPException(500, "Ошибка создания ссылки")
        
    return {"invoice_link": link}

@router.post("/webhook/telegram")
async def telegram_webhook(request: Request, db: AsyncSession = Depends(get_db)):
    data = await request.json()
    
    if "message" in data and "successful_payment" in data["message"]:
        pay = data["message"]["successful_payment"]
        payload = json.loads(pay["invoice_payload"])
        
        user_id = payload.get("user_id")
        plan = payload.get("plan")
        
        if user_id and plan:
            user = await db.get(User, user_id)
            if user:
                user.subscription_plan = plan
                user.subscription_expires_at = datetime.utcnow() + timedelta(days=30)
                db.add(user)
                await db.commit()
                logger.info(f"User {user.telegram_id} upgraded to {plan} via Stars")
                
    return {"ok": True}

@router.post("/payment/yookassa/create")
async def create_yookassa_payment(req: YooPaymentRequest, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if not YOOKASSA_SHOP_ID or not YOOKASSA_SECRET_KEY:
        raise HTTPException(500, "YooKassa config missing")

    prices = {"pro": 2990, "business": 6990}
    amount_val = prices.get(req.plan_id)
    if not amount_val:
        raise HTTPException(400, "Invalid plan")

    idempotence_key = str(uuid.uuid4())
    auth_str = f"{YOOKASSA_SHOP_ID}:{YOOKASSA_SECRET_KEY}"
    b64_auth = base64.b64encode(auth_str.encode()).decode()

    headers = {
        "Idempotence-Key": idempotence_key,
        "Authorization": f"Basic {b64_auth}",
        "Content-Type": "application/json"
    }

    return_url = "https://t.me/WbAnalyticsBot/app" 

    payload = {
        "amount": {"value": f"{amount_val}.00", "currency": "RUB"},
        "capture": True,
        "confirmation": {"type": "redirect", "return_url": return_url},
        "description": f"Подписка {req.plan_id.upper()} (30 дней)",
        "metadata": {"user_id": user.id, "telegram_id": user.telegram_id, "plan_id": req.plan_id},
        "receipt": {
            "customer": {"email": "user@example.com"},
            "items": [{"description": f"Тариф {req.plan_id}", "quantity": "1.00", "amount": {"value": f"{amount_val}.00", "currency": "RUB"}, "vat_code": "1"}]
        }
    }

    async with httpx.AsyncClient() as client:
        try:
            resp = await client.post("https://api.yookassa.ru/v3/payments", json=payload, headers=headers)
            resp.raise_for_status()
            data = resp.json()
            
            new_payment = Payment(
                user_id=user.id,
                amount=amount_val,
                currency="RUB",
                provider_payment_id=data['id'],
                status=data['status'],
                plan_id=req.plan_id
            )
            db.add(new_payment)
            await db.commit()
            
            return {"payment_url": data['confirmation']['confirmation_url'], "payment_id": data['id']}
        except Exception as e:
            logger.error(f"YooKassa Connection Error: {e}")
            raise HTTPException(500, "Internal payment error")

@router.post("/payment/yookassa/webhook")
async def yookassa_webhook(request: Request, db: AsyncSession = Depends(get_db)):
    try:
        data = await request.json()
    except:
        raise HTTPException(400, "Invalid JSON")

    event = data.get("event")
    obj = data.get("object", {})

    if event == "payment.succeeded" and obj.get("status") == "succeeded":
        payment_id = obj.get("id")
        metadata = obj.get("metadata", {})
        user_id = metadata.get("user_id")
        plan_id = metadata.get("plan_id")

        if not user_id or not plan_id:
            return {"status": "ignored"}

        stmt = select(Payment).where(Payment.provider_payment_id == payment_id)
        payment_record = (await db.execute(stmt)).scalars().first()
        
        if payment_record:
            payment_record.status = "succeeded"
            payment_record.confirmed_at = datetime.utcnow()
            db.add(payment_record)
        else:
            payment_record = Payment(
                user_id=int(user_id),
                provider_payment_id=payment_id,
                amount=int(float(obj['amount']['value'])),
                currency="RUB",
                status="succeeded",
                plan_id=plan_id,
                confirmed_at=datetime.utcnow()
            )
            db.add(payment_record)

        user = await db.get(User, int(user_id))
        if user:
            user.subscription_plan = plan_id
            now = datetime.utcnow()
            if user.subscription_expires_at and user.subscription_expires_at > now:
                user.subscription_expires_at += timedelta(days=30)
            else:
                user.subscription_expires_at = now + timedelta(days=30)
            user.is_recurring = False 
            db.add(user)
            await db.commit()
            logger.info(f"User {user.telegram_id} subscription extended (YooKassa).")
        
    return {"status": "ok"}
</file>

<file path="backend/routers/seo.py">
import os
import io
import logging
from datetime import datetime
from typing import List, Optional, Dict
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from pydantic import BaseModel
from fpdf import FPDF

from database import get_db, User, SeoPosition
from dependencies import get_current_user
from tasks import generate_seo_task, check_seo_position_task, cluster_keywords_task
from parser_service import parser_service

logger = logging.getLogger("SEO-Router")
router = APIRouter(prefix="/api", tags=["SEO"])

class SeoTrackRequest(BaseModel):
    sku: int
    keyword: str

class SeoGenRequest(BaseModel):
    sku: int
    keywords: List[str]
    tone: str
    title_len: Optional[int] = 100
    desc_len: Optional[int] = 1000

class ClusterRequest(BaseModel):
    sku: int
    keywords: List[str]

class SeoPdfRequest(BaseModel):
    sku: str
    title: str
    description: str
    features: Optional[Dict[str, str]] = {}
    faq: Optional[List[Dict[str, str]]] = []

@router.post("/seo/track")
async def track_position(req: SeoTrackRequest, user: User = Depends(get_current_user)):
    task = check_seo_position_task.delay(req.sku, req.keyword, user.id)
    return {"status": "accepted", "task_id": task.id}

@router.get("/seo/positions")
async def get_seo_positions(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    res = await db.execute(select(SeoPosition).where(SeoPosition.user_id == user.id).order_by(SeoPosition.last_check.desc()))
    return res.scalars().all()

@router.delete("/seo/positions/{id}")
async def delete_seo_position(id: int, user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    await db.execute(delete(SeoPosition).where(SeoPosition.id == id, SeoPosition.user_id == user.id))
    await db.commit()
    return {"status": "deleted"}

@router.get("/seo/parse/{sku}")
async def parse_seo_keywords(sku: int, user: User = Depends(get_current_user)):
    res = await parser_service.get_seo_data(sku) 
    if res.get("status") == "error":
        raise HTTPException(400, res.get("message"))
    return res

@router.post("/seo/generate")
async def generate_seo_content(req: SeoGenRequest, user: User = Depends(get_current_user)):
    task = generate_seo_task.delay(req.keywords, req.tone, req.sku, user.id, req.title_len, req.desc_len)
    return {"status": "accepted", "task_id": task.id}

@router.post("/seo/cluster")
async def cluster_keywords_endpoint(req: ClusterRequest, user: User = Depends(get_current_user)):
    task = cluster_keywords_task.delay(req.keywords, user.id, req.sku)
    return {"status": "accepted", "task_id": task.id}

@router.post("/report/seo-pdf/generate")
async def generate_seo_pdf_report(req: SeoPdfRequest, user: User = Depends(get_current_user)):
    font_paths = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "./DejaVuSans.ttf" 
    ]
    font_path = None
    for path in font_paths:
        if os.path.exists(path):
            font_path = path
            break
            
    pdf = FPDF()
    pdf.add_page()
    
    font_family = 'Arial' 
    if font_path:
        try:
            pdf.add_font('DejaVu', '', font_path, uni=True)
            pdf.add_font('DejaVu', 'B', font_path, uni=True) 
            font_family = 'DejaVu'
        except Exception as e:
            logger.error(f"Font loading error: {e}")
    
    pdf.set_font(font_family, 'B', 16)
    pdf.cell(0, 10, f"GEO SEO Report: SKU {req.sku}", ln=1, align='C')
    pdf.ln(5)
    
    pdf.set_font(font_family, 'B', 12)
    pdf.set_text_color(100, 100, 100)
    pdf.cell(0, 10, "OPTIMIZED TITLE", ln=1)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font(font_family, '', 11)
    pdf.multi_cell(0, 6, req.title)
    pdf.ln(5)
    
    pdf.set_font(font_family, 'B', 12)
    pdf.set_text_color(100, 100, 100)
    pdf.cell(0, 10, "DESCRIPTION", ln=1)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font(font_family, '', 10)
    pdf.multi_cell(0, 5, req.description)
    pdf.ln(10)
    
    if req.features:
        pdf.set_font(font_family, 'B', 12)
        pdf.set_text_color(100, 100, 100)
        pdf.cell(0, 10, "SPECIFICATIONS (Features)", ln=1)
        pdf.set_text_color(0, 0, 0)
        pdf.set_font(font_family, '', 9)
        for k, v in req.features.items():
            pdf.set_fill_color(245, 245, 245)
            pdf.cell(60, 8, str(k), border=1, fill=True)
            pdf.cell(0, 8, str(v), border=1)
            pdf.ln()
        pdf.ln(10)

    if req.faq:
        pdf.set_font(font_family, 'B', 12)
        pdf.set_text_color(100, 100, 100)
        pdf.cell(0, 10, "FAQ (User Intent)", ln=1)
        pdf.set_text_color(0, 0, 0)
        for item in req.faq:
            pdf.set_font(font_family, 'B', 10)
            pdf.multi_cell(0, 5, f"Q: {item.get('question', '')}")
            pdf.set_x(pdf.l_margin)
            pdf.set_font(font_family, '', 10)
            pdf.multi_cell(0, 5, f"A: {item.get('answer', '')}")
            pdf.ln(3)

    pdf.set_y(-30)
    pdf.set_font(font_family, '', 8)
    pdf.set_text_color(128)
    pdf.cell(0, 10, f"Generated by WB Analytics AI • {datetime.now().strftime('%Y-%m-%d %H:%M')}", align='C')

    pdf_content = pdf.output(dest='S')
    if isinstance(pdf_content, str): 
        pdf_bytes = pdf_content.encode('latin-1') 
    else: 
        pdf_bytes = pdf_content

    return StreamingResponse(
        io.BytesIO(pdf_bytes), 
        media_type='application/pdf', 
        headers={'Content-Disposition': f'attachment; filename="seo_report_{req.sku}.pdf"'}
    )
</file>

<file path="backend/routers/users.py">
import json
from datetime import datetime, timedelta
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, delete
from pydantic import BaseModel

from database import get_db, User, MonitoredItem, SearchHistory
from dependencies import get_current_user
from wb_api_service import wb_api_service
from tasks import sync_financial_reports

router = APIRouter(prefix="/api/user", tags=["User"])

class TokenRequest(BaseModel):
    token: str

@router.get("/me")
async def get_profile(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    count_stmt = select(func.count()).select_from(MonitoredItem).where(MonitoredItem.user_id == user.id)
    count = (await db.execute(count_stmt)).scalar() or 0
    
    masked_token = None
    if user.wb_api_token:
        masked_token = user.wb_api_token[:5] + "*" * 10 + user.wb_api_token[-5:]
    
    days_left = 0
    if user.subscription_expires_at:
        delta = user.subscription_expires_at - datetime.utcnow()
        days_left = max(0, delta.days)

    return {
        "id": user.telegram_id,
        "username": user.username,
        "name": user.first_name,
        "plan": user.subscription_plan,
        "is_admin": user.is_admin,
        "items_count": count,
        "has_wb_token": bool(user.wb_api_token),
        "wb_token_preview": masked_token,
        "days_left": days_left,
        "subscription_expires_at": user.subscription_expires_at
    }

@router.post("/token")
async def save_wb_token(
    req: TokenRequest, 
    user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)
):
    """Сохранение токена API WB"""
    # Проверяем токен (хотя бы один сервис должен ответить)
    is_valid = await wb_api_service.check_token(req.token)
    if not is_valid:
        raise HTTPException(status_code=400, detail="Неверный токен или ошибка API WB")

    user.wb_api_token = req.token
    db.add(user)
    await db.commit()
    # Trigger initial sync
    sync_financial_reports.delay(user.id)
    return {"status": "saved", "message": "Токен успешно сохранен, запущена синхронизация"}

@router.get("/token/scopes")
async def get_token_scopes(user: User = Depends(get_current_user)):
    """Диагностика прав токена"""
    if not user.wb_api_token:
        return {"statistics": False, "standard": False, "promotion": False, "questions": False}
    
    return await wb_api_service.get_token_scopes(user.wb_api_token)

@router.delete("/token")
async def delete_wb_token(
    user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)
):
    user.wb_api_token = None
    db.add(user)
    await db.commit()
    return {"status": "deleted"}

@router.get("/history")
async def get_user_history(
    request_type: Optional[str] = Query(None), 
    user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)
):
    stmt = select(SearchHistory).where(SearchHistory.user_id == user.id)
    
    if request_type:
        stmt = stmt.where(SearchHistory.request_type == request_type)
    
    stmt = stmt.order_by(SearchHistory.created_at.desc()).limit(50)
    
    res = await db.execute(stmt)
    history = res.scalars().all()
    result = []
    for h in history:
        try: data = json.loads(h.result_json) if h.result_json else {}
        except: data = {}
        result.append({"id": h.id, "sku": h.sku, "type": h.request_type, "title": h.title, "created_at": h.created_at, "data": data})
    return result

@router.delete("/history")
async def clear_user_history(user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    await db.execute(delete(SearchHistory).where(SearchHistory.user_id == user.id))
    await db.commit()
    return {"status": "cleared"}

@router.get("/tariffs")
async def get_tariffs(user: User = Depends(get_current_user)):
    return [
        {"id": "free", "name": "Start", "price": "0 ₽", "stars": 0, "features": ["3 товара", "История 24ч", "SEO (Авто)", "Ding! (1 раз/день)"], "current": user.subscription_plan == "free", "color": "slate"},
        {"id": "pro", "name": "Pro", "price": "2990 ₽", "stars": 2500, "features": ["50 товаров", "SEO (Настройка длины)", "Unit-экономика", "Ding! (Безлимит)", "PDF"], "current": user.subscription_plan == "pro", "color": "indigo", "is_best": True},
        {"id": "business", "name": "Business", "price": "6990 ₽", "stars": 6000, "features": ["Автобиддер", "Все настройки SEO", "Прогноз поставок", "API"], "current": user.subscription_plan == "business", "color": "emerald"}
    ]
</file>

<file path="backend/tasks/__init__.py">
from .bidder import bidder_producer_task, bidder_consumer_task
from .finance import sync_financial_reports, train_forecasting_models
from .seo import analyze_reviews_task, generate_seo_task, cluster_keywords_task, check_seo_position_task
from .monitoring import parse_and_save_sku, update_all_monitored_items, check_new_orders
from .utils import get_status

__all__ = [
    "bidder_producer_task",
    "bidder_consumer_task",
    "sync_financial_reports",
    "train_forecasting_models",
    "analyze_reviews_task",
    "generate_seo_task",
    "cluster_keywords_task",
    "check_seo_position_task",
    "parse_and_save_sku",
    "update_all_monitored_items",
    "check_new_orders",
    "get_status"
]
</file>

<file path="backend/tasks/bidder.py">
import logging
import asyncio
import redis
from datetime import datetime
from typing import Dict, Any, Optional

from celery_app import celery_app, REDIS_URL
from wb_api_service import wb_api_service
from database import SyncSessionLocal, User, BidderSettings
from bidder_engine import PIDController
from .utils import log_bidder_action_sync

logger = logging.getLogger("Tasks-Bidder")

try:
    r_client = redis.from_url(REDIS_URL, decode_responses=True)
except Exception as e:
    logger.error(f"Redis connect error: {e}")
    r_client = None

class BidderWorker:
    def __init__(self, user_id: int, token: str, settings: BidderSettings):
        self.user_id = user_id
        self.token = token
        self.settings = {
            "target_pos": settings.target_pos,
            "min_bid": settings.min_bid,
            "max_bid": settings.max_bid,
            "target_cpa": settings.target_cpa,
            "max_cpm": settings.max_cpm,
            "strategy": settings.strategy
        }
        self.campaign_id = settings.campaign_id
        self.is_active = settings.is_active

    async def process_campaign(self):
        if not self.is_active: return

        campaign_key = f"bidder:state:{self.campaign_id}"
        
        # 1. Fetch Stats for CPA Guard (CTR, Conversions)
        stats = await wb_api_service.get_advert_stats(self.token, self.campaign_id)
        if not stats:
            logger.warning(f"No stats for campaign {self.campaign_id}")
            stats = {"ctr": 1.5, "views": 0} # Safe defaults

        # 2. Get Current Auction State
        info = await wb_api_service.get_current_bid_info(self.token, self.campaign_id)
        current_bid = info.get('price', 0)
        current_pos = info.get('position', 100)
        
        # 3. Load PID State
        integral, prev_meas, last_update = 0.0, None, 0.0
        if r_client:
            state = r_client.hgetall(campaign_key)
            if state:
                integral = float(state.get('integral', 0.0))
                prev_meas = float(state.get('prev_meas')) if state.get('prev_meas') else None
                last_update = float(state.get('last_update', 0.0))

        now = datetime.now().timestamp()
        dt = now - last_update if last_update > 0 else 1.0

        # 4. PID Calculation
        pid = PIDController(
            target_pos=self.settings['target_pos'],
            min_bid=self.settings['min_bid'],
            max_bid=self.settings['max_bid']
        )
        pid.load_state(integral, prev_meas)
        pid_bid = pid.update(current_pos, current_bid, dt)

        # 5. Strategy & Safety Layer
        strategy_manager = StrategyManager(self.settings)
        # Assuming conversion rate ~ 3% if not available
        conv_rate = stats.get('cr', 0.03) 
        
        final_bid, action_reason = strategy_manager.decide_bid(
            pid_bid=pid_bid,
            current_metrics={"ctr": stats.get('ctr', 0), "cr": conv_rate},
            competitor_bid=None 
        )

        # 6. Save State
        new_integral, new_prev_meas = pid.get_state()
        if r_client:
            r_client.hset(campaign_key, mapping={
                'integral': new_integral,
                'prev_meas': new_prev_meas if new_prev_meas else '',
                'last_update': now
            })
            r_client.expire(campaign_key, 3600)

        # 7. Execute Update
        if final_bid != current_bid:
            await wb_api_service.update_bid(self.token, self.campaign_id, final_bid)
            logger.info(f"Camp {self.campaign_id}: {current_bid} -> {final_bid} ({action_reason})")
        else:
            action_reason = "hold"

        # 8. Log
        log_bidder_action_sync(
            self.user_id, self.campaign_id, current_pos, 
            self.settings['target_pos'], current_bid, final_bid, action_reason
        )

@celery_app.task(name="bidder_producer_task")
def bidder_producer_task():
    """Finds active campaigns in DB and launches workers."""
    session = SyncSessionLocal()
    try:
        active_settings = session.query(BidderSettings).filter(BidderSettings.is_active == True).all()
        logger.info(f"Bidder Producer: Found {len(active_settings)} active campaigns.")
        
        for setting in active_settings:
            user = session.query(User).filter(User.id == setting.user_id).first()
            if user and user.wb_api_token:
                bidder_consumer_task.delay(user.id, user.wb_api_token, setting.campaign_id)
    finally:
        session.close()

@celery_app.task(bind=True, name="bidder_consumer_task")
def bidder_consumer_task(self, user_id: int, token: str, campaign_id: int):
    session = SyncSessionLocal()
    try:
        setting = session.query(BidderSettings).filter(
            BidderSettings.campaign_id == campaign_id, 
            BidderSettings.user_id == user_id
        ).first()
        
        if not setting: return

        worker = BidderWorker(user_id, token, setting)
        
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(worker.process_campaign())
        loop.close()
    except Exception as e:
        logger.error(f"Bidder Worker Error for Camp {campaign_id}: {e}")
    finally:
        session.close()
</file>

<file path="backend/tasks/finance.py">
import logging
import asyncio
import aiohttp
import json
import redis
import pandas as pd
from datetime import datetime, timedelta

from celery_app import celery_app, REDIS_URL
from wb_api_service import wb_api_service
from clickhouse_models import ch_service
from database import SyncSessionLocal, User
from forecasting import forecast_demand

logger = logging.getLogger("Tasks-Finance")

try:
    r_client = redis.from_url(REDIS_URL, decode_responses=True)
except Exception as e:
    logger.error(f"Redis connect error: {e}")
    r_client = None

class FinancialSyncProcessor:
    WB_STATS_URL = "https://statistics-api.wildberries.ru/api/v5/supplier/reportDetailByPeriod"
    WB_ORDERS_URL = "https://statistics-api.wildberries.ru/api/v1/supplier/orders"
    BATCH_SIZE = 5000
    
    # Define valid columns strictly matching ClickHouse schema
    VALID_COLUMNS = {
        'rrd_id', 'realizationreport_id', 'supplier_id', 'gi_id', 'subject_name', 
        'nm_id', 'brand_name', 'sa_name', 'ts_name', 'barcode', 'doc_type_name', 
        'office_name', 'supplier_oper_name', 'site_country', 'create_dt', 
        'order_dt', 'sale_dt', 'rr_dt', 'quantity', 'retail_price', 
        'retail_amount', 'sale_percent', 'commission_percent', 
        'retail_price_withdisc_rub', 'delivery_amount', 'return_amount', 
        'delivery_rub', 'gi_box_type_name', 'product_discount_for_report', 
        'supplier_promo', 'rid', 'ppvz_spp_prc', 'ppvz_kvw_prc_base', 
        'ppvz_kvw_prc', 'sup_rating_prc_up', 'is_kgvp_v2', 'ppvz_sales_commission', 
        'ppvz_for_pay', 'ppvz_reward', 'acquiring_fee', 'acquiring_bank', 
        'ppvz_vw', 'ppvz_vw_nds', 'ppvz_office_id', 'penalty', 
        'additional_payment', 'rebill_logistic_cost'
    }

    def __init__(self, token: str, user_id: int):
        self.token = token
        self.user_id = user_id
        self.headers = {"Authorization": token}
        self.semaphore = asyncio.Semaphore(3)
        self.buffer = []

    async def _fetch_with_retry(self, session, url, params, retries=3):
        for i in range(retries):
            async with self.semaphore:
                try:
                    async with session.get(url, params=params, headers=self.headers, timeout=60) as resp:
                        if resp.status == 429:
                            await asyncio.sleep(2 ** (i + 1))
                            continue
                        if resp.status != 200:
                            logger.error(f"WB API Error {resp.status}: {await resp.text()}")
                            return None
                        return await resp.json()
                except Exception as e:
                    logger.warning(f"Fetch attempt {i} failed: {e}")
                    await asyncio.sleep(1)
        return None

    def _flush_buffer(self):
        if not self.buffer: 
            return
        try:
            df = pd.DataFrame(self.buffer)
            
            # Filter only valid columns to avoid "Unrecognized column" errors
            valid_cols = [c for c in df.columns if c in self.VALID_COLUMNS]
            df = df[valid_cols]

            numeric_cols = ['retail_price', 'retail_amount', 'retail_price_withdisc_rub', 'delivery_rub', 'ppvz_for_pay', 'penalty', 'additional_payment', 'ppvz_sales_commission', 'ppvz_reward']
            for col in numeric_cols:
                if col in df.columns:
                    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

            date_cols = ['create_dt', 'order_dt', 'sale_dt', 'rr_dt']
            for col in date_cols:
                if col in df.columns:
                    df[col] = pd.to_datetime(df[col], errors='coerce').fillna(datetime.now())

            records = df.to_dict('records')
            if records:
                ch_service.insert_reports(records)
                logger.info(f" flushed {len(records)} records to ClickHouse for user {self.user_id}")
            self.buffer = []
        except Exception as e:
            logger.error(f"Failed to flush buffer: {e}")
            self.buffer = []

    async def sync_actual_reports(self, date_from: datetime, date_to: datetime):
        async with aiohttp.ClientSession() as session:
            rrdid = 0
            while True:
                params = {
                    "dateFrom": date_from.strftime("%Y-%m-%dT%H:%M:%S"),
                    "dateTo": date_to.strftime("%Y-%m-%dT%H:%M:%S"),
                    "limit": 1000,
                    "rrdid": rrdid
                }
                data = await self._fetch_with_retry(session, self.WB_STATS_URL, params)
                if not data: break

                processed_batch = []
                for row in data:
                    row['supplier_id'] = self.user_id
                    if not row.get('rr_dt'): row['rr_dt'] = row.get('create_dt')
                    processed_batch.append(row)
                    rrdid = row.get('rrd_id', rrdid)

                self.buffer.extend(processed_batch)
                if len(self.buffer) >= self.BATCH_SIZE:
                    self._flush_buffer()
                
                if len(data) < 1000: break
        
        self._flush_buffer()

    async def sync_provisional_orders(self):
        date_from = (datetime.now() - timedelta(days=2)).strftime("%Y-%m-%dT%H:%M:%S")
        async with aiohttp.ClientSession() as session:
            params = {"dateFrom": date_from, "flag": 0} 
            data = await self._fetch_with_retry(session, self.WB_ORDERS_URL, params)
            if not data: return

            for order in data:
                report_row = {
                    "rrd_id": order.get("odid", 0),
                    "realizationreport_id": 0,
                    "supplier_id": self.user_id,
                    "nm_id": order.get("nmId"),
                    "gi_id": 0,
                    "subject_name": order.get("category"),
                    "brand_name": order.get("brand"),
                    "sa_name": order.get("article"),
                    "ts_name": "",
                    "barcode": "",
                    "doc_type_name": "Provisional_Order",
                    "office_name": order.get("warehouseName"),
                    "supplier_oper_name": "",
                    "site_country": order.get("regionName"),
                    "create_dt": order.get("date"),
                    "order_dt": order.get("date"),
                    "sale_dt": order.get("date"),
                    "rr_dt": datetime.now(),
                    "quantity": 1,
                    "retail_price": order.get("priceBeforeDisc", 0),
                    "retail_amount": order.get("priceWithDiscount", 0),
                    "sale_percent": order.get("discountPercent", 0),
                    "commission_percent": 25.00,
                    "retail_price_withdisc_rub": order.get("priceWithDiscount", 0),
                    "delivery_rub": 50.00,
                    "ppvz_sales_commission": order.get("priceWithDiscount", 0) * 0.25,
                    "penalty": 0,
                    "additional_payment": 0,
                    "return_amount": 0,
                    "delivery_amount": 1,
                    "product_discount_for_report": 0,
                    "supplier_promo": 0,
                    "rid": order.get("gNumber", 0)
                }
                self.buffer.append(report_row)
            self._flush_buffer()

    async def run_full_sync(self):
        end = datetime.now()
        start = end - timedelta(days=30)
        logger.info(f"Starting Actual Sync for user {self.user_id}")
        await self.sync_actual_reports(start, end)
        logger.info(f"Starting Provisional Sync for user {self.user_id}")
        await self.sync_provisional_orders()

@celery_app.task(bind=True, name="sync_financial_reports")
def sync_financial_reports(self, user_id: int):
    self.update_state(state='PROGRESS', meta={'status': 'Initializing Sync...'})
    session = SyncSessionLocal()
    try:
        user = session.query(User).filter(User.id == user_id).first()
        if not user or not user.wb_api_token:
            return {"status": "error", "message": "No token"}
        token = user.wb_api_token
    finally:
        session.close()

    processor = FinancialSyncProcessor(token, user_id)
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(processor.run_full_sync())
        loop.close()
        return {"status": "success", "message": "Financial data synced"}
    except Exception as e:
        logger.error(f"Sync failed for user {user_id}: {e}")
        return {"status": "error", "error": str(e)}

@celery_app.task(name="train_forecasting_models")
def train_forecasting_models():
    logger.info("Starting forecasting training cycle...")
    try:
        ch_client = ch_service.get_client()
        query_items = "SELECT DISTINCT supplier_id, nm_id FROM wb_analytics.realization_reports WHERE sale_dt > now() - INTERVAL 90 DAY"
        result = ch_client.query(query_items)
        items = result.result_rows
        
        logger.info(f"Found {len(items)} items to forecast.")
        
        for row in items:
            supplier_id, sku = row
            query_history = """
            SELECT toDate(sale_dt) as ds, sum(quantity) as y
            FROM wb_analytics.realization_reports
            WHERE supplier_id = %(uid)s AND nm_id = %(sku)s AND doc_type_name = 'Продажа'
            GROUP BY ds ORDER BY ds ASC
            """
            history_res = ch_client.query(query_history, parameters={'uid': supplier_id, 'sku': sku})
            history_rows = history_res.result_rows
            
            if not history_rows: continue
            
            sales_history = [{"date": str(h[0]), "qty": int(h[1])} for h in history_rows]
            forecast_result = forecast_demand(sales_history, horizon_days=30)
            
            if r_client and forecast_result.get("status") == "success":
                key = f"forecast:{supplier_id}:{sku}"
                r_client.set(key, json.dumps(forecast_result), ex=90000)
                
    except Exception as e:
        logger.error(f"Forecasting cycle failed: {e}")
</file>

<file path="backend/tasks/monitoring.py">
import logging
import asyncio
from datetime import datetime

from celery_app import celery_app
from parser_service import parser_service
from analysis_service import analysis_service
from wb_api_service import wb_api_service
from bot_service import bot_service
from database import SyncSessionLocal, MonitoredItem, User
from .utils import save_price_sync, save_history_sync

logger = logging.getLogger("Tasks-Monitoring")

@celery_app.task(bind=True, name="parse_and_save_sku")
def parse_and_save_sku(self, sku: int, user_id: int = None):
    self.update_state(state='PROGRESS', meta={'status': 'Запуск парсера...'})
    
    raw_result = parser_service.get_product_data(sku)
    
    if raw_result.get("status") == "error": 
        err_msg = raw_result.get("message", "Unknown error")
        return {"status": "error", "error": err_msg}
    
    self.update_state(state='PROGRESS', meta={'status': 'Сохранение...'})
    
    save_price_sync(sku, raw_result)
    final_result = analysis_service.calculate_metrics(raw_result)

    if user_id:
        p = raw_result.get('prices', {})
        brand = raw_result.get('brand', 'WB')
        title = f"{p.get('wallet_purple')}₽ | {brand}"
        save_history_sync(user_id, sku, 'price', title, final_result)

    return final_result

@celery_app.task(name="update_all_monitored_items")
def update_all_monitored_items():
    session = SyncSessionLocal()
    try:
        skus = [i.sku for i in session.query(MonitoredItem).all()]
        logger.info(f"Beat: Starting update for {len(skus)} items")
        for sku in skus:
            parse_and_save_sku.delay(sku)
    finally:
        session.close()

def _process_orders_sync():
    session = SyncSessionLocal()
    try:
        users = session.query(User).filter(User.wb_api_token.isnot(None)).all()
        
        async def check_user(user):
            try:
                new_orders = await wb_api_service.get_new_orders_since(user.wb_api_token, user.last_order_check)
                if new_orders:
                    total_sum = sum(x.get('priceWithDiscount', 0) for x in new_orders)
                    msg = f"🔔 <b>Дзынь! Новые заказы: +{len(new_orders)}</b>\n"
                    msg += f"💰 Сумма: {total_sum:,.0f} ₽\n\n"
                    
                    for o in new_orders[:3]: 
                        price = o.get('priceWithDiscount', 0)
                        category = o.get('category', 'Товар')
                        msg += f"📦 {category}: {price:,.0f} ₽\n"
                    
                    if len(new_orders) > 3:
                        msg += f"...и еще {len(new_orders)-3} шт."
                    
                    await bot_service.send_message(user.telegram_id, msg)
                    return True
            except Exception as e:
                logger.error(f"User {user.id} error: {e}")
            return False

        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        for user in users:
            found = loop.run_until_complete(check_user(user))
            if found:
                user.last_order_check = datetime.now()
                session.commit()
                
        loop.close()
        
    finally:
        session.close()

@celery_app.task(name="check_new_orders")
def check_new_orders():
    _process_orders_sync()
</file>

<file path="backend/tasks/seo.py">
import logging
import asyncio
from typing import List

from celery_app import celery_app
from parser_service import parser_service, GEO_ZONES
from analysis_service import analysis_service
from .utils import save_history_sync, save_seo_position_sync

logger = logging.getLogger("Tasks-SEO")

@celery_app.task(bind=True, name="analyze_reviews_task")
def analyze_reviews_task(self, sku: int, limit: int = 50, user_id: int = None):
    self.update_state(state='PROGRESS', meta={'status': 'Парсинг карточки и отзывов...'})
    
    product_info = parser_service.get_full_product_info(sku, limit)
    if product_info.get("status") == "error":
        return {"status": "error", "error": product_info.get("message")}
    
    self.update_state(state='PROGRESS', meta={'status': 'ABSA Аналитика (DeepSeek-V3)...'})
    
    reviews = product_info.get('reviews', [])
    product_name = product_info.get('name', f"Товар {sku}")
    ai_result = analysis_service.analyze_reviews_with_ai(reviews, product_name)

    final_result = {
        "status": "success",
        "sku": sku,
        "product_name": product_name,
        "image": product_info.get('image'),
        "rating": product_info.get('rating'),
        "reviews_count": len(reviews),
        "ai_analysis": ai_result
    }

    if user_id:
        title = f"ABSA: {product_name[:30]} ({len(reviews)} отз.)"
        save_history_sync(user_id, sku, 'ai', title, final_result)

    return final_result

@celery_app.task(bind=True, name="generate_seo_task")
def generate_seo_task(self, keywords: list, tone: str, sku: int = 0, user_id: int = None, title_len: int = 100, desc_len: int = 1000):
    self.update_state(state='PROGRESS', meta={'status': 'Генерация GEO контента...'})
    
    content = analysis_service.generate_product_content(keywords, tone, title_len, desc_len)
    
    final_result = {
        "status": "success",
        "sku": sku,
        "keywords": keywords,
        "tone": tone,
        "generated_content": content 
    }
    
    if user_id and sku > 0:
        title = f"GEO: {content.get('title', 'Без заголовка')[:20]}..."
        save_history_sync(user_id, sku, 'seo', title, final_result)
        
    return final_result

@celery_app.task(bind=True, name="cluster_keywords_task")
def cluster_keywords_task(self, keywords: List[str], user_id: int = None, sku: int = 0):
    self.update_state(state='PROGRESS', meta={'status': 'Загрузка BERT модели...'})
    
    result = analysis_service.cluster_keywords(keywords)
    
    if user_id and sku > 0:
        title = f"Clusters: {len(keywords)} keys ({result.get('n_clusters', 0)} groups)"
        save_history_sync(user_id, sku, 'clusters', title, result)
        
    return result

@celery_app.task(bind=True, name="check_seo_position_task")
def check_seo_position_task(self, sku: int, keyword: str, user_id: int, regions: List[str] = None):
    self.update_state(state='PROGRESS', meta={'status': 'Geo Tracking...'})
    if not regions: regions = ["moscow"]

    async def check_all_regions():
        tasks = []
        for reg_name in regions:
            dest_id = GEO_ZONES.get(reg_name.lower(), GEO_ZONES["moscow"])
            tasks.append(parser_service.get_search_position_v2(keyword, sku, dest=dest_id))
        return await asyncio.gather(*tasks)

    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        results = loop.run_until_complete(check_all_regions())
        loop.close()
        
        main_result = results[0]
        db_position = main_result["organic_pos"]
        save_seo_position_sync(user_id, sku, keyword, db_position)
        
        detailed_report = {}
        for reg, res in zip(regions, results): detailed_report[reg] = res

        return {"status": "success", "sku": sku, "keyword": keyword, "main_position": db_position, "geo_details": detailed_report}

    except Exception as e:
        logger.error(f"SEO Check Task Error: {e}")
        return {"status": "error", "message": str(e)}
</file>

<file path="backend/tasks/utils.py">
import json
import logging
from datetime import datetime
from celery.result import AsyncResult
from database import SyncSessionLocal, MonitoredItem, PriceHistory, SearchHistory, SeoPosition, BidderLog
from celery_app import celery_app

logger = logging.getLogger("Tasks-Utils")

def get_status(task_id: str):
    """
    Получение статуса задачи Celery.
    Используется в polling-запросах на фронтенде.
    """
    res = AsyncResult(task_id, app=celery_app)
    resp = {"task_id": task_id, "status": res.status}
    
    if res.status == 'SUCCESS':
        resp["data"] = res.result
    elif res.status == 'FAILURE':
        resp["error"] = str(res.result)
    elif res.status == 'PROGRESS':
        resp["info"] = res.info.get('status', 'Processing')
        
    return resp

def save_history_sync(user_id, sku, type, title, result_data):
    if not user_id: return
    session = SyncSessionLocal()
    try:
        if isinstance(result_data, dict):
            json_str = json.dumps(result_data, ensure_ascii=False)
        else:
            json_str = str(result_data)
            
        h = SearchHistory(user_id=user_id, sku=sku, request_type=type, title=title, result_json=json_str)
        session.add(h)
        session.commit()
    except Exception as e:
        logger.error(f"History DB error: {e}")
        session.rollback()
    finally:
        session.close()

def save_price_sync(sku, data):
    if data.get("status") == "error": return
    session = SyncSessionLocal()
    try:
        item = session.query(MonitoredItem).filter(MonitoredItem.sku == sku).first()
        if item:
            item.name = data.get("name")
            item.brand = data.get("brand")
            
            p = data.get("prices", {})
            ph = PriceHistory(
                item_id=item.id,
                wallet_price=p.get("wallet_purple", 0),
                standard_price=p.get("standard_black", 0),
                base_price=p.get("base_crossed", 0)
            )
            session.add(ph)
            session.commit()
            logger.info(f"DB: Updated price for {sku}")
    except Exception as e:
        logger.error(f"Price DB Error: {e}")
        session.rollback()
    finally:
        session.close()

def save_seo_position_sync(user_id, sku, keyword, position):
    session = SyncSessionLocal()
    try:
        pos_entry = session.query(SeoPosition).filter(
            SeoPosition.user_id == user_id, 
            SeoPosition.sku == sku, 
            SeoPosition.keyword == keyword
        ).first()
        
        if pos_entry:
            pos_entry.position = position
            pos_entry.last_check = datetime.utcnow()
        else:
            pos_entry = SeoPosition(user_id=user_id, sku=sku, keyword=keyword, position=position)
            session.add(pos_entry)
        session.commit()
    except Exception as e:
        logger.error(f"SEO DB Error: {e}")
        session.rollback()
    finally:
        session.close()

def log_bidder_action_sync(user_id, campaign_id, current_pos, target_pos, prev_bid, calc_bid, action):
    session = SyncSessionLocal()
    try:
        saved = (prev_bid - calc_bid) if (prev_bid and calc_bid) else 0
        log = BidderLog(
            user_id=user_id, campaign_id=campaign_id, current_pos=current_pos,
            target_pos=target_pos, previous_bid=prev_bid, calculated_bid=calc_bid,
            saved_amount=saved, action=action
        )
        session.add(log)
        session.commit()
    except Exception as e:
        logger.error(f"Bidder Log DB Error: {e}")
    finally:
        session.close()
</file>

<file path="backend/wb_api_service.py">
# Backward compatibility shim
from wb_api import wb_api_service, WBApiService
</file>

<file path="backend/wb_api/__init__.py">
from .base import WBApiBase
from .statistics import WBStatisticsMixin
from .promotion import WBPromotionMixin

class WBApiService(WBStatisticsMixin, WBPromotionMixin, WBApiBase):
    """
    Единый фасад для работы с API Wildberries.
    Наследует методы из миксинов Statistics и Promotion, а также Base.
    """
    pass

# Создаем синглтон, как было в оригинальном файле
wb_api_service = WBApiService()

__all__ = ["wb_api_service", "WBApiService"]
</file>

<file path="backend/wb_api/base.py">
import logging
import asyncio
import aiohttp
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List

logger = logging.getLogger("WB-API-Base")

class WBApiBase:
    """
    Базовый класс для работы с API WB.
    Содержит общие настройки, кэширование и метод отправки запросов.
    """
    
    BASE_URL = "https://statistics-api.wildberries.ru/api/v1/supplier"
    COMMON_URL = "https://common-api.wildberries.ru/api/v1" 
    ADV_URL = "https://advert-api.wb.ru/adv/v1" 
    
    # In-Memory Cache: { "token_method_params": (timestamp, data) }
    _cache: Dict[str, Any] = {}
    _cache_ttl = 300 # 5 минут (TTL)

    async def _request_with_retry(self, session, url, headers, params=None, method='GET', json_data=None, retries=3):
        """
        Выполняет запрос с повторными попытками при 429/5xx ошибках.
        """
        backoff = 2
        
        for attempt in range(retries):
            try:
                if method == 'GET':
                    coro = session.get(url, headers=headers, params=params, timeout=20)
                else:
                    coro = session.post(url, headers=headers, json=json_data, timeout=20)

                async with coro as resp:
                    if resp.status == 200:
                        return await resp.json()
                    elif resp.status == 429:
                        logger.warning(f"WB API Rate Limit (429) on {url}. Retrying in {backoff}s...")
                        await asyncio.sleep(backoff)
                        backoff *= 2 
                    elif resp.status >= 500:
                        logger.warning(f"WB API Server Error ({resp.status}). Retrying...")
                        await asyncio.sleep(backoff)
                        backoff *= 2
                    elif resp.status == 204:
                         return None # No content
                    else:
                        text = await resp.text()
                        logger.error(f"WB API Error {resp.status} on {url}: {text}")
                        return None
            except Exception as e:
                logger.error(f"Request failed: {e}")
                await asyncio.sleep(backoff)
        
        return None

    def _get_cache_key(self, token, method, params):
        token_part = token[-10:] if token else "none"
        param_str = json.dumps(params, sort_keys=True)
        return f"{token_part}:{method}:{param_str}"

    async def _get_cached_or_request(self, session, url, headers, params, use_cache=True):
        if not use_cache:
            return await self._request_with_retry(session, url, headers, params)

        cache_key = self._get_cache_key(headers.get("Authorization"), url, params)
        
        if cache_key in self._cache:
            ts, data = self._cache[cache_key]
            if (datetime.now() - ts).total_seconds() < self._cache_ttl:
                return data
        
        data = await self._request_with_retry(session, url, headers, params)
        
        if data is not None:
            self._cache[cache_key] = (datetime.now(), data)
            
        return data

    async def check_token(self, token: str) -> bool:
        if not token: 
            return False
        
        url = f"{self.BASE_URL}/incomes"
        params = {"dateFrom": datetime.now().strftime("%Y-%m-%d")}
        headers = {"Authorization": token}
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url, headers=headers, params=params, timeout=10) as resp:
                    if resp.status == 401:
                        return False
                    return True
            except Exception as e:
                logger.error(f"Token check error: {e}")
                return False
</file>

<file path="backend/wb_api/content.py">
import logging
from typing import List, Dict, Any
from .base import WBBaseClient, WBEndpoint

logger = logging.getLogger("WB-API-Content")

class WBContentMixin(WBBaseClient):

    async def get_cards_list(self, token: str, limit: int = 100, offset: int = 0, search: str = "") -> Dict:
        """Получение списка номенклатур (карточек товаров)"""
        
        payload = {
            "settings": {
                "cursor": {
                    "limit": limit
                },
                "filter": {
                    "withPhoto": -1
                }
            }
        }
        
        if search:
            payload["settings"]["filter"]["textSearch"] = search
            
        data = await self._request("POST", WBEndpoint.CONTENT_CARDS.value, token, json_data=payload)
        
        if not data or "cards" not in data:
            return {"cards": [], "cursor": {}}
            
        return data
</file>

<file path="backend/wb_api/promotion.py">
import logging
import aiohttp
from typing import Optional, Dict, Any, List
from .base import WBApiBase

logger = logging.getLogger("WB-API-Promotion")

class WBPromotionMixin(WBApiBase):

    async def get_advert_campaigns(self, token: str):
        """Получение списка рекламных кампаний (Реклама > Список кампаний)"""
        # Сначала получаем ID кампаний, затем их инфо
        # WB не дает просто список, нужно запросить ID по статусам
        url_count = f"{self.ADV_URL}/promotion/count"
        url_ids = f"{self.ADV_URL}/promotion/adverts"
        url_infos = f"{self.ADV_URL}/promotion/adverts" # POST info
        
        headers = {"Authorization": token}
        
        async with aiohttp.ClientSession() as session:
            # 1. Получаем список ID (активные - 9, пауза - 11)
            # В реальном API WB V1 может быть другой endpoint, используем стандартный
            ids_payload = {"status": [9, 11], "type": [6, 8, 9]} # 6=Поиск, 8=Авто, 9=Карточка
            campaigns_list = await self._request_with_retry(session, url_ids, headers, method='POST', json_data=ids_payload)
            
            if not campaigns_list:
                return []
            
            # campaigns_list это список объектов. Нам нужны детали.
            # Если API возвращает сразу детали - отлично. Если нет - запрашиваем.
            # Обычно /promotion/adverts возвращает массив ID или краткую инфо.
            # Предположим возврат в формате WB API: [{id, type, status, ...}]
            
            # Обогатим информацией о бюджете/ставке
            results = []
            for camp in campaigns_list:
                # Фильтруем мусор
                if not isinstance(camp, dict): continue
                
                # Запрос статистики или доп инфо, если нужно. Пока возвращаем то что есть.
                results.append({
                    "id": camp.get("advertId"),
                    "name": camp.get("name", f"Кампания {camp.get('advertId')}"),
                    "status": camp.get("status"),
                    "type": camp.get("type"),
                    "changeTime": camp.get("changeTime")
                })
            
            return results

    async def get_advert_stats(self, token: str, campaign_id: int):
        """Получение полной статистики кампании"""
        url = f"{self.ADV_URL}/fullstat"
        headers = {"Authorization": token}
        # WB требует список id
        payload = [{"id": campaign_id}]
        
        async with aiohttp.ClientSession() as session:
            data = await self._request_with_retry(session, url, headers, method='POST', json_data=payload)
            # data is list of results
            if data and isinstance(data, list) and len(data) > 0:
                stat = data[0]
                return {
                    "views": stat.get("views", 0),
                    "clicks": stat.get("clicks", 0),
                    "ctr": stat.get("ctr", 0),
                    "spend": stat.get("sum", 0),
                    "cr": 0 # WB API не всегда отдает CR прямо
                }
            return None

    async def get_current_bid_info(self, token: str, campaign_id: int):
        """Получение текущей ставки"""
        # Используем endpoint /v0/advert (получение инфо о кампании)
        # Или /v1/promotion/adverts c ID
        url = f"https://advert-api.wb.ru/adv/v0/advert"
        headers = {"Authorization": token}
        params = {"id": campaign_id}
        
        async with aiohttp.ClientSession() as session:
            data = await self._request_with_retry(session, url, headers, params=params)
            
            if data and "params" in data:
                # Структура зависит от типа кампании (Поиск/Авто)
                params_list = data.get("params", [])
                if params_list:
                    # Берем первую сущность
                    p = params_list[0]
                    return {
                        "campaignId": campaign_id,
                        "price": p.get("price", 0),
                        "subjectId": p.get("subjectId")
                    }
            return {"campaignId": campaign_id, "price": 0, "position": 0}

    async def update_bid(self, token: str, campaign_id: int, new_bid: int):
        """
        Реальное обновление ставки.
        Endpoint: /adv/v0/save (для старых типов) или /adv/v1/save-ad (для авто)
        Для универсальности используем v0/save который работает для поиска/карточки.
        """
        url = f"https://advert-api.wb.ru/adv/v0/save"
        headers = {"Authorization": token}
        # Структура payload сложная и зависит от типа кампании.
        # Для упрощения предполагаем тип 6 (Поиск).
        
        # Сначала надо получить текущие параметры, чтобы не затереть их
        current_info = await self.get_current_bid_info(token, campaign_id)
        if not current_info or "subjectId" not in current_info:
            logger.error(f"Cannot update bid: failed to fetch current info for {campaign_id}")
            return
            
        payload = {
            "advertId": campaign_id,
            "type": 6, 
            "params": [
                {
                    "subjectId": current_info["subjectId"],
                    "price": new_bid
                }
            ]
        }
        
        async with aiohttp.ClientSession() as session:
            await self._request_with_retry(session, url, headers, method='POST', json_data=payload)
            logger.info(f"REAL BID UPDATE: Campaign {campaign_id} -> {new_bid} RUB")
</file>

<file path="backend/wb_api/statistics.py">
import asyncio
import aiohttp
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from .base import WBApiBase

class WBStatisticsMixin(WBApiBase):
    
    async def get_token_scopes(self, token: str) -> dict:
        """
        Диагностика доступных разделов API для данного токена.
        Возвращает словарь с флагами доступа.
        """
        headers = {"Authorization": token}
        results = {
            "statistics": False,
            "standard": False,
            "promotion": False,
            "questions": False
        }

        async with aiohttp.ClientSession() as session:
            # 1. Проверка Статистики (Используем /orders как маркер)
            try:
                # Тайм-аут короткий, нам нужен только статус код
                async with session.get(f"{self.BASE_URL}/orders", 
                                       params={"dateFrom": datetime.now().strftime("%Y-%m-%d")}, 
                                       headers=headers, timeout=5) as r:
                    # 401 = Unauthorized, 200/429 = OK (доступ есть)
                    results["statistics"] = r.status != 401
            except: 
                pass

            # 2. Проверка Контента/Общих (Standard) - тарифы
            try:
                async with session.get(f"{self.COMMON_URL}/tariffs/box", 
                                       params={"date": datetime.now().strftime("%Y-%m-%d")}, 
                                       headers=headers, timeout=5) as r:
                    results["standard"] = r.status != 401
            except: 
                pass

            # 3. Проверка Рекламы (Promotion)
            try:
                async with session.get(f"{self.ADV_URL}/promotion/count", 
                                       headers=headers, timeout=5) as r:
                    results["promotion"] = r.status != 401
            except: 
                pass

        return results

    async def get_dashboard_stats(self, token: str):
        """Сводка: Заказы сегодня и остатки"""
        if not token: 
            return {"orders_today": {"sum": 0, "count": 0}, "stocks": {"total_quantity": 0}}

        async with aiohttp.ClientSession() as session:
            today_str = datetime.now().strftime("%Y-%m-%dT00:00:00")
            
            orders_task = self._get_orders(session, token, today_str, use_cache=True)
            stocks_task = self._get_stocks(session, token, today_str, use_cache=True)
            
            orders_res, stocks_res = await asyncio.gather(orders_task, stocks_task)
            
            return {
                "orders_today": orders_res,
                "stocks": stocks_res
            }

    async def get_new_orders_since(self, token: str, last_check: datetime):
        if not last_check:
            last_check = datetime.now() - timedelta(hours=1)
        
        date_from_str = (last_check - timedelta(days=1)).strftime("%Y-%m-%dT%H:%M:%S")
        
        async with aiohttp.ClientSession() as session:
            orders_data = await self._get_orders(session, token, date_from_str, use_cache=False)
            
            if not orders_data or "items" not in orders_data:
                return []
            
            new_orders = []
            for order in orders_data["items"]:
                try:
                    order_date = datetime.strptime(order["date"], "%Y-%m-%dT%H:%M:%S")
                    if order_date > last_check:
                        new_orders.append(order)
                except: continue
                
            return new_orders

    async def get_my_stocks(self, token: str):
        if not token: return []
        
        today = datetime.now().strftime("%Y-%m-%dT00:00:00")
        url = f"{self.BASE_URL}/stocks"
        params = {"dateFrom": today}
        headers = {"Authorization": token}
        
        async with aiohttp.ClientSession() as session:
             data = await self._get_cached_or_request(session, url, headers, params, use_cache=True)
             return data if isinstance(data, list) else []

    async def get_warehouse_coeffs(self, token: str):
        """
        Получение реальных коэффициентов приемки.
        """
        url = f"{self.COMMON_URL}/tariffs/box"
        headers = {"Authorization": token} if token else {}
        today = datetime.now().strftime("%Y-%m-%d")
        params = {"date": today}

        async with aiohttp.ClientSession() as session:
            data = await self._get_cached_or_request(session, url, headers, params, use_cache=True)
            if data and 'response' in data and 'data' in data['response']:
                return data['response']['data']
            return []

    async def calculate_transit(self, liters: int, destination: str = "Koledino"):
        # Логика калькулятора остается на бэкенде, но коэффициенты можно брать из get_warehouse_coeffs
        # Для простоты оставляем расчет, но убираем заглушку рандома
        direct_base = 1500
        direct_rate = 30
        
        transit_base = 500 
        transit_rate = 10 
        transit_logistics = 1000 
        
        return {
            "destination": destination,
            "direct": {
                "rate": direct_rate,
                "total": direct_base + (liters * direct_rate)
            },
            "transit_kazan": {
                "rate": transit_rate,
                "logistics": transit_logistics,
                "total": transit_base + (liters * transit_rate) + transit_logistics
            }
        }

    async def _get_orders(self, session, token: str, date_from: str, use_cache=True):
        url = f"{self.BASE_URL}/orders"
        params = {"dateFrom": date_from}
        headers = {"Authorization": token}
        
        data = await self._get_cached_or_request(session, url, headers, params, use_cache=use_cache)
        
        if not data:
            return {"count": 0, "sum": 0, "items": []}
        
        if isinstance(data, list):
            valid_orders = [x for x in data if not x.get("isCancel")]
            total_sum = sum(item.get("priceWithDiscount", 0) for item in valid_orders)
            return {
                "count": len(valid_orders),
                "sum": int(total_sum),
                "items": valid_orders
            }
        return {"count": 0, "sum": 0, "items": []}

    async def _get_stocks(self, session, token: str, date_from: str, use_cache=True):
        url = f"{self.BASE_URL}/stocks"
        params = {"dateFrom": date_from}
        headers = {"Authorization": token}
        
        data = await self._get_cached_or_request(session, url, headers, params, use_cache=use_cache)
        
        if not data:
            return {"total_quantity": 0}
            
        if isinstance(data, list):
            total_qty = sum(item.get("quantity", 0) for item in data)
            return {"total_quantity": total_qty}
            
        return {"total_quantity": 0}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: wb_postgres
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=wb_secret_password
      - POSTGRES_DB=wb_monitor
      - LANG=C.UTF-8
    volumes:
      - postgres_data_final:/var/lib/postgresql/data
    ports: ["5433:5432"]
    healthcheck:
      test: ["NONE"]
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  clickhouse:
    image: clickhouse/clickhouse-server:latest
    container_name: wb_clickhouse
    restart: always
    ports:
      - "8123:8123"
      - "9000:9000"
    volumes:
      - clickhouse_data:/var/lib/clickhouse
    env_file:
      - ./backend/.env
    ulimits:
      nofile:
        soft: 262144
        hard: 262144
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  redis:
    image: redis:alpine
    container_name: wb_redis
    restart: always
    ports: ["6379:6379"]
    command: redis-server --save 60 1 --loglevel warning
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  api:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: wb_api
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes: 
      - ./backend:/app
      - ./backend/proxy_ext:/app/proxy_ext
    ports: ["8000:8000"]
    env_file:
      - ./backend/.env
    environment:
      - RUN_MIGRATIONS=true
      - REDIS_URL=redis://redis:6379/0
      - DATABASE_URL=postgresql+asyncpg://postgres:wb_secret_password@db:5432/wb_monitor
      - CLICKHOUSE_HOST=clickhouse
      - CLICKHOUSE_DB=wb_analytics
      - HEADLESS=True
      # DEBUG_MODE=True  <-- ЗАКОММЕНТИРОВАНО (Нормальный режим)
    depends_on: 
      db:
        condition: service_started
      redis:
        condition: service_started
      clickhouse:
        condition: service_started
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  worker:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: wb_worker
    command: celery -A celery_app worker --loglevel=info --concurrency=2
    volumes: 
      - ./backend:/app
      - ./backend/proxy_ext:/app/proxy_ext
    env_file:
      - ./backend/.env
    environment:
      - RUN_MIGRATIONS=false
      - C_FORCE_ROOT=1
      - REDIS_URL=redis://redis:6379/0
      - DATABASE_URL=postgresql+asyncpg://postgres:wb_secret_password@db:5432/wb_monitor
      - CLICKHOUSE_HOST=clickhouse
      - CLICKHOUSE_DB=wb_analytics
      - HEADLESS=True
    depends_on: 
      db:
        condition: service_started
      redis:
        condition: service_started
      clickhouse:
        condition: service_started
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  beat:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: wb_beat
    command: celery -A celery_app beat --loglevel=info
    volumes: 
      - ./backend:/app
    env_file:
      - ./backend/.env
    environment:
      - RUN_MIGRATIONS=false
      - REDIS_URL=redis://redis:6379/0
      - DATABASE_URL=postgresql+asyncpg://postgres:wb_secret_password@db:5432/wb_monitor
    depends_on: 
      redis:
        condition: service_started
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

volumes:
  postgres_data_final:
  clickhouse_data:
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    
    <!-- Подключаем SDK Telegram Mini App — без этого API Telegram не заработает -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <title>UB Monitor - Анализ WB</title>
  </head>
  <body>
    <div id="root"></div>
    
    <!-- Указываем путь к главному файлу React -->
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "ub-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "^0.284.0",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^4.3.9",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.24",
    "tailwindcss": "^3.3.2"
  }
}
</file>

<file path="frontend/postcss.config.js">
export default {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }
</file>

<file path="frontend/src/App.jsx">
import React, { useState, useEffect } from 'react';
import { API_URL, getTgHeaders } from './config';
import TabNav from './components/TabNav';

// Pages
import DashboardPage from './pages/DashboardPage';
import ScannerPage from './pages/ScannerPage';
import MonitorPage from './pages/MonitorPage';
import FinancePage from './pages/FinancePage';
import AIAnalysisPage from './pages/AIAnalysisPage';
import SeoGeneratorPage from './pages/SeoGeneratorPage';
import SeoTrackerPage from './pages/SeoTrackerPage';
import BidderPage from './pages/BidderPage';
import SupplyPage from './pages/SupplyPage';
import ProfilePage from './pages/ProfilePage';
import AdminPage from './pages/AdminPage';

export default function App() {
  const [activeTab, setActiveTab] = useState('home');
  const [user, setUser] = useState(null);

  useEffect(() => { 
      fetch(`${API_URL}/api/user/me`, { headers: getTgHeaders() })
        .then(r => r.json())
        .then(setUser)
        .catch(console.error); 
  }, [activeTab]);

  const renderContent = () => {
      switch(activeTab) {
          case 'home': return <DashboardPage onNavigate={setActiveTab} user={user} />;
          case 'scanner': return <ScannerPage onNavigate={setActiveTab} />;
          case 'monitor': return <MonitorPage />;
          case 'finance': return <FinancePage onNavigate={setActiveTab} />;
          case 'ai': return <AIAnalysisPage user={user} />;
          case 'seo': return <SeoGeneratorPage />;
          case 'seo_tracker': return <SeoTrackerPage />; 
          case 'bidder': return <BidderPage />; 
          case 'supply': return <SupplyPage />; 
          case 'profile': return <ProfilePage onNavigate={setActiveTab} />;
          case 'admin': return <AdminPage onBack={() => setActiveTab('profile')} />;
          default: return <DashboardPage onNavigate={setActiveTab} user={user} />;
      }
  };

  return (
    <div className="min-h-screen bg-[#F4F4F9] font-sans text-slate-900 select-none pb-24">
        {renderContent()}
        <TabNav active={activeTab} setTab={setActiveTab} isAdmin={user?.is_admin} />
    </div>
  );
}
</file>

<file path="frontend/src/components/CostEditModal.jsx">
import React, { useState } from 'react';

const CostEditModal = ({ item, onClose, onSave }) => {
    const [cost, setCost] = useState(item.cost_price || 0);
    return (
        <div className="fixed inset-0 z-[70] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 animate-in fade-in">
            <div className="bg-white w-full max-w-sm rounded-[32px] p-6 shadow-2xl">
                <h3 className="font-bold text-lg mb-2">Себестоимость</h3>
                <p className="text-xs text-slate-400 mb-4">Для расчета чистой прибыли SKU {item.sku}</p>
                <input 
                    type="number" 
                    value={cost} 
                    onChange={e => setCost(e.target.value)}
                    className="w-full bg-slate-50 text-2xl font-black text-center p-4 rounded-2xl outline-none focus:ring-2 ring-indigo-500 mb-4"
                />
                <div className="flex gap-2">
                    <button onClick={onClose} className="flex-1 py-3 bg-slate-100 font-bold rounded-xl text-slate-600">Отмена</button>
                    <button onClick={() => onSave(item.sku, cost)} className="flex-1 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-lg shadow-indigo-200">Сохранить</button>
                </div>
            </div>
        </div>
    );
};

export default CostEditModal;
</file>

<file path="frontend/src/components/HistoryModule.jsx">
import React, { useState, useEffect } from 'react';
import { API_URL, getTgHeaders } from '../config';
import { Brain, Wand2, BarChart3, Search, Star, ThumbsDown, Crown, X, Loader2, ChevronLeft, Copy, Table, HelpCircle, Layers, BrainCircuit } from 'lucide-react';

const CopyableBlock = ({ label, text, className="" }) => (
  <div className={`bg-slate-50 p-4 rounded-2xl border border-slate-100 mb-3 group relative ${className}`}>
    <div className="flex justify-between items-center mb-2">
        <span className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">{label}</span>
        <button 
            onClick={() => { navigator.clipboard.writeText(text); alert('Скопировано'); }} 
            className="p-2 text-slate-300 hover:text-indigo-600 transition-colors bg-white rounded-lg shadow-sm"
        >
            <Copy size={14}/>
        </button>
    </div>
    <div className="text-sm text-slate-700 whitespace-pre-wrap leading-relaxed">{text}</div>
  </div>
);

const HistoryModule = ({ type, isOpen, onClose }) => {
    const [history, setHistory] = useState([]);
    const [loading, setLoading] = useState(true);
    const [selectedItem, setSelectedItem] = useState(null);

    useEffect(() => {
        if (isOpen) {
            setLoading(true);
            // Если тип не указан, грузим все (или можно сделать фильтр "seo" включающий и "clusters")
            const url = type ? `${API_URL}/api/user/history?request_type=${type}` : `${API_URL}/api/user/history`;
            fetch(url, { 
                headers: getTgHeaders()
            })
            .then(r => r.json())
            .then(data => { setHistory(data); setLoading(false); })
            .catch(() => setLoading(false));
        }
    }, [isOpen, type]);

    if (!isOpen) return null;

    const getTypeIcon = (t) => {
        switch(t) {
            case 'ai': return <Brain size={18}/>;
            case 'seo': return <Wand2 size={18}/>;
            case 'price': return <BarChart3 size={18}/>;
            case 'clusters': return <BrainCircuit size={18} className="text-indigo-600"/>;
            default: return <Search size={18}/>;
        }
    };

    const renderDetails = (item) => {
        const data = item.data;
        
        // --- Clustering History ---
        if (item.type === 'clusters' && data.clusters) {
            return (
                 <div className="space-y-4 animate-in fade-in">
                    <div className="flex gap-2 mb-2">
                         <span className="bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full text-xs font-bold">
                            Всего слов: {data.total_keywords}
                         </span>
                         <span className="bg-emerald-100 text-emerald-700 px-3 py-1 rounded-full text-xs font-bold">
                            Кластеров: {data.n_clusters}
                         </span>
                    </div>
                    {data.clusters.map((c, i) => (
                        <div key={i} className="bg-white p-4 rounded-2xl border border-slate-100 shadow-sm">
                            <div className="flex items-center gap-2 mb-3">
                                <Layers size={16} className="text-indigo-500"/>
                                <h4 className="font-bold text-sm capitalize">{c.topic}</h4>
                                <span className="ml-auto text-xs bg-slate-100 px-2 py-0.5 rounded text-slate-500">{c.count}</span>
                            </div>
                            <div className="flex flex-wrap gap-1.5">
                                {c.keywords.map((k, j) => (
                                    <span key={j} className="text-[10px] bg-slate-50 text-slate-600 px-2 py-1 rounded-md border border-slate-100">{k}</span>
                                ))}
                            </div>
                        </div>
                    ))}
                 </div>
            )
        }

        // --- SEO History ---
        if (item.type === 'seo' && data.generated_content) {
            const content = data.generated_content;
            return (
                <div className="space-y-4 animate-in fade-in">
                    <div className="flex flex-wrap gap-1 mb-4">
                        {data.keywords?.slice(0, 10).map((k, i) => (
                            <span key={i} className="bg-indigo-50 text-indigo-700 px-2 py-1 rounded-lg text-[10px] font-bold">{k}</span>
                        ))}
                        {data.keywords?.length > 10 && <span className="text-[10px] text-slate-400 p-1">+{data.keywords.length - 10}</span>}
                    </div>

                    <CopyableBlock label="Заголовок" text={content.title} />
                    
                    {/* Features Table */}
                    {content.structured_features && (
                        <div className="bg-white p-4 rounded-2xl border border-slate-100 shadow-sm">
                            <h4 className="font-bold text-xs text-slate-500 uppercase mb-2 flex items-center gap-2">
                                <Table size={14}/> Характеристики
                            </h4>
                            <div className="text-xs">
                                {Object.entries(content.structured_features).map(([k, v], i) => (
                                    <div key={i} className="flex border-b border-slate-50 last:border-0 py-1.5">
                                        <span className="w-1/3 text-slate-400">{k}</span>
                                        <span className="w-2/3 font-medium text-slate-700">{v}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    <CopyableBlock label="Описание" text={content.description} />

                    {/* FAQ */}
                    {content.faq && (
                        <div className="bg-slate-50 p-4 rounded-2xl border border-slate-100">
                             <h4 className="font-bold text-xs text-slate-500 uppercase mb-3 flex items-center gap-2">
                                <HelpCircle size={14}/> FAQ
                            </h4>
                            <div className="space-y-3">
                                {content.faq.map((f, i) => (
                                    <div key={i}>
                                        <div className="font-bold text-xs text-slate-700 mb-1">❓ {f.question}</div>
                                        <div className="text-xs text-slate-500 leading-relaxed">{f.answer}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            )
        }

        // --- AI Analysis History ---
        if (item.type === 'ai' && data.ai_analysis) {
            return (
                <div className="space-y-4 animate-in fade-in">
                    <div className="flex gap-4 items-center bg-white border border-slate-100 p-3 rounded-2xl">
                         {data.image && <img src={data.image} className="w-12 h-16 object-cover rounded-lg" alt="product"/>}
                         <div>
                             <div className="font-bold text-lg flex items-center gap-1 text-amber-500"><Star size={16} fill="currentColor"/> {data.rating}</div>
                             <div className="text-xs text-slate-500">{data.reviews_count} отзывов</div>
                         </div>
                    </div>
                    
                    {data.ai_analysis.global_summary && (
                        <div className="bg-slate-800 p-3 rounded-xl text-xs text-slate-300 italic">
                            "{data.ai_analysis.global_summary}"
                        </div>
                    )}

                    <div className="bg-red-50 p-4 rounded-2xl border border-red-100">
                         <h4 className="font-bold text-red-600 text-sm mb-2 flex items-center gap-2"><ThumbsDown size={14}/> Жалобы</h4>
                         <ul className="text-sm space-y-2 text-slate-700">
                             {data.ai_analysis.flaws?.map((f,i) => <li key={i} className="bg-white p-2 rounded-lg shadow-sm text-xs">⛔ {f}</li>)}
                         </ul>
                    </div>
                    <div className="bg-indigo-50 p-4 rounded-2xl border border-indigo-100">
                         <h4 className="font-bold text-indigo-600 text-sm mb-2 flex items-center gap-2"><Crown size={14}/> Стратегия</h4>
                         <ul className="text-sm space-y-2 text-slate-700">
                             {data.ai_analysis.strategy?.map((s,i) => <li key={i} className="bg-white p-2 rounded-lg shadow-sm text-xs">{s}</li>)}
                         </ul>
                    </div>
                </div>
            )
        }

        // --- Price/Monitor History ---
        if (item.type === 'price' && data.prices) {
            return (
                <div className="space-y-4 animate-in fade-in">
                    <div className="flex gap-4 items-start">
                        {data.image && <img src={data.image} className="w-16 h-20 object-cover rounded-lg bg-slate-100" alt="product" />}
                        <div>
                            <div className="text-[10px] font-bold text-slate-400 uppercase">{data.brand}</div>
                            <div className="font-bold text-sm leading-tight">{data.name}</div>
                            <div className="mt-1 text-xs bg-slate-100 inline-block px-2 py-1 rounded text-slate-500">Остаток: {data.stock_qty} шт</div>
                        </div>
                    </div>
                    <div className="bg-slate-50 p-4 rounded-2xl border border-slate-100">
                        <div className="flex justify-between items-center mb-2">
                            <span className="text-sm font-medium text-slate-500">WB Кошелек</span>
                            <span className="text-xl font-black text-purple-600">{data.prices.wallet_purple} ₽</span>
                        </div>
                        <div className="flex justify-between items-center mb-1">
                            <span className="text-xs text-slate-400">Обычная цена</span>
                            <span className="text-sm font-bold text-slate-700">{data.prices.standard_black} ₽</span>
                        </div>
                        <div className="flex justify-between items-center">
                            <span className="text-xs text-slate-400">До скидок</span>
                            <span className="text-xs text-slate-400 line-through">{data.prices.base_crossed} ₽</span>
                        </div>
                    </div>
                </div>
            )
        }

        // --- Fallback ---
        return (
            <pre className="text-xs bg-slate-50 p-3 rounded-xl overflow-auto max-h-[60vh] text-slate-600 font-mono">
                {JSON.stringify(data, null, 2)}
            </pre>
        );
    };

    return (
        <div className="fixed inset-0 z-[60] bg-black/60 backdrop-blur-sm flex items-end sm:items-center justify-center animate-in fade-in duration-200">
            <div className="bg-white w-full max-w-lg sm:rounded-[32px] rounded-t-[32px] p-6 shadow-2xl relative max-h-[85vh] flex flex-col">
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-bold text-lg flex items-center gap-2">История {type && type !== 'clusters' && getTypeIcon(type)}</h3>
                    <button onClick={onClose} className="p-2 bg-slate-100 rounded-full text-slate-500 hover:bg-slate-200"><X size={20} /></button>
                </div>

                {!selectedItem ? (
                    <div className="flex-1 overflow-y-auto space-y-3 pb-4 custom-scrollbar">
                        {loading ? (
                            <div className="flex justify-center p-10"><Loader2 className="animate-spin text-slate-400"/></div>
                        ) : history.length === 0 ? (
                            <div className="text-center p-10 text-slate-400 border border-dashed border-slate-200 rounded-2xl">Пусто</div>
                        ) : (
                            history.map(h => (
                                <div key={h.id} onClick={() => setSelectedItem(h)} className="bg-slate-50 p-3 rounded-xl flex items-center gap-3 cursor-pointer active:scale-[0.99] transition-transform hover:bg-slate-100">
                                    <div className="bg-white p-2 rounded-lg text-indigo-600 shadow-sm">{getTypeIcon(h.type)}</div>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-bold text-sm truncate">{h.title || `SKU ${h.sku}`}</div>
                                        <div className="text-[10px] text-slate-400">{new Date(h.created_at).toLocaleString('ru-RU')}</div>
                                    </div>
                                    <ChevronLeft className="rotate-180 text-slate-300" size={16}/>
                                </div>
                            ))
                        )}
                    </div>
                ) : (
                    <div className="flex-1 overflow-y-auto pb-4 custom-scrollbar">
                        <button onClick={() => setSelectedItem(null)} className="flex items-center gap-1 text-xs font-bold text-slate-400 mb-4 hover:text-indigo-600 transition-colors">
                            <ChevronLeft size={14}/> Назад к списку
                        </button>
                        <h3 className="font-bold text-xl mb-4 leading-tight">{selectedItem.title}</h3>
                        {renderDetails(selectedItem)}
                    </div>
                )}
            </div>
        </div>
    );
};

export default HistoryModule;
</file>

<file path="frontend/src/components/StoriesBar.jsx">
import React, { useState, useEffect } from 'react';
import { API_URL, getTgHeaders } from '../config';

const StoriesBar = () => {
    const [stories, setStories] = useState([]);
    
    useEffect(() => {
        fetch(`${API_URL}/api/internal/stories`, {
             headers: getTgHeaders()
        }).then(r => r.json()).then(setStories).catch(console.error);
    }, []);

    if (stories.length === 0) return null;

    return (
        <div className="flex gap-3 overflow-x-auto pb-4 px-2 scrollbar-hide">
            {stories.map(s => (
                <div key={s.id} className="flex flex-col items-center gap-1 min-w-[64px]">
                    <div className={`w-14 h-14 rounded-full p-[2px] ${s.color}`}>
                        <div className="w-full h-full rounded-full bg-white border-2 border-transparent flex items-center justify-center flex-col">
                             <span className="text-[10px] font-bold text-center leading-tight">{s.val}</span>
                        </div>
                    </div>
                    <span className="text-[9px] font-medium text-slate-500">{s.title}</span>
                </div>
            ))}
        </div>
    )
}

export default StoriesBar;
</file>

<file path="frontend/src/components/TabNav.jsx">
import React from 'react';
import { LayoutGrid, BarChart3, DollarSign, Brain, User } from 'lucide-react';

const TabNav = ({ active, setTab, isAdmin }) => (
  <div className="fixed bottom-0 left-0 right-0 bg-white/95 backdrop-blur-md border-t border-slate-100 px-2 py-3 flex justify-between items-end z-50 pb-8 safe-area-pb shadow-[0_-5px_20px_rgba(0,0,0,0.03)]">
    <button onClick={() => setTab('home')} className={`flex flex-col items-center gap-1 w-[20%] transition-colors ${active === 'home' ? 'text-indigo-600' : 'text-slate-400'}`}>
      <LayoutGrid size={22} strokeWidth={active === 'home' ? 2.5 : 2} />
      <span className="text-[9px] font-bold">Главная</span>
    </button>
    <button onClick={() => setTab('monitor')} className={`flex flex-col items-center gap-1 w-[20%] transition-colors ${active === 'monitor' ? 'text-indigo-600' : 'text-slate-400'}`}>
      <BarChart3 size={22} strokeWidth={active === 'monitor' ? 2.5 : 2} />
      <span className="text-[9px] font-bold">Цены</span>
    </button>
    
    <div className="relative -top-5 w-[20%] flex justify-center">
        <button 
            onClick={() => setTab('finance')} 
            className="bg-indigo-600 text-white w-14 h-14 rounded-full shadow-xl shadow-indigo-300 active:scale-95 transition-transform border-4 border-white flex items-center justify-center"
        >
            <DollarSign size={28} strokeWidth={3} />
        </button>
    </div>

    <button onClick={() => setTab('ai')} className={`flex flex-col items-center gap-1 w-[20%] transition-colors ${active === 'ai' ? 'text-indigo-600' : 'text-slate-400'}`}>
      <Brain size={22} strokeWidth={active === 'ai' ? 2.5 : 2} />
      <span className="text-[9px] font-bold">ИИ</span>
    </button>
    
    <button onClick={() => setTab('profile')} className={`flex flex-col items-center gap-1 w-[20%] transition-colors ${active === 'profile' ? 'text-indigo-600' : 'text-slate-400'}`}>
      <User size={22} strokeWidth={active === 'profile' ? 2.5 : 2} />
      <span className="text-[9px] font-bold">Профиль</span>
    </button>
  </div>
);

export default TabNav;
</file>

<file path="frontend/src/components/TariffCard.jsx">
import React from 'react';
import { Star, CheckCircle2 } from 'lucide-react';

const TariffCard = ({ plan, onPay }) => (
  <div className={`p-6 rounded-3xl border-2 relative overflow-hidden transition-all ${plan.is_best ? 'border-indigo-600 bg-indigo-50/50 scale-[1.02] shadow-lg' : 'border-slate-100 bg-white'}`}>
    {plan.is_best && (
      <div className="absolute top-0 right-0 bg-indigo-600 text-white px-3 py-1 rounded-bl-xl text-[10px] font-black uppercase">
        ХИТ
      </div>
    )}
    <h3 className={`text-xl font-black uppercase ${plan.is_best ? 'text-indigo-700' : 'text-slate-800'}`}>{plan.name}</h3>
    <div className="flex items-baseline gap-2 mt-2 mb-4">
        <span className="text-3xl font-black text-slate-900">{plan.price}</span>
        {plan.stars > 0 && <span className="text-xs font-bold text-amber-500 bg-amber-100 px-2 py-0.5 rounded-full flex items-center gap-1"><Star size={10} fill="currentColor"/> {plan.stars} Stars</span>}
    </div>
    
    <ul className="space-y-3 mb-6">
      {plan.features.map((f, i) => (
        <li key={i} className="flex items-start gap-3 text-sm font-medium text-slate-600">
          <CheckCircle2 size={16} className={`mt-0.5 ${plan.is_best ? 'text-indigo-600' : 'text-slate-400'}`} />
          <span>{f}</span>
        </li>
      ))}
    </ul>
    
    <button 
        onClick={() => !plan.current && onPay(plan)}
        className={`w-full py-4 rounded-xl font-bold text-sm shadow-lg active:scale-95 transition-all flex justify-center items-center gap-2 ${plan.current ? 'bg-slate-200 text-slate-500 cursor-not-allowed' : plan.is_best ? 'bg-indigo-600 text-white shadow-indigo-200' : 'bg-slate-900 text-white'}`}
    >
      {plan.current ? 'Ваш текущий план' : <>{plan.stars > 0 && <Star size={16} fill="currentColor" className="text-amber-400"/>} Оплатить Stars</>}
    </button>
  </div>
);

export default TariffCard;
</file>

<file path="frontend/src/config.js">
export const API_URL = "https://api.ulike-bot.ru";

export const getTgHeaders = () => ({
  'Content-Type': 'application/json',
  'Accept': 'application/json',
  'X-TG-Data': window.Telegram?.WebApp?.initData || ""
});
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Стили для того, чтобы приложение выглядело как родное в Telegram */
body {
  margin: 0;
  padding: 0;
  background-color: var(--tg-theme-bg-color, #f8fafc);
  color: var(--tg-theme-text-color, #0f172a);
  -webkit-tap-highlight-color: transparent;
}
</file>

<file path="frontend/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css' // Теперь этот файл существует и ошибка исчезнет

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="frontend/src/pages/AdminPage.jsx">
import React, { useState, useEffect } from 'react';
import { ChevronLeft } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const AdminPage = ({ onBack }) => {
  const [stats, setStats] = useState(null);
  
  useEffect(() => {
    fetch(`${API_URL}/api/admin/stats`, { 
        headers: getTgHeaders() 
    }).then(r => r.json()).then(setStats).catch(console.error);
  }, []);

  return (
    <div className="p-4 space-y-4 pb-24 animate-in fade-in slide-in-from-right-4">
      <div className="flex items-center gap-4 mb-4">
          <button onClick={onBack} className="p-2 bg-white rounded-full shadow-sm active:scale-95"><ChevronLeft size={24}/></button>
          <h2 className="text-xl font-bold">Панель администратора</h2>
      </div>
      
      <div className="grid grid-cols-2 gap-3">
        <div className="bg-white p-4 rounded-2xl shadow-sm border border-slate-100">
          <p className="text-xs text-slate-400 font-bold uppercase">Пользователей</p>
          <p className="text-3xl font-black text-indigo-600 mt-1">{stats?.total_users || '-'}</p>
        </div>
        <div className="bg-white p-4 rounded-2xl shadow-sm border border-slate-100">
          <p className="text-xs text-slate-400 font-bold uppercase">Товаров в базе</p>
          <p className="text-3xl font-black text-green-600 mt-1">{stats?.total_items_monitored || '-'}</p>
        </div>
        <div className="col-span-2 bg-emerald-50 p-4 rounded-2xl border border-emerald-100 flex items-center justify-between">
           <span className="text-emerald-800 font-bold text-sm">Статус сервера</span>
           <span className="bg-emerald-200 text-emerald-800 text-xs font-bold px-2 py-1 rounded-md">{stats?.server_status || 'Checking...'}</span>
        </div>
      </div>
    </div>
  );
};

export default AdminPage;
</file>

<file path="frontend/src/pages/AIAnalysisPage.jsx">
import React, { useState } from 'react';
import { Sparkles, Clock, Loader2, Star, ThumbsDown, BarChart3, Users, BrainCircuit, ShieldCheck, Heart, FileDown, Lock, Settings2, Search, RotateCcw } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';
import HistoryModule from '../components/HistoryModule';

const AIAnalysisPage = ({ user }) => {
    const [sku, setSku] = useState('');
    const [step, setStep] = useState('input'); // input | config | analyzing | result
    
    // Product Stats
    const [productMeta, setProductMeta] = useState(null);
    const [metaLoading, setMetaLoading] = useState(false);
    
    // Analysis Config
    const [reviewLimit, setReviewLimit] = useState(100);
    const [loading, setLoading] = useState(false);
    const [downloading, setDownloading] = useState(false);
    const [status, setStatus] = useState('');
    const [result, setResult] = useState(null);
    const [historyOpen, setHistoryOpen] = useState(false);

    // СБРОС СОСТОЯНИЯ
    const handleReset = () => {
        setSku('');
        setStep('input');
        setProductMeta(null);
        setResult(null);
        setReviewLimit(100);
        setStatus('');
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    const handleCheckProduct = async () => {
        if (!sku) return;
        setMetaLoading(true);
        try {
            const res = await fetch(`${API_URL}/api/ai/check/${sku}`, { 
                method: 'GET', 
                headers: getTgHeaders() 
            });
            const data = await res.json();
            
            if (res.status !== 200) throw new Error(data.detail || "Ошибка проверки");
            
            setProductMeta(data);
            
            const total = data.total_reviews || 0;
            
            let safeLimit = 100;
            if (total > 0 && total < 100) safeLimit = total;
            if (total === 0) safeLimit = 50; 
            
            setReviewLimit(safeLimit);
            setStep('config');
        } catch (e) {
            alert(e.message);
        } finally {
            setMetaLoading(false);
        }
    };

    const runAnalysis = async () => {
        setLoading(true);
        setStep('analyzing');
        setResult(null);
        
        try {
            const res = await fetch(`${API_URL}/api/ai/analyze/${sku}?limit=${reviewLimit}`, { 
                method: 'POST', 
                headers: getTgHeaders() 
            });
            const data = await res.json();
            const taskId = data.task_id;

            let attempts = 0;
            while(attempts < 120) {
                setStatus(`Парсинг ${reviewLimit} последних отзывов... (${attempts*2}s)`);
                await new Promise(r => setTimeout(r, 2000));
                
                const sRes = await fetch(`${API_URL}/api/ai/result/${taskId}`, { headers: getTgHeaders() });
                const sData = await sRes.json();
                
                if (sData.status === 'SUCCESS') {
                    setResult(sData.data);
                    setStep('result');
                    break;
                }
                if (sData.status === 'FAILURE') throw new Error(sData.error || "Ошибка ИИ");
                if (sData.info) setStatus(sData.info);
                
                attempts++;
            }
        } catch(e) {
            alert(e.message);
            setStep('config');
        } finally {
            setLoading(false);
        }
    };

    const handleDownloadPDF = async () => {
        if (!sku && !result?.sku) return;
        const targetSku = sku || result.sku;
        if (user?.plan === 'free') {
            alert("Скачивание PDF доступно только на тарифе PRO");
            return;
        }
        try {
            const token = window.Telegram?.WebApp?.initData || "";
            const downloadUrl = `${API_URL}/api/report/ai-pdf/${targetSku}?x_tg_data=${encodeURIComponent(token)}`;
            window.open(downloadUrl, '_blank');
        } catch (e) {
            alert("Ошибка скачивания: " + e.message);
        }
    };

    const getScoreColor = (score) => {
        if (score >= 7) return 'bg-emerald-500 text-white';
        if (score >= 4.5) return 'bg-amber-400 text-amber-950';
        return 'bg-red-500 text-white';
    };

    const getTypeIcon = (type) => {
        if (!type) return <Users size={18} />;
        const t = type.toLowerCase();
        if (t.includes('rational')) return <BrainCircuit size={18} className="text-blue-500" />;
        if (t.includes('emotional')) return <Heart size={18} className="text-pink-500" />;
        if (t.includes('skeptic')) return <ShieldCheck size={18} className="text-slate-500" />;
        return <Users size={18} />;
    };

    const getSliderParams = () => {
        if (!productMeta) return { max: 100, min: 10, step: 10 };
        const total = productMeta.total_reviews || 0;
        const max = total > 0 ? total : 200;
        let min = 10;
        if (max < 10) min = 1;
        let step = 10;
        if (max > 1000) step = 50;
        if (max < 50) step = 1;
        return { max, min, step };
    };

    const sParams = getSliderParams();

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in slide-in-from-bottom-4">
            {/* HEADER */}
            <div className="flex justify-between items-stretch h-20">
                <div className="bg-gradient-to-br from-violet-600 to-fuchsia-600 p-4 rounded-3xl text-white shadow-xl shadow-fuchsia-200 flex-1 mr-3 flex flex-col justify-center">
                    <h1 className="text-xl font-black flex items-center gap-2">
                        <Sparkles className="text-yellow-300" size={20} /> AI Стратег
                    </h1>
                    <p className="text-[10px] opacity-80 mt-1">DeepSeek ABSA + Psychographics</p>
                </div>
                
                <div className="flex flex-col gap-2 h-full">
                    <button 
                        onClick={() => setHistoryOpen(true)} 
                        className="bg-white p-3 rounded-2xl shadow-sm text-slate-400 hover:text-indigo-600 transition-colors flex-1 flex items-center justify-center active:scale-95"
                    >
                        <Clock size={20}/>
                    </button>
                    
                    {step !== 'input' && (
                        <button 
                            onClick={handleReset}
                            className="bg-slate-100 p-3 rounded-2xl shadow-sm text-slate-500 hover:text-red-500 transition-colors flex-1 flex items-center justify-center active:scale-95"
                            title="Новый поиск"
                        >
                            <RotateCcw size={20}/>
                        </button>
                    )}
                </div>
            </div>

            <HistoryModule type="ai" isOpen={historyOpen} onClose={() => setHistoryOpen(false)} />

            {/* MAIN INPUT CARD - Скрываем полностью, если есть результат */}
            {step !== 'result' && (
                <div className="bg-white p-4 rounded-3xl shadow-sm border border-slate-100 transition-all">
                    
                    {/* Step 1: Input */}
                    {step === 'input' && (
                        <>
                            <input 
                                type="number" 
                                value={sku} 
                                onChange={e => setSku(e.target.value)} 
                                placeholder="Введите Артикул WB" 
                                className="w-full p-4 bg-slate-50 rounded-xl font-bold mb-4 outline-none focus:ring-2 ring-violet-200 transition-all text-lg"
                                onKeyDown={(e) => e.key === 'Enter' && handleCheckProduct()}
                            />
                            <button 
                                onClick={handleCheckProduct} 
                                disabled={metaLoading}
                                className="w-full bg-slate-900 text-white p-4 rounded-xl font-bold shadow-lg active:scale-95 transition-transform flex justify-center items-center gap-2 text-lg"
                            >
                                {metaLoading ? <Loader2 className="animate-spin" /> : <><Search size={20}/> Найти товар</>}
                            </button>
                        </>
                    )}

                    {/* Step 2: Configuration */}
                    {step === 'config' && productMeta && (
                        <div className="animate-in fade-in zoom-in-95 duration-300">
                            <div className="flex gap-4 mb-6 bg-slate-50 p-3 rounded-2xl">
                                {productMeta.image && <img src={productMeta.image} className="w-16 h-20 object-cover rounded-lg bg-white shadow-sm" alt="product"/>}
                                <div>
                                    <h3 className="font-bold text-sm leading-tight mb-1 line-clamp-2">{productMeta.name}</h3>
                                    {productMeta.total_reviews > 0 && (
                                        <div className="text-xs text-slate-500 font-medium bg-white px-2 py-1 rounded-md inline-block shadow-sm">
                                            Доступно: <span className="text-violet-600 font-black">{productMeta.total_reviews}</span> отзывов
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="mb-6 px-2">
                                <div className="flex justify-between items-center mb-4">
                                    <label className="text-xs font-bold text-slate-400 uppercase flex items-center gap-1">
                                        <Settings2 size={12}/> Глубина анализа
                                    </label>
                                    <span className="text-xs font-black text-white bg-violet-600 px-3 py-1 rounded-full shadow-md shadow-violet-200">
                                        {reviewLimit} шт.
                                    </span>
                                </div>
                                
                                <input 
                                    type="range" 
                                    min={sParams.min}
                                    max={sParams.max}
                                    step={sParams.step}
                                    value={reviewLimit} 
                                    onChange={(e) => setReviewLimit(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-200 rounded-lg cursor-pointer accent-violet-600"
                                />
                                <div className="flex justify-between text-[10px] text-slate-400 mt-2 font-bold px-1">
                                    <span>{sParams.min}</span>
                                    <span>{sParams.max} (Max)</span>
                                </div>
                            </div>

                            <div className="flex gap-2">
                                <button 
                                    onClick={() => setStep('input')}
                                    className="flex-1 bg-slate-100 text-slate-500 p-4 rounded-xl font-bold active:scale-95 transition-transform"
                                >
                                    Назад
                                </button>
                                <button 
                                    onClick={runAnalysis} 
                                    className="flex-[2] bg-violet-600 text-white p-4 rounded-xl font-bold shadow-lg shadow-violet-200 active:scale-95 transition-transform flex justify-center items-center gap-2"
                                >
                                    <Sparkles size={18}/> Анализ
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Loading State */}
                    {step === 'analyzing' && (
                        <div className="py-8 text-center animate-pulse">
                            <Loader2 size={48} className="animate-spin text-violet-600 mx-auto mb-4" />
                            <p className="text-slate-500 font-medium text-sm">{status}</p>
                        </div>
                    )}
                </div>
            )}

            {/* Step 3: Result */}
            {step === 'result' && result && (
                <div className="space-y-4 animate-in fade-in slide-in-from-bottom-8">
                    
                    {/* Кнопки действий над результатом */}
                    <div className="flex justify-between items-center bg-slate-50 p-2 rounded-2xl">
                         <button onClick={() => setStep('config')} className="text-xs font-bold text-slate-400 hover:text-violet-600 px-3 py-2">
                            ← Настройки
                         </button>
                        <button 
                            onClick={handleDownloadPDF} 
                            disabled={downloading}
                            className={`
                                flex items-center gap-2 px-4 py-2 rounded-xl text-xs font-bold transition-all active:scale-95
                                ${user?.plan === 'free' ? 'bg-white text-slate-400 border border-slate-200' : 'bg-slate-900 text-white shadow-lg'}
                            `}
                        >
                            {downloading ? <Loader2 size={14} className="animate-spin"/> : (user?.plan === 'free' ? <Lock size={14}/> : <FileDown size={14}/>)}
                            {user?.plan === 'free' ? 'PDF (PRO)' : 'Скачать PDF'}
                        </button>
                    </div>

                    <div className="flex gap-4 items-center bg-white p-4 rounded-2xl shadow-sm border border-slate-100">
                        {result.image && <img src={result.image} className="w-16 h-20 object-cover rounded-lg bg-slate-100" alt="product" />}
                        <div>
                            <div className="flex items-center gap-1 text-amber-500 font-black mb-1 text-lg">
                                <Star size={18} fill="currentColor" /> {result.rating}
                            </div>
                            <p className="text-xs text-slate-400 font-bold uppercase tracking-wider">Датасет</p>
                            <p className="font-bold">{result.reviews_count} отзывов</p>
                        </div>
                    </div>

                    {result.ai_analysis.global_summary && (
                        <div className="bg-slate-800 text-slate-200 p-5 rounded-2xl text-sm italic border-l-4 border-violet-500 shadow-md">
                            "{result.ai_analysis.global_summary}"
                        </div>
                    )}

                    {result.ai_analysis.audience_stats && (
                        <div className="bg-white p-6 rounded-3xl border border-slate-100 shadow-sm">
                            <h3 className="font-bold text-lg mb-4 flex items-center gap-2 text-slate-800">
                                <Users className="text-violet-600" size={20}/> Портрет аудитории
                            </h3>
                            <div className="grid grid-cols-3 gap-2 mb-6">
                                <div className="bg-blue-50 p-3 rounded-2xl text-center border border-blue-100">
                                    <BrainCircuit className="mx-auto text-blue-500 mb-1" size={20}/>
                                    <div className="text-xl font-black text-blue-700">{result.ai_analysis.audience_stats.rational_percent}%</div>
                                    <div className="text-[10px] uppercase font-bold text-blue-400">Рационал</div>
                                </div>
                                <div className="bg-pink-50 p-3 rounded-2xl text-center border border-pink-100">
                                    <Heart className="mx-auto text-pink-500 mb-1" size={20}/>
                                    <div className="text-xl font-black text-pink-700">{result.ai_analysis.audience_stats.emotional_percent}%</div>
                                    <div className="text-[10px] uppercase font-bold text-pink-400">Эмоционал</div>
                                </div>
                                <div className="bg-slate-50 p-3 rounded-2xl text-center border border-slate-200">
                                    <ShieldCheck className="mx-auto text-slate-500 mb-1" size={20}/>
                                    <div className="text-xl font-black text-slate-700">{result.ai_analysis.audience_stats.skeptic_percent}%</div>
                                    <div className="text-[10px] uppercase font-bold text-slate-400">Скептик</div>
                                </div>
                            </div>
                            
                            {result.ai_analysis.infographic_recommendation && (
                                <div className="bg-violet-50 border border-violet-100 p-4 rounded-2xl flex gap-3 items-start">
                                    <div className="bg-white p-2 rounded-xl shadow-sm shrink-0">
                                        {getTypeIcon(result.ai_analysis.dominant_type)}
                                    </div>
                                    <div>
                                        <div className="text-xs font-bold text-violet-400 uppercase mb-1">Совет для инфографики</div>
                                        <div className="text-sm font-medium text-violet-900 leading-snug">
                                            {result.ai_analysis.infographic_recommendation}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {result.ai_analysis.aspects && result.ai_analysis.aspects.length > 0 && (
                        <div className="bg-white p-6 rounded-3xl border border-slate-100 shadow-sm">
                            <h3 className="font-bold text-lg mb-4 flex items-center gap-2 text-slate-800">
                                <BarChart3 className="text-violet-600" size={20}/> Аспектный анализ
                            </h3>
                            <div className="space-y-6">
                                {result.ai_analysis.aspects.map((aspect, idx) => (
                                    <div key={idx} className="relative">
                                        <div className="flex justify-between items-center mb-1">
                                            <span className="font-bold text-sm text-slate-700">{aspect.aspect}</span>
                                            <span className={`text-[10px] font-black px-2 py-0.5 rounded-md ${getScoreColor(aspect.sentiment_score)}`}>
                                                {aspect.sentiment_score}/9.0
                                            </span>
                                        </div>
                                        <div className="h-2 w-full bg-slate-100 rounded-full mb-2 overflow-hidden">
                                            <div 
                                                className={`h-full rounded-full transition-all duration-1000 ${getScoreColor(aspect.sentiment_score).split(' ')[0]}`} 
                                                style={{width: `${(aspect.sentiment_score / 9) * 100}%`}}
                                            ></div>
                                        </div>
                                        {aspect.actionable_advice && (
                                            <div className="flex gap-2 items-start text-xs text-slate-500 bg-slate-50 p-2 rounded-lg">
                                                <div className="min-w-[4px] h-4 bg-amber-400 rounded-full mt-0.5"></div>
                                                <span className="font-medium">{aspect.actionable_advice}</span>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                     <div className="grid grid-cols-1 gap-4">
                        <div className="bg-red-50 p-5 rounded-3xl border border-red-100">
                            <h3 className="text-red-600 font-black text-sm flex items-center gap-2 mb-3 uppercase tracking-wider">
                                <ThumbsDown size={16} /> Критические зоны
                            </h3>
                            <ul className="space-y-2">
                                {result.ai_analysis.flaws?.map((f, i) => (
                                    <li key={i} className="bg-white p-2.5 rounded-xl text-xs font-medium text-slate-700 shadow-sm border border-red-50">
                                        {f}
                                    </li>
                                ))}
                            </ul>
                        </div>

                        <div className="bg-emerald-50 p-5 rounded-3xl border border-emerald-100">
                            <h3 className="text-emerald-600 font-black text-sm flex items-center gap-2 mb-3 uppercase tracking-wider">
                                <Sparkles size={16} /> Точки роста
                            </h3>
                            <ul className="space-y-2">
                                {result.ai_analysis.strategy?.map((s, i) => (
                                    <li key={i} className="bg-white p-2.5 rounded-xl text-xs font-medium text-slate-700 shadow-sm border-l-4 border-emerald-400">
                                        {s}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    </div>

                    <button 
                        onClick={handleReset}
                        className="w-full bg-slate-100 text-slate-500 p-4 rounded-2xl font-bold active:scale-95 transition-all hover:bg-slate-200 hover:text-slate-700 flex items-center justify-center gap-2"
                    >
                        <RotateCcw size={18}/> Проверить другой товар
                    </button>

                </div>
            )}
        </div>
    );
};

export default AIAnalysisPage;
</file>

<file path="frontend/src/pages/BidderPage.jsx">
import React, { useState, useEffect } from 'react';
import { 
    Target, ShieldCheck, Zap, Activity, TrendingDown, Loader2, AlertCircle, RefreshCw
} from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const BidderPage = () => {
    const [campaigns, setCampaigns] = useState([]);
    const [dashboard, setDashboard] = useState(null);
    const [logs, setLogs] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchData = async () => {
        setLoading(true);
        setError(null);
        try {
            const [campRes, dashRes, logsRes] = await Promise.all([
                fetch(`${API_URL}/api/bidder/campaigns`, { headers: getTgHeaders() }),
                fetch(`${API_URL}/api/bidder/dashboard`, { headers: getTgHeaders() }),
                fetch(`${API_URL}/api/bidder/logs`, { headers: getTgHeaders() })
            ]);

            // Если API возвращает пустые массивы (fail-safe), мы не падаем
            const cData = campRes.ok ? await campRes.json() : [];
            const dData = dashRes.ok ? await dashRes.json() : {};
            const lData = logsRes.ok ? await logsRes.json() : [];

            setCampaigns(cData);
            setDashboard(dData);
            setLogs(lData);
            
            // Если все ответы упали, тогда ставим ошибку
            if (!campRes.ok && !dashRes.ok) {
                 throw new Error("Сервис временно недоступен");
            }
        } catch (e) {
            console.error(e);
            setError("Не удалось подключиться к WB Advert API. Проверьте соединение.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchData();
        const interval = setInterval(fetchData, 10000);
        return () => clearInterval(interval);
    }, []);

    const CampaignCard = ({ camp }) => (
        <div className="bg-slate-900 text-white p-5 rounded-3xl relative overflow-hidden mb-3 shadow-lg shadow-slate-300">
            <div className="absolute top-0 right-0 w-32 h-32 bg-indigo-600/20 rounded-full blur-3xl -mr-10 -mt-10"></div>
            
            <div className="flex justify-between items-start mb-4 relative z-10">
                <div>
                    <div className="flex items-center gap-2 mb-1">
                        <span className={`w-2 h-2 rounded-full ${camp.status === 9 ? 'bg-emerald-400 shadow-[0_0_10px_#34d399]' : 'bg-amber-400'}`}></span>
                        <h4 className="font-bold text-sm text-slate-200 uppercase tracking-wider">{camp.name}</h4>
                    </div>
                    <div className="text-[10px] text-slate-500 font-mono">ID: {camp.id}</div>
                </div>
                <div className="bg-white/10 px-2 py-1 rounded-lg backdrop-blur-md">
                    <span className="text-xs font-bold text-indigo-300">{camp.status === 9 ? 'Active' : 'Paused'}</span>
                </div>
            </div>

            <div className="grid grid-cols-2 gap-4 mb-4 relative z-10">
                <div>
                    <div className="text-[10px] text-slate-400 uppercase">Тип</div>
                    <div className="text-sm font-black">{camp.type === 6 ? 'Поиск' : camp.type === 8 ? 'Авто' : 'Другое'}</div>
                </div>
                <div className="text-right">
                    <div className="text-[10px] text-slate-400 uppercase">Изменено</div>
                    <div className="text-sm font-bold text-slate-300">{new Date(camp.changeTime).toLocaleDateString()}</div>
                </div>
            </div>
        </div>
    );

    if (loading && campaigns.length === 0) {
        return <div className="flex justify-center items-center h-[80vh]"><Loader2 className="animate-spin text-indigo-600" /></div>;
    }

    if (error) {
        return (
            <div className="p-6 text-center animate-in fade-in h-[80vh] flex flex-col justify-center items-center">
                <AlertCircle className="mx-auto text-red-500 mb-2" size={32}/>
                <h3 className="font-bold text-slate-800">Ошибка соединения</h3>
                <p className="text-sm text-slate-500 mt-2 mb-4">{error}</p>
                <button onClick={fetchData} className="bg-slate-900 text-white px-4 py-2 rounded-xl text-sm font-bold flex items-center gap-2">
                    <RefreshCw size={14} /> Повторить
                </button>
            </div>
        )
    }

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in">
             <div className="bg-gradient-to-r from-violet-600 to-indigo-600 p-6 rounded-[32px] text-white shadow-xl shadow-indigo-200 relative overflow-hidden">
                <div className="relative z-10">
                    <h1 className="text-2xl font-black flex items-center gap-2">
                        <Zap className="text-yellow-300" fill="currentColor" /> Биддер
                    </h1>
                    <p className="text-sm opacity-90 mt-2 font-medium">Управление ставками</p>
                    
                    <div className="mt-6 flex items-center gap-4">
                        <div className="bg-white/10 backdrop-blur-md rounded-2xl p-3 flex-1">
                            <div className="text-[10px] opacity-70 uppercase font-bold">Экономия 24ч</div>
                            <div className="text-xl font-black flex items-center gap-1">
                                {dashboard?.total_budget_saved || 0} ₽ 
                                <TrendingDown size={14} className="text-emerald-300"/>
                            </div>
                        </div>
                        <div className="bg-white/10 backdrop-blur-md rounded-2xl p-3 flex-1">
                            <div className="text-[10px] opacity-70 uppercase font-bold">Активных</div>
                            <div className="text-xl font-black">{dashboard?.campaigns_active || 0}</div>
                        </div>
                    </div>
                </div>
            </div>

            <div className="flex items-center justify-between px-2">
                <h3 className="font-bold text-lg text-slate-800">Мои кампании</h3>
                <span className="text-xs font-bold text-slate-400 bg-slate-100 px-2 py-1 rounded-lg">{campaigns.length} шт</span>
            </div>

            <div className="space-y-3">
                {campaigns.length === 0 ? (
                    <div className="text-center p-8 text-slate-400 bg-white rounded-3xl border border-dashed border-slate-200">
                        {error ? "Ошибка загрузки" : "Нет активных кампаний"}
                    </div>
                ) : (
                    campaigns.map(camp => <CampaignCard key={camp.id} camp={camp} />)
                )}
            </div>

            {logs.length > 0 && (
                <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                    <h3 className="font-bold text-sm text-slate-400 uppercase tracking-wider mb-4">Лог активности</h3>
                    <div className="space-y-4 relative before:absolute before:left-[11px] before:top-2 before:bottom-2 before:w-[2px] before:bg-slate-100">
                        {logs.map((l, i) => (
                            <div key={i} className="flex gap-4 relative">
                                <div className="w-6 h-6 rounded-full bg-slate-50 border-2 border-white shadow-sm z-10 flex items-center justify-center text-[8px] font-black text-slate-400 shrink-0">
                                    {l.time}
                                </div>
                                <div>
                                    <div className="text-[10px] font-bold text-slate-400 mb-0.5">{l.full_date}</div>
                                    <div className="text-xs font-medium text-slate-700 leading-relaxed bg-slate-50 p-2 rounded-lg border border-slate-100">
                                        {l.msg}
                                        {l.saved > 0 && <span className="block text-emerald-600 font-bold mt-1">Сэкономлено: {l.saved} ₽</span>}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    )
}

export default BidderPage;
</file>

<file path="frontend/src/pages/DashboardPage.jsx">
import React, { useState, useEffect } from 'react';
import { Sparkles, Loader2, PieChart, Truck, Target, TrendingUp, Plus, Wand2 } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';
import StoriesBar from '../components/StoriesBar';

const DashboardPage = ({ onNavigate, user }) => {
    const [stats, setStats] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (user?.has_wb_token) {
            setLoading(true);
            fetch(`${API_URL}/api/internal/stats`, {
                headers: getTgHeaders()
            })
            .then(r => r.json())
            .then(data => {
                setStats(data);
                setLoading(false);
            })
            .catch(() => setLoading(false));
        }
    }, [user]);

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in duration-500">
            <StoriesBar />

            <div className="bg-gradient-to-br from-indigo-600 to-violet-700 rounded-[32px] p-6 text-white shadow-xl shadow-indigo-200 relative overflow-hidden">
                <div className="relative z-10">
                    <div className="flex justify-between items-start mb-4">
                        <div className="flex items-center gap-2 opacity-80">
                            <Sparkles size={16} className="text-amber-300" />
                            <span className="text-xs font-bold uppercase tracking-widest">Мои Продажи</span>
                        </div>
                        {!user?.has_wb_token && (
                            <button onClick={() => onNavigate('profile')} className="bg-white/20 hover:bg-white/30 px-3 py-1 rounded-full text-xs font-bold transition-colors">
                                Подключить
                            </button>
                        )}
                    </div>

                    {!user?.has_wb_token ? (
                        <div className="text-center py-4">
                            <p className="font-bold text-lg mb-2">Подключите API</p>
                            <p className="text-xs opacity-70">Чтобы видеть реальные продажи</p>
                        </div>
                    ) : loading ? (
                        <div className="flex justify-center py-6"><Loader2 className="animate-spin" /></div>
                    ) : (
                        <div className="grid grid-cols-2 gap-4">
                            <div className="bg-white/10 p-3 rounded-2xl backdrop-blur-sm">
                                <p className="text-xs opacity-70 mb-1">Заказы сегодня</p>
                                <p className="text-2xl font-black">{stats?.orders_today?.sum?.toLocaleString() || 0} ₽</p>
                                <p className="text-xs opacity-70">{stats?.orders_today?.count || 0} шт</p>
                            </div>
                            <div className="bg-white/10 p-3 rounded-2xl backdrop-blur-sm">
                                <p className="text-xs opacity-70 mb-1">Остатки</p>
                                <p className="text-2xl font-black">{stats?.stocks?.total_quantity?.toLocaleString() || 0} шт</p>
                            </div>
                        </div>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
                 <div onClick={() => onNavigate('finance')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer col-span-2">
                    <div className="bg-emerald-100 w-12 h-12 rounded-2xl flex items-center justify-center text-emerald-600">
                        <PieChart size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">Unit-экономика</span>
                        <span className="text-xs text-slate-400">P&L, Маржа, ROI</span>
                    </div>
                </div>
                <div onClick={() => onNavigate('supply')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer">
                    <div className="bg-orange-100 w-12 h-12 rounded-2xl flex items-center justify-center text-orange-600">
                        <Truck size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">Поставки</span>
                        <span className="text-xs text-slate-400">Прогноз склада</span>
                    </div>
                </div>
                <div onClick={() => onNavigate('bidder')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer">
                    <div className="bg-purple-100 w-12 h-12 rounded-2xl flex items-center justify-center text-purple-600">
                        <Target size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">Биддер</span>
                        <span className="text-xs text-slate-400">Управление рекламой</span>
                    </div>
                </div>
                 <div onClick={() => onNavigate('seo_tracker')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer">
                    <div className="bg-blue-100 w-12 h-12 rounded-2xl flex items-center justify-center text-blue-600">
                        <TrendingUp size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">SEO Трекер</span>
                        <span className="text-xs text-slate-400">Позиции (SERP)</span>
                    </div>
                </div>
                 <div onClick={() => onNavigate('scanner')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer">
                    <div className="bg-slate-100 w-12 h-12 rounded-2xl flex items-center justify-center text-slate-600">
                        <Plus size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">Сканер</span>
                        <span className="text-xs text-slate-400">Добавить</span>
                    </div>
                </div>
                 <div onClick={() => onNavigate('seo')} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm flex flex-col gap-3 active:scale-[0.98] transition-all cursor-pointer">
                    <div className="bg-yellow-100 w-12 h-12 rounded-2xl flex items-center justify-center text-yellow-600">
                        <Wand2 size={24} />
                    </div>
                    <div>
                        <span className="font-bold text-slate-800 block">SEO Gen</span>
                        <span className="text-xs text-slate-400">Генератор</span>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default DashboardPage;
</file>

<file path="frontend/src/pages/FinancePage.jsx">
import React, { useState, useEffect, useMemo } from 'react';
import { 
    Loader2, Calculator, DollarSign, Info 
} from 'lucide-react';
import { 
    BarChart, Bar, Tooltip, ResponsiveContainer, 
    Cell, ReferenceLine 
} from 'recharts';
import { API_URL, getTgHeaders } from '../config';
import CostEditModal from '../components/CostEditModal';

const FinancePage = () => {
    const [products, setProducts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [editingCost, setEditingCost] = useState(null);
    const [viewMode, setViewMode] = useState('unit'); // 'unit' | 'pnl'

    const fetchProducts = async () => {
        setLoading(true);
        try {
            const res = await fetch(`${API_URL}/api/internal/products`, {
                headers: getTgHeaders()
            });
            if (res.ok) {
                const data = await res.json();
                setProducts(data);
            }
        } catch(e) { 
            console.error(e); 
        } finally { 
            setLoading(false); 
        }
    };

    useEffect(() => { fetchProducts(); }, []);

    const handleUpdateCost = async (sku, cost) => {
        try {
            await fetch(`${API_URL}/api/internal/cost/${sku}`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ cost_price: Number(cost) })
            });
            setEditingCost(null);
            fetchProducts();
        } catch(e) { alert("Ошибка обновления"); }
    };

    const pnlStats = useMemo(() => {
        let grossSales = 0;
        let cogs = 0;
        let logistics = 0; 
        let commission = 0; 
        
        products.forEach(p => {
            const velocity = p.supply?.metrics?.avg_daily_demand || 0;
            const monthlySales = velocity * 30;
            
            if (monthlySales > 0) {
                grossSales += p.price * monthlySales;
                cogs += p.cost_price * monthlySales;
                const expenses = p.price - p.unit_economy.profit - p.cost_price;
                const logCost = 50 * monthlySales;
                logistics += logCost;
                commission += (expenses * monthlySales) - logCost;
            }
        });

        if (grossSales === 0 && cogs === 0) return [];

        const netSales = grossSales;
        const cm1 = netSales - cogs;
        const cm2 = cm1 - logistics - commission;
        const marketing = cm2 * 0.1; 
        const ebitda = cm2 - marketing;

        return [
            { name: 'Выручка', value: Math.round(grossSales), type: 'income' },
            { name: 'Себестоимость', value: -Math.round(cogs), type: 'expense' },
            { name: 'Комиссия', value: -Math.round(commission), type: 'expense' },
            { name: 'Логистика', value: -Math.round(logistics), type: 'expense' },
            { name: 'Маркетинг', value: -Math.round(marketing), type: 'expense' },
            { name: 'EBITDA', value: Math.round(ebitda), type: 'total' }
        ];
    }, [products]);

    const MetricCard = ({ title, value, subvalue, color }) => (
        <div className="bg-white p-4 rounded-2xl border border-slate-100 shadow-sm flex flex-col justify-between">
            <span className="text-[10px] text-slate-400 font-bold uppercase tracking-wider">{title}</span>
            <div className={`text-xl font-black ${color}`}>{value}</div>
            {subvalue && <div className="text-[10px] text-slate-400 mt-1">{subvalue}</div>}
        </div>
    );

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in slide-in-from-bottom-4">
             <div className="flex justify-between items-center">
                <div>
                    <h2 className="text-2xl font-black text-slate-800 flex items-center gap-2">
                        <DollarSign className="text-emerald-500" fill="currentColor" /> 
                        Финансы
                    </h2>
                    <p className="text-xs text-slate-400">P&L и Unit-экономика</p>
                </div>
                <div className="flex bg-white rounded-xl p-1 shadow-sm border border-slate-100">
                    <button 
                        onClick={() => setViewMode('unit')}
                        className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-all ${viewMode === 'unit' ? 'bg-slate-900 text-white' : 'text-slate-400'}`}
                    >
                        Unit
                    </button>
                    <button 
                        onClick={() => setViewMode('pnl')}
                        className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-all ${viewMode === 'pnl' ? 'bg-slate-900 text-white' : 'text-slate-400'}`}
                    >
                        P&L
                    </button>
                </div>
            </div>

            {editingCost && (
                <CostEditModal 
                    item={editingCost} 
                    onClose={() => setEditingCost(null)} 
                    onSave={handleUpdateCost} 
                />
            )}

            {loading ? (
                <div className="flex justify-center p-20"><Loader2 className="animate-spin text-emerald-600" size={32}/></div>
            ) : viewMode === 'pnl' ? (
                <div className="space-y-4 animate-in slide-in-from-right-8">
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <h3 className="font-bold text-lg mb-4">Проекция (по текущей скорости)</h3>
                        {pnlStats.length > 0 ? (
                            <>
                                <div className="h-64 w-full">
                                    <ResponsiveContainer width="100%" height="100%">
                                        <BarChart data={pnlStats}>
                                            <Tooltip 
                                                cursor={{fill: '#f1f5f9'}}
                                                contentStyle={{borderRadius: '12px', border: 'none', boxShadow: '0 10px 30px -5px rgba(0,0,0,0.1)'}}
                                            />
                                            <ReferenceLine y={0} stroke="#cbd5e1" />
                                            <Bar dataKey="value" radius={[4, 4, 4, 4]}>
                                                {pnlStats.map((entry, index) => (
                                                    <Cell key={`cell-${index}`} fill={entry.value > 0 ? (entry.type === 'total' ? '#10b981' : '#3b82f6') : '#ef4444'} />
                                                ))}
                                            </Bar>
                                        </BarChart>
                                    </ResponsiveContainer>
                                </div>
                                <div className="grid grid-cols-2 gap-2 mt-4">
                                    {pnlStats.map((s, i) => (
                                        <div key={i} className="flex justify-between text-sm border-b border-slate-50 last:border-0 py-2">
                                            <span className="text-slate-500">{s.name}</span>
                                            <span className={`font-bold ${s.value > 0 ? 'text-slate-800' : 'text-red-500'}`}>
                                                {s.value.toLocaleString()} ₽
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <div className="text-center text-slate-400 py-10">
                                Нет данных о продажах для прогноза P&L.
                            </div>
                        )}
                    </div>

                    <div className="bg-blue-50 p-4 rounded-2xl border border-blue-100 flex gap-3 items-start">
                        <Info className="text-blue-600 min-w-[20px]" size={20}/>
                        <p className="text-xs text-blue-800 leading-relaxed">
                            <strong>Отказ от ответственности:</strong> Расчеты строятся на основе текущих остатков и загруженных данных. Для точного отчета используйте раздел "Отчеты".
                        </p>
                    </div>
                </div>
            ) : (
                <div className="space-y-4 animate-in slide-in-from-left-8">
                    {/* Unit Economics List */}
                    <div className="grid grid-cols-2 gap-3">
                        <MetricCard title="Товаров в анализе" value={products.length} color="text-slate-800" />
                        <MetricCard 
                            title="Средний ROI" 
                            value={`${Math.round(products.reduce((acc, p) => acc + (p.unit_economy?.roi || 0), 0) / (products.length || 1))}%`} 
                            color="text-emerald-600" 
                        />
                    </div>

                    <div className="space-y-3">
                        {products.map((item) => (
                            <div key={item.sku} className="bg-white p-5 rounded-3xl border border-slate-100 shadow-sm relative group">
                                <div className="flex justify-between items-start mb-4">
                                    <div className="min-w-0">
                                        <div className="text-[10px] text-slate-400 font-bold uppercase tracking-wider mb-1">SKU {item.sku}</div>
                                        <div className="font-bold text-lg leading-tight">{item.price} ₽</div>
                                    </div>
                                    <button onClick={() => setEditingCost(item)} className="p-3 bg-slate-50 text-slate-500 rounded-2xl hover:bg-indigo-50 hover:text-indigo-600 transition-colors">
                                        <Calculator size={20} />
                                    </button>
                                </div>
                                
                                <div className="space-y-2 mb-4 relative">
                                    <div className="absolute left-[3px] top-2 bottom-2 w-0.5 bg-slate-100 rounded-full"></div>
                                    
                                    <div className="flex justify-between items-center text-sm pl-4 relative">
                                        <div className="w-2 h-2 bg-slate-300 rounded-full absolute -left-[4px]"></div>
                                        <span className="text-slate-500">Цена продажи</span>
                                        <span className="font-bold">{item.price} ₽</span>
                                    </div>
                                    <div className="flex justify-between items-center text-sm pl-4 relative">
                                        <div className="w-2 h-2 bg-red-300 rounded-full absolute -left-[4px]"></div>
                                        <span className="text-slate-400">Комиссия и Логистика</span>
                                        <span className="text-red-400">-{Math.round(item.price - item.unit_economy.profit - item.cost_price)} ₽</span>
                                    </div>
                                    <div className="flex justify-between items-center text-sm pl-4 relative">
                                        <div className="w-2 h-2 bg-orange-300 rounded-full absolute -left-[4px]"></div>
                                        <span className="text-slate-400">Себестоимость</span>
                                        <span className="text-orange-400">-{item.cost_price} ₽</span>
                                    </div>
                                    <div className="flex justify-between items-center text-base pl-4 relative pt-1 border-t border-slate-50">
                                        <div className={`w-2 h-2 rounded-full absolute -left-[4px] ${item.unit_economy.profit > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></div>
                                        <span className="font-bold text-slate-800">Чистая прибыль (CM2)</span>
                                        <span className={`font-black ${item.unit_economy.profit > 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                            {item.unit_economy.profit} ₽
                                        </span>
                                    </div>
                                </div>

                                <div className="flex gap-2">
                                    <span className={`flex-1 text-center py-2 rounded-xl text-xs font-bold ${item.unit_economy.roi > 100 ? 'bg-emerald-100 text-emerald-700' : item.unit_economy.roi > 30 ? 'bg-blue-100 text-blue-700' : 'bg-red-50 text-red-600'}`}>
                                        ROI: {item.unit_economy.roi}%
                                    </span>
                                    <span className="flex-1 text-center py-2 rounded-xl text-xs font-bold bg-slate-50 text-slate-600">
                                        Маржа: {item.unit_economy.margin}%
                                    </span>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
}

export default FinancePage;
</file>

<file path="frontend/src/pages/MonitorPage.jsx">
import React, { useState, useEffect } from 'react';
import { Clock, RefreshCw, X, FileDown, Loader2, BarChart3, Trash2 } from 'lucide-react';
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid } from 'recharts';
import { API_URL, getTgHeaders } from '../config';
import HistoryModule from '../components/HistoryModule';

const MonitorPage = () => {
  const [list, setList] = useState([]);
  const [historyOpen, setHistoryOpen] = useState(false);
  const [historyData, setHistoryData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [downloading, setDownloading] = useState(false);

  const fetchList = async () => {
      try {
        const res = await fetch(`${API_URL}/api/monitor/list`, {
            headers: getTgHeaders()
        });
        if (res.ok) setList(await res.json());
      } catch(e) { console.error(e); } finally { setLoading(false); }
  };

  useEffect(() => { fetchList(); }, []);

  const handleDelete = async (e, sku) => {
    e.stopPropagation();
    if(!confirm("Удалить товар из списка?")) return;
    await fetch(`${API_URL}/api/monitor/delete/${sku}`, { 
        method: 'DELETE',
        headers: getTgHeaders()
    });
    fetchList();
  };

  const loadHistory = async (sku) => {
    setHistoryData(null);
    try {
        const res = await fetch(`${API_URL}/api/monitor/history/${sku}`, {
            headers: getTgHeaders()
        });
        if(res.ok) setHistoryData(await res.json());
    } catch(e) { console.error(e); }
  };

  const downloadReport = async (sku) => {
      setDownloading(true);
      try {
          const token = window.Telegram?.WebApp?.initData || "";
          const response = await fetch(`${API_URL}/api/report/pdf/${sku}`, {
              headers: { 'X-TG-Data': token }
          });

          if (response.status === 403) {
              alert("Эта функция доступна только в тарифе PRO или Business");
              setDownloading(false);
              return;
          }

          if (!response.ok) throw new Error("Ошибка загрузки");

          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `report_${sku}.pdf`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);
      } catch (e) {
          alert("Не удалось скачать отчет");
      } finally {
          setDownloading(false);
      }
  };

  return (
    <div className="p-4 space-y-4 pb-32 animate-in fade-in slide-in-from-bottom-4">
      <div className="flex justify-between items-center px-2">
        <div>
             <h2 className="text-xl font-bold text-slate-800">Конкуренты</h2>
             <p className="text-xs text-slate-400">Мониторинг цен (Внешний)</p>
        </div>
        <div className="flex gap-2">
            <button onClick={() => setHistoryOpen(true)} className="p-2 bg-indigo-50 text-indigo-600 rounded-full shadow-sm active:scale-95"><Clock size={18}/></button>
            <button onClick={fetchList} className="p-2 bg-white rounded-full shadow-sm text-slate-400 active:rotate-180 transition-all"><RefreshCw size={18}/></button>
        </div>
      </div>
      <HistoryModule type="price" isOpen={historyOpen} onClose={() => setHistoryOpen(false)} />
      
      {historyData && (
        <div className="fixed inset-0 z-[60] bg-black/50 backdrop-blur-sm flex items-center justify-center p-4">
            <div className="bg-white w-full max-w-lg rounded-[32px] p-6 shadow-2xl relative">
                <button onClick={() => setHistoryData(null)} className="absolute top-4 right-4 p-2 bg-slate-100 rounded-full text-slate-500"><X size={20} /></button>
                <div className="mb-6">
                    <span className="text-[10px] font-black uppercase text-indigo-500 bg-indigo-50 px-2 py-1 rounded-lg">{historyData.sku}</span>
                    <h3 className="font-bold text-xl leading-tight mt-2 line-clamp-2">{historyData.name}</h3>
                </div>
                
                <div className="flex gap-2 mb-4">
                    <button 
                        onClick={() => downloadReport(historyData.sku)} 
                        disabled={downloading}
                        className="flex-1 bg-slate-900 text-white py-3 rounded-xl text-xs font-bold flex items-center justify-center gap-2 active:scale-95 transition-transform disabled:opacity-70"
                    >
                        {downloading ? <Loader2 size={16} className="animate-spin" /> : <><FileDown size={16} /> Скачать PDF</>}
                    </button>
                </div>

                <div className="h-64 w-full">
                    <ResponsiveContainer width="100%" height="100%">
                    <AreaChart data={historyData.history}>
                        <defs>
                        <linearGradient id="colorWallet" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#4f46e5" stopOpacity={0.3}/>
                            <stop offset="95%" stopColor="#4f46e5" stopOpacity={0}/>
                        </linearGradient>
                        </defs>
                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f1f5f9" />
                        <XAxis dataKey="date" tick={{fontSize: 10}} tickLine={false} axisLine={false} />
                        <YAxis hide domain={['auto', 'auto']} />
                        <Tooltip 
                            contentStyle={{borderRadius: '16px', border: 'none', boxShadow: '0 10px 30px -5px rgba(0,0,0,0.1)'}} 
                            itemStyle={{color: '#4f46e5', fontWeight: 800}}
                        />
                        <Area type="monotone" dataKey="wallet" stroke="#4f46e5" strokeWidth={3} fill="url(#colorWallet)" />
                    </AreaChart>
                    </ResponsiveContainer>
                </div>
                <p className="text-center text-xs text-slate-400 mt-4">Динамика цены WB Кошелек</p>
            </div>
        </div>
      )}

      <div className="space-y-3">
        {loading ? (
            <div className="flex justify-center p-10"><Loader2 className="animate-spin text-indigo-600"/></div>
        ) : list.length === 0 ? (
          <div className="text-center p-10 text-slate-400 bg-white rounded-3xl border border-dashed border-slate-200">
              Список пуст. Добавьте товары через сканер.
          </div>
        ) : (
          list.map((item) => (
            <div key={item.id} onClick={() => loadHistory(item.sku)} className="bg-white p-4 rounded-2xl flex items-center gap-4 border border-slate-100 shadow-sm relative group active:scale-[0.98] transition-transform cursor-pointer">
              <div className="bg-indigo-50 w-12 h-12 flex items-center justify-center rounded-xl text-indigo-600">
                  <BarChart3 size={20} />
              </div>
              <div className="flex-1 min-w-0">
                  <div className="font-bold truncate text-sm">{item.name || `SKU ${item.sku}`}</div>
                  <div className="text-[10px] text-slate-400 font-black uppercase tracking-wider">{item.brand || 'WB'}</div>
              </div>
              <div className="text-right">
                  <div className="font-black text-indigo-600">{item.prices[0]?.wallet_price} ₽</div>
                  <button onClick={(e) => handleDelete(e, item.sku)} className="text-red-300 hover:text-red-500 p-1"><Trash2 size={16}/></button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

export default MonitorPage;
</file>

<file path="frontend/src/pages/ProfilePage.jsx">
import React, { useState, useEffect } from 'react';
import { User, Key, X, Loader2, Shield, ArrowUpRight, CreditCard, AlertTriangle, CheckCircle2, XCircle } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const ProfilePage = ({ onNavigate }) => {
    const [tariffs, setTariffs] = useState([]);
    const [user, setUser] = useState(null);
    const [wbToken, setWbToken] = useState('');
    const [tokenLoading, setTokenLoading] = useState(false);
    const [payLoading, setPayLoading] = useState(false);
    const [error, setError] = useState(null);
    const [scopes, setScopes] = useState(null);
    const [scopesLoading, setScopesLoading] = useState(false);

    useEffect(() => {
        // Загрузка тарифов
        fetch(`${API_URL}/api/user/tariffs`, { headers: getTgHeaders() })
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data)) setTariffs(data);
            })
            .catch(e => console.error("Tariffs error:", e));

        // Загрузка профиля
        fetch(`${API_URL}/api/user/me`, { headers: getTgHeaders() })
            .then(async r => {
                if (!r.ok) {
                    const text = await r.text();
                    try {
                        const json = JSON.parse(text);
                        throw new Error(json.detail || `Статус ${r.status}`);
                    } catch {
                        throw new Error(`Ошибка сервера: ${r.status}`);
                    }
                }
                return r.json();
            })
            .then(data => {
                setUser(data);
                if (data && data.has_wb_token) {
                    setWbToken(data.wb_token_preview || '');
                    fetchScopes();
                }
            })
            .catch(e => {
                console.error("Profile fetch failed:", e);
                setError(`${e.message}`);
            });
    }, []);

    const fetchScopes = () => {
        setScopesLoading(true);
        fetch(`${API_URL}/api/user/token/scopes`, { headers: getTgHeaders() })
            .then(r => r.json())
            .then(setScopes)
            .catch(console.error)
            .finally(() => setScopesLoading(false));
    };

    const payStars = async (plan) => {
        if (!plan.stars) return;
        try {
            const res = await fetch(`${API_URL}/api/payment/stars_link`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ plan_id: plan.id, amount: plan.stars })
            });
            const d = await res.json();
            if (d.invoice_link && window.Telegram?.WebApp?.openInvoice) {
                window.Telegram.WebApp.openInvoice(d.invoice_link, (status) => {
                    if (status === 'paid') {
                        alert("Оплата прошла успешно!");
                        window.location.reload();
                    }
                });
            } else {
                alert("Ошибка создания ссылки или нет Telegram WebApp");
            }
        } catch (e) {
            alert(e.message);
        }
    };

    const payRubles = async (plan) => {
        if (!plan.price || plan.price === "0 ₽") return;
        setPayLoading(true);
        try {
            const res = await fetch(`${API_URL}/api/payment/yookassa/create`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ plan_id: plan.id })
            });
            const data = await res.json();
            if (res.ok && data.payment_url) {
                if (window.Telegram?.WebApp?.openLink) {
                    window.Telegram.WebApp.openLink(data.payment_url);
                } else {
                    window.open(data.payment_url, '_blank');
                }
            } else {
                throw new Error(data.detail || "Ошибка платежного провайдера");
            }
        } catch (e) {
            alert(`Ошибка: ${e.message}`);
        } finally {
            setPayLoading(false);
        }
    };

    const saveToken = async () => {
        // Блокируем сохранение маскированного токена
        if (!wbToken || wbToken.includes("*****")) return;
        
        setTokenLoading(true);
        try {
            const res = await fetch(`${API_URL}/api/user/token`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ token: wbToken })
            });
            
            if (res.ok) {
                alert("Токен успешно сохранен!");
                const uRes = await fetch(`${API_URL}/api/user/me`, { headers: getTgHeaders() });
                if (uRes.ok) {
                    const uData = await uRes.json();
                    setUser(uData);
                    fetchScopes(); // Обновляем права
                }
            } else {
                const d = await res.json();
                throw new Error(d.detail || "Ошибка сохранения");
            }
        } catch (e) {
            alert(e.message);
        } finally {
            setTokenLoading(false);
        }
    };

    const deleteToken = async () => {
        if (!confirm("Удалить токен?")) return;
        setTokenLoading(true);
        try {
            await fetch(`${API_URL}/api/user/token`, { method: 'DELETE', headers: getTgHeaders() });
            setWbToken('');
            setScopes(null);
            setUser(prev => ({ ...prev, has_wb_token: false }));
        } catch (e) {
            console.error(e);
        } finally {
            setTokenLoading(false);
        }
    };

    const ScopeBadge = ({ label, active, loading }) => (
        <div className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg border text-xs font-bold transition-all ${active ? 'bg-emerald-50 border-emerald-200 text-emerald-700' : 'bg-slate-50 border-slate-200 text-slate-400 opacity-60'}`}>
            {loading ? <Loader2 size={12} className="animate-spin" /> : active ? <CheckCircle2 size={14} /> : <XCircle size={14} />}
            {label}
        </div>
    );

    const RenderTariffCard = ({ plan }) => (
        <div className={`p-5 rounded-2xl border-2 transition-all ${plan.current ? 'border-emerald-500 bg-emerald-50/50' : 'border-slate-100 bg-white'}`}>
            <div className="flex justify-between items-start mb-3">
                <div>
                    <h3 className="font-bold text-lg flex items-center gap-2">
                        {plan.name}
                        {plan.current && <span className="bg-emerald-500 text-white text-[10px] px-2 py-0.5 rounded-full">CURRENT</span>}
                    </h3>
                    <div className="text-2xl font-black mt-1">{plan.price} <span className="text-sm font-normal text-slate-400">/ мес</span></div>
                </div>
                {plan.stars > 0 && (
                    <div className="text-right">
                        <div className="text-amber-500 font-bold text-sm flex items-center justify-end gap-1">
                            ★ {plan.stars}
                        </div>
                    </div>
                )}
            </div>

            <ul className="space-y-2 mb-4">
                {plan.features.map((f, i) => (
                    <li key={i} className="text-sm text-slate-600 flex items-center gap-2">
                        <div className={`w-1.5 h-1.5 rounded-full ${plan.current ? 'bg-emerald-500' : 'bg-slate-300'}`} />
                        {f}
                    </li>
                ))}
            </ul>

            {!plan.current && plan.price !== "0 ₽" && (
                <div className="grid grid-cols-2 gap-2 mt-4">
                    <button onClick={() => payStars(plan)} className="flex items-center justify-center gap-2 py-2.5 bg-amber-400 text-white rounded-xl font-bold text-sm hover:bg-amber-500 transition-colors">
                        <span>Stars</span>
                    </button>
                    <button onClick={() => payRubles(plan)} disabled={payLoading} className="flex items-center justify-center gap-2 py-2.5 bg-slate-900 text-white rounded-xl font-bold text-sm hover:bg-slate-800 transition-colors">
                        {payLoading ? <Loader2 className="animate-spin" size={16} /> : <CreditCard size={16} />}
                        <span>РФ Карта</span>
                    </button>
                </div>
            )}
        </div>
    );

    // Логика состояния кнопки: 
    // Дизейблим если идет загрузка ИЛИ (если токен уже есть и поле содержит маску '*****')
    // Это предотвращает отправку маскированного токена, но разрешает отправку, если пользователь начал вводить новый
    const isSaveDisabled = tokenLoading || (user?.has_wb_token && wbToken.includes('*****')) || !wbToken;

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in slide-in-from-bottom-4">
            {error && (
                <div className="bg-red-50 p-4 rounded-2xl border border-red-100 flex flex-col gap-2">
                    <div className="flex items-start gap-3">
                        <AlertTriangle className="text-red-500 shrink-0" size={20} />
                        <div>
                            <h3 className="font-bold text-red-800 text-sm">Ошибка загрузки</h3>
                            <p className="text-xs text-red-600 mt-1">{error}</p>
                        </div>
                    </div>
                </div>
            )}

            <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100 flex items-center gap-4">
                <div className="w-16 h-16 rounded-full bg-slate-100 flex items-center justify-center text-slate-400">
                    <User size={32} />
                </div>
                <div>
                    <h2 className="text-xl font-bold">{user?.name || 'Загрузка...'}</h2>
                    <p className="text-sm text-slate-400">@{user?.username || '...'}</p>
                    <div className="mt-2 flex flex-wrap gap-2">
                        <div className="inline-flex items-center gap-1 bg-black text-white px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider">
                            {user?.plan || 'Free'} Plan
                        </div>
                        {user?.days_left > 0 && (
                            <div className="inline-flex items-center gap-1 bg-emerald-100 text-emerald-800 px-2 py-0.5 rounded text-[10px] font-bold">
                                {user.days_left} дн.
                            </div>
                        )}
                    </div>
                </div>
            </div>

            <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                <div className="flex items-center gap-2 mb-4">
                    <Key className="text-indigo-600" size={20} />
                    <h2 className="font-bold text-lg">API Ключ WB</h2>
                </div>

                <div className="relative">
                    <input
                        type="text"
                        value={wbToken}
                        onChange={(e) => setWbToken(e.target.value)}
                        onFocus={(e) => { if (user?.has_wb_token) e.target.select() }} // Удобство для выделения старого токена
                        placeholder="Введите токен..."
                        className="w-full bg-slate-50 border border-slate-100 rounded-xl p-3 pr-10 text-sm font-medium outline-none focus:ring-2 ring-indigo-100 transition-all"
                    />
                    {user?.has_wb_token && (
                        <button onClick={deleteToken} className="absolute right-2 top-2 p-1 text-slate-300 hover:text-red-500 transition-colors">
                            <X size={16} />
                        </button>
                    )}
                </div>

                {/* SCOPES DISPLAY */}
                {(user?.has_wb_token || scopes) && (
                    <div className="mt-4">
                        <div className="text-[10px] uppercase font-bold text-slate-400 mb-2">Доступные разделы API</div>
                        <div className="flex flex-wrap gap-2">
                            <ScopeBadge label="Статистика" active={scopes?.statistics} loading={scopesLoading} />
                            <ScopeBadge label="Контент/Цены" active={scopes?.standard} loading={scopesLoading} />
                            <ScopeBadge label="Реклама" active={scopes?.promotion} loading={scopesLoading} />
                            <ScopeBadge label="Вопросы" active={scopes?.questions} loading={scopesLoading} />
                        </div>
                    </div>
                )}

                {/* Кнопка сохранения теперь видна всегда, но блокируется если токен не изменен */}
                <button
                    onClick={saveToken}
                    disabled={isSaveDisabled}
                    className={`w-full mt-4 py-3 rounded-xl font-bold text-sm transition-all flex justify-center items-center gap-2
                        ${isSaveDisabled
                            ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                            : 'bg-indigo-600 text-white shadow-lg shadow-indigo-200 active:scale-95 hover:bg-indigo-700'
                        }`}
                >
                    {tokenLoading ? <Loader2 className="animate-spin" size={18} /> : (user?.has_wb_token ? 'Обновить токен' : 'Сохранить токен')}
                </button>
            </div>

            <h2 className="font-bold text-lg px-2 mt-4">Тарифы</h2>
            <div className="space-y-4">
                {tariffs.map(plan => (
                    <RenderTariffCard key={plan.id} plan={plan} />
                ))}
            </div>

            {user?.is_admin && (
                <button onClick={() => onNavigate('admin')} className="w-full bg-slate-900 text-white p-4 rounded-2xl shadow-lg flex items-center justify-between active:scale-95 transition-transform mt-4">
                    <div className="flex items-center gap-3">
                        <Shield size={20} className="text-emerald-400" />
                        <span className="font-bold text-sm">Админ-панель</span>
                    </div>
                    <ArrowUpRight size={18} />
                </button>
            )}

            <div className="mt-8 pt-8 border-t border-slate-100 text-center space-y-2">
                <div className="flex justify-center gap-4 text-xs text-slate-400">
                    <a href="#" className="hover:text-slate-600 transition-colors">Публичная оферта</a>
                    <span>•</span>
                    <a href="#" className="hover:text-slate-600 transition-colors">Политика конфиденциальности</a>
                </div>
                <p className="text-[10px] text-slate-300">
                    Сервис не является аффилированным лицом Wildberries.<br />
                    Обработка персональных данных в соответствии с 152-ФЗ.
                </p>
            </div>
        </div>
    );
};

export default ProfilePage;
</file>

<file path="frontend/src/pages/ScannerPage.jsx">
import React, { useState } from 'react';
import { Search, Loader2 } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const ScannerPage = ({ onNavigate }) => {
  const [sku, setSku] = useState('');
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState('');

  const handleScan = async () => {
    if (!sku) return;
    setLoading(true);
    setStatus('Запуск задачи...');

    try {
      const res = await fetch(`${API_URL}/api/monitor/add/${sku}`, { 
        method: 'POST',
        headers: getTgHeaders()
      });
      
      if (res.status === 403) {
          alert("Лимит тарифа исчерпан! Обновите подписку.");
          setLoading(false);
          return;
      }
      
      const data = await res.json();
      const taskId = data.task_id;

      let attempts = 0;
      while (attempts < 60) {
        await new Promise(r => setTimeout(r, 2000));
        
        const statusRes = await fetch(`${API_URL}/api/monitor/status/${taskId}`);
        const statusData = await statusRes.json();
        
        if (statusData.info && statusData.info !== status) {
            setStatus(statusData.info);
        }

        if (statusData.status === 'SUCCESS') {
           onNavigate('monitor');
           return;
        }
        if (statusData.status === 'FAILURE') throw new Error(statusData.error);
        attempts++;
      }
      throw new Error("Таймаут ожидания");
    } catch (e) {
      alert(`Ошибка: ${e.message}`);
      setLoading(false);
    }
  };

  return (
    <div className="p-4 flex flex-col h-[80vh] justify-center animate-in zoom-in-95 duration-300">
      <div className="bg-white p-8 rounded-[40px] shadow-2xl shadow-indigo-100 border border-slate-100">
        <div className="text-center mb-6">
            <div className="w-16 h-16 bg-indigo-50 text-indigo-600 rounded-full flex items-center justify-center mx-auto mb-4">
                <Search size={32} />
            </div>
            <h2 className="text-2xl font-black text-slate-800">Добавить товар</h2>
        </div>

        <div className="relative mb-4">
          <input
            type="number"
            placeholder="Артикул (SKU)"
            className="w-full bg-slate-50 border-none rounded-2xl p-5 pl-4 text-center text-2xl font-black outline-none transition-all placeholder:text-slate-300 text-slate-800"
            value={sku}
            onChange={(e) => setSku(e.target.value)}
          />
        </div>
        <button
          onClick={handleScan}
          disabled={loading}
          className="w-full bg-black text-white p-5 rounded-2xl font-bold text-lg flex items-center justify-center gap-3 active:scale-95 transition-all shadow-xl disabled:opacity-70 min-h-[64px]"
        >
          {loading ? (
             <span className="flex items-center gap-2 animate-in fade-in">
                 <Loader2 className="animate-spin" /> 
                 <span className="min-w-[100px] text-left">{status}</span>
             </span>
          ) : 'Начать отслеживание'}
        </button>
      </div>
    </div>
  );
};

export default ScannerPage;
</file>

<file path="frontend/src/pages/SeoGeneratorPage.jsx">
import React, { useState } from 'react';
import { Wand2, Clock, Loader2, Sparkles, Copy, X, BrainCircuit, Layers, Table, HelpCircle, FileText, Download } from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';
import HistoryModule from '../components/HistoryModule';

const SeoGeneratorPage = () => {
    const [step, setStep] = useState(1);
    const [sku, setSku] = useState('');
    const [loading, setLoading] = useState(false);
    const [status, setStatus] = useState('');
    
    // Keywords State
    const [keywords, setKeywords] = useState([]);
    const [newKeyword, setNewKeyword] = useState('');
    const [clusters, setClusters] = useState(null); // { topic: string, keywords: [] }[]
    
    // Config State
    const [tone, setTone] = useState('Продающий');
    const [titleLen, setTitleLen] = useState(100);
    const [descLen, setDescLen] = useState(1000);
    
    // Result State
    const [result, setResult] = useState(null);
    const [error, setError] = useState('');
    const [historyOpen, setHistoryOpen] = useState(false);
    const [pdfLoading, setPdfLoading] = useState(false);

    const toneOptions = ["Продающий", "Информативный", "Дерзкий", "Формальный", "Дружелюбный"];

    const fetchKeywords = async () => {
        if (!sku) return;
        setLoading(true); setError('');
        try {
            const res = await fetch(`${API_URL}/api/seo/parse/${sku}`, { headers: getTgHeaders() });
            const data = await res.json();
            if (res.status !== 200) throw new Error(data.detail || data.message);
            setKeywords(data.keywords || []); 
            setClusters(null);
            setStep(2);
        } catch (e) { setError(e.message); } finally { setLoading(false); }
    };

    const handleClusterKeywords = async () => {
        setLoading(true);
        setStatus('Загрузка BERT модели...');
        try {
            const res = await fetch(`${API_URL}/api/seo/cluster`, { 
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ sku: Number(sku), keywords })
            });
            const data = await res.json();
            const taskId = data.task_id;
            
            let attempts = 0;
            while(attempts < 30) {
                await new Promise(r => setTimeout(r, 2000));
                const sRes = await fetch(`${API_URL}/api/monitor/status/${taskId}`);
                const sData = await sRes.json();
                
                if (sData.status === 'SUCCESS') {
                    setClusters(sData.data.clusters);
                    setLoading(false);
                    return;
                }
                if (sData.status === 'FAILURE') throw new Error(sData.error);
                if (sData.info) setStatus(sData.info);
                attempts++;
            }
        } catch (e) {
            setError('Ошибка кластеризации: ' + e.message);
        } finally {
            setLoading(false);
            setStatus('');
        }
    };

    const addKeyword = () => {
        if (newKeyword.trim() && !keywords.includes(newKeyword.trim())) {
            setKeywords([...keywords, newKeyword.trim()]);
            setNewKeyword('');
        }
    };

    const removeKeyword = (k) => {
        setKeywords(keywords.filter(w => w !== k));
    };

    const generateContent = async () => {
        setLoading(true);
        setStatus('Генерация GEO контента...');
        try {
            const res = await fetch(`${API_URL}/api/seo/generate`, { method: 'POST', headers: getTgHeaders(), body: JSON.stringify({ sku: Number(sku), keywords, tone, title_len: titleLen, desc_len: descLen }) });
            const data = await res.json();
            const taskId = data.task_id;
            let attempts = 0;
            while(attempts < 60) {
                await new Promise(r => setTimeout(r, 3000));
                const sRes = await fetch(`${API_URL}/api/ai/result/${taskId}`);
                const sData = await sRes.json();
                if (sData.status === 'SUCCESS') { setResult(sData.data.generated_content); setStep(3); break; }
                if (sData.status === 'FAILURE') throw new Error(sData.error);
                attempts++;
            }
        } catch (e) { setError(e.message); } finally { setLoading(false); setStatus(''); }
    };

    const downloadPdf = async () => {
        if (!result) return;
        setPdfLoading(true);
        try {
            const payload = {
                sku: String(sku),
                title: result.title || "",
                description: result.description || "",
                features: result.structured_features || {},
                faq: result.faq || []
            };

            if (user?.plan === 'free') {
                alert("Скачивание PDF доступно только на тарифе PRO или Business");
                return;
            }

            const response = await fetch(`${API_URL}/api/report/seo-pdf/generate`, {
                method: 'POST',
                headers: {
                    ...getTgHeaders(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error("Ошибка генерации PDF");

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `SEO_Report_${sku}.pdf`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } catch (e) {
            alert("Не удалось скачать PDF: " + e.message);
        } finally {
            setPdfLoading(false);
        }
    };

    const CopyButton = ({ text }) => (
        <button onClick={() => {navigator.clipboard.writeText(text); alert("Скопировано!");}} className="p-2 text-slate-400 hover:text-indigo-600 transition-colors bg-slate-50 rounded-lg">
            <Copy size={16} />
        </button>
    );

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in slide-in-from-bottom-4">
            <div className="flex justify-between items-center">
                <div className="bg-gradient-to-r from-orange-500 to-pink-500 p-6 rounded-3xl text-white shadow-xl shadow-orange-200 flex-1 mr-4">
                    <h1 className="text-2xl font-black flex items-center gap-2"><Wand2 className="text-yellow-200" /> SEO Gen</h1>
                    <p className="text-sm opacity-90 mt-2">GEO-оптимизация 2026</p>
                </div>
                <button onClick={() => setHistoryOpen(true)} className="bg-white p-4 rounded-3xl shadow-sm text-slate-400 hover:text-indigo-600 transition-colors h-full"><Clock size={24}/></button>
            </div>
            
            <HistoryModule type="seo" isOpen={historyOpen} onClose={() => setHistoryOpen(false)} />

            {/* STEP 1: Import */}
            {step === 1 && (
                 <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                    <h3 className="font-bold text-lg mb-4">Шаг 1. Импорт данных</h3>
                    <div className="relative mb-4">
                        <input
                            type="number"
                            placeholder="Артикул WB (SKU)"
                            className="w-full bg-slate-50 border-none rounded-2xl p-4 pl-4 font-bold outline-none focus:ring-2 ring-orange-200 transition-all text-slate-800"
                            value={sku}
                            onChange={(e) => setSku(e.target.value)}
                        />
                    </div>
                    {error && <p className="text-red-500 text-sm mb-4 bg-red-50 p-3 rounded-xl">{error}</p>}
                    <button onClick={fetchKeywords} disabled={loading} className="w-full bg-slate-900 text-white p-4 rounded-xl font-bold active:scale-95 transition-all flex justify-center">
                        {loading ? <Loader2 className="animate-spin" /> : 'Получить ключевые слова'}
                    </button>
                 </div>
            )}

            {/* STEP 2: Clustering & Settings */}
            {step === 2 && (
                <div className="space-y-4 animate-in fade-in">
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100 space-y-4">
                        <div className="flex justify-between items-center">
                            <h3 className="font-bold text-lg">Шаг 2. Семантика</h3>
                            <button 
                                onClick={handleClusterKeywords} 
                                disabled={loading || clusters}
                                className={`text-xs font-bold px-3 py-2 rounded-xl flex items-center gap-2 transition-all ${clusters ? 'bg-emerald-100 text-emerald-700' : 'bg-indigo-600 text-white shadow-lg shadow-indigo-200'}`}
                            >
                                {loading ? <Loader2 size={14} className="animate-spin"/> : <BrainCircuit size={14}/>}
                                {clusters ? 'Сгруппировано' : 'AI Кластеризация'}
                            </button>
                        </div>

                        {status && <div className="text-xs text-indigo-600 font-medium bg-indigo-50 p-2 rounded-lg text-center">{status}</div>}
                        
                        {clusters ? (
                            <div className="space-y-3 max-h-[300px] overflow-y-auto pr-2 custom-scrollbar">
                                {clusters.map((c, i) => (
                                    <div key={i} className="bg-slate-50 p-3 rounded-xl border border-slate-100">
                                        <div className="flex items-center gap-2 mb-2">
                                            <Layers size={14} className="text-indigo-500"/>
                                            <span className="font-bold text-sm capitalize">{c.topic}</span>
                                            <span className="text-[10px] bg-white px-2 rounded-full text-slate-400 border border-slate-200">{c.count}</span>
                                        </div>
                                        <div className="flex flex-wrap gap-1">
                                            {c.keywords.map((k, j) => (
                                                <span key={j} className="text-[10px] bg-white text-slate-600 px-2 py-1 rounded-md border border-slate-200">{k}</span>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="flex flex-wrap gap-2 mb-4 max-h-[200px] overflow-y-auto">
                                {keywords.map((k, i) => (
                                    <div key={i} className="bg-slate-100 text-slate-700 px-3 py-1.5 rounded-xl text-sm font-medium flex items-center gap-2">
                                        {k}
                                        <button onClick={() => removeKeyword(k)} className="text-slate-400 hover:text-red-500"><X size={14} /></button>
                                    </div>
                                ))}
                            </div>
                        )}

                        <div className="flex gap-2 mb-6">
                            <input 
                                value={newKeyword}
                                onChange={e => setNewKeyword(e.target.value)}
                                placeholder="Добавить ключ..."
                                className="flex-1 bg-slate-50 rounded-xl px-4 py-2 text-sm outline-none"
                            />
                            <button onClick={addKeyword} className="bg-slate-900 text-white px-4 rounded-xl font-bold text-xl">+</button>
                        </div>
                        
                        <div className="pt-4 border-t border-slate-100">
                            <div className="mb-4">
                                <label className="text-xs font-bold text-slate-400 uppercase mb-2 block">Размер текста</label>
                                <div className="flex justify-between text-[10px] text-slate-400 mb-1">
                                    <span>Заголовок: {titleLen}</span>
                                    <span>Описание: {descLen}</span>
                                </div>
                                <input type="range" min="40" max="150" value={titleLen} onChange={e=>setTitleLen(Number(e.target.value))} className="w-full accent-indigo-600 mb-2 h-1 bg-slate-100 rounded-lg appearance-none cursor-pointer"/>
                                <input type="range" min="500" max="3000" step="100" value={descLen} onChange={e=>setDescLen(Number(e.target.value))} className="w-full accent-indigo-600 h-1 bg-slate-100 rounded-lg appearance-none cursor-pointer"/>
                            </div>

                            <h3 className="font-bold text-sm mb-3">Tone of Voice</h3>
                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                                {toneOptions.map(t => (
                                    <button 
                                        key={t}
                                        onClick={() => setTone(t)}
                                        className={`px-4 py-2 rounded-xl text-xs font-bold border whitespace-nowrap transition-all ${tone === t ? 'border-orange-500 bg-orange-50 text-orange-600' : 'border-slate-100 bg-white text-slate-500'}`}
                                    >
                                        {t}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {error && <p className="text-red-500 text-sm mb-4">{error}</p>}

                        <div className="flex gap-3 mt-4">
                            <button onClick={() => setStep(1)} className="flex-1 bg-slate-100 text-slate-600 p-4 rounded-xl font-bold">Назад</button>
                            <button onClick={generateContent} disabled={loading} className="flex-[2] bg-gradient-to-r from-orange-500 to-pink-500 text-white p-4 rounded-xl font-bold shadow-lg shadow-orange-200 active:scale-95 transition-all flex justify-center gap-2 items-center">
                                {loading ? <Loader2 className="animate-spin" /> : <><Sparkles size={18} /> Создать GEO</>}
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* STEP 3: Result (GEO Content) */}
            {step === 3 && result && (
                <div className="space-y-4 animate-in fade-in">
                    
                    <button 
                        onClick={downloadPdf} 
                        disabled={pdfLoading}
                        className="w-full bg-slate-800 text-white p-3 rounded-xl font-bold flex items-center justify-center gap-2 active:scale-95 transition-all shadow-lg"
                    >
                        {pdfLoading ? <Loader2 size={16} className="animate-spin"/> : <Download size={16}/>}
                        Скачать PDF отчет
                    </button>

                    {/* Header */}
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <div className="flex justify-between items-center mb-2">
                            <h3 className="font-bold text-slate-400 text-xs uppercase">Заголовок</h3>
                            <CopyButton text={result.title} />
                        </div>
                        <textarea 
                            className="w-full bg-slate-50 p-3 rounded-xl text-sm font-bold text-slate-800 outline-none focus:ring-2 ring-indigo-100 min-h-[60px]"
                            value={result.title}
                            onChange={(e) => setResult({...result, title: e.target.value})}
                        />
                    </div>

                    {/* Features Table */}
                    {result.structured_features && Object.keys(result.structured_features).length > 0 && (
                        <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                             <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-slate-700 text-sm flex items-center gap-2">
                                    <Table size={16} className="text-indigo-500"/> Характеристики
                                </h3>
                                <CopyButton text={Object.entries(result.structured_features).map(([k,v]) => `${k}: ${v}`).join('\n')} />
                            </div>
                            <div className="border border-slate-100 rounded-xl overflow-hidden text-sm">
                                {Object.entries(result.structured_features).map(([k, v], i) => (
                                    <div key={i} className="flex border-b border-slate-100 last:border-0">
                                        <div className="w-1/3 bg-slate-50 p-2 font-medium text-slate-500 border-r border-slate-100">{k}</div>
                                        <div className="w-2/3 p-2 text-slate-800">{v}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Description */}
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <div className="flex justify-between items-center mb-2">
                            <h3 className="font-bold text-slate-400 text-xs uppercase">Описание</h3>
                            <CopyButton text={result.description} />
                        </div>
                        <textarea 
                            className="w-full bg-slate-50 p-3 rounded-xl text-sm text-slate-700 outline-none focus:ring-2 ring-indigo-100 min-h-[300px] leading-relaxed"
                            value={result.description}
                            onChange={(e) => setResult({...result, description: e.target.value})}
                        />
                    </div>

                    {/* FAQ */}
                    {result.faq && result.faq.length > 0 && (
                         <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-slate-700 text-sm flex items-center gap-2">
                                    <HelpCircle size={16} className="text-orange-500"/> Часто задаваемые вопросы
                                </h3>
                                <CopyButton text={result.faq.map(f => `Q: ${f.question}\nA: ${f.answer}`).join('\n\n')} />
                            </div>
                            <div className="space-y-3">
                                {result.faq.map((item, i) => (
                                    <div key={i} className="bg-slate-50 p-3 rounded-xl">
                                        <div className="font-bold text-xs text-slate-700 mb-1">❓ {item.question}</div>
                                        <div className="text-xs text-slate-500 leading-relaxed">{item.answer}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    <button onClick={() => setStep(1)} className="w-full bg-slate-900 text-white p-4 rounded-xl font-bold">Новый поиск</button>
                </div>
            )}
        </div>
    );
};

export default SeoGeneratorPage;
</file>

<file path="frontend/src/pages/SeoTrackerPage.jsx">
import React, { useState, useEffect } from 'react';
import { 
    TrendingUp, Loader2, MapPin, Zap, Search, 
    CheckCircle2, AlertCircle, ArrowRight 
} from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const REGIONS = [
    { id: 'moscow', name: 'Москва' },
    { id: 'spb', name: 'СПб' },
    { id: 'kazan', name: 'Казань' },
    { id: 'krasnodar', name: 'Краснодар' },
    { id: 'novosibirsk', name: 'Новосибирск' },
];

const SeoTrackerPage = () => {
    const [positions, setPositions] = useState([]);
    const [sku, setSku] = useState('');
    const [keyword, setKeyword] = useState('');
    const [selectedRegions, setSelectedRegions] = useState(['moscow']);
    const [loading, setLoading] = useState(false);
    const [liveResult, setLiveResult] = useState(null);
    const [statusText, setStatusText] = useState('');

    const loadPositions = () => {
        fetch(`${API_URL}/api/seo/positions`, {
             headers: getTgHeaders()
        }).then(r => r.json()).then(setPositions).catch(console.error);
    }

    useEffect(() => { loadPositions(); }, []);

    const toggleRegion = (regId) => {
        if (selectedRegions.includes(regId)) {
            // Не даем убрать последний регион
            if (selectedRegions.length > 1) {
                setSelectedRegions(selectedRegions.filter(r => r !== regId));
            }
        } else {
            setSelectedRegions([...selectedRegions, regId]);
        }
    };

    const handleTrack = async () => {
        if(!sku || !keyword) return;
        setLoading(true);
        setLiveResult(null);
        setStatusText('Запуск проверки...');

        try {
             // 1. Запускаем задачу
             const res = await fetch(`${API_URL}/api/seo/track`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({
                    sku: Number(sku), 
                    keyword,
                    regions: selectedRegions
                })
             });
             
             if (!res.ok) throw new Error("Ошибка запуска");
             const data = await res.json();
             const taskId = data.task_id;

             // 2. Поллинг результата (Geo Tracking может занять время)
             let attempts = 0;
             while (attempts < 30) {
                 await new Promise(r => setTimeout(r, 2000));
                 
                 const statusRes = await fetch(`${API_URL}/api/monitor/status/${taskId}`);
                 const statusData = await statusRes.json();
                 
                 if (statusData.info) setStatusText(statusData.info);

                 if (statusData.status === 'SUCCESS') {
                     setLiveResult(statusData.data);
                     loadPositions(); // Обновляем историю
                     break;
                 }
                 
                 if (statusData.status === 'FAILURE') {
                     throw new Error(statusData.error || "Ошибка парсинга");
                 }
                 
                 attempts++;
             }

        } catch(e) { 
            console.error(e);
            alert("Ошибка: " + e.message); 
        } finally { 
            setLoading(false); 
        }
    }

    // Компонент карточки регионального результата
    const RegionResultCard = ({ regionId, data }) => {
        const regionName = REGIONS.find(r => r.id === regionId)?.name || regionId;
        const isBoosted = data?.is_boosted;
        const organicPos = data?.organic_pos;
        const adPos = data?.ad_pos;

        return (
            <div className="bg-slate-50 p-3 rounded-xl border border-slate-200 flex justify-between items-center mb-2 animate-in fade-in slide-in-from-top-2">
                <div className="flex items-center gap-2">
                    <div className="bg-white p-1.5 rounded-lg shadow-sm text-slate-400">
                        <MapPin size={16}/>
                    </div>
                    <span className="text-sm font-bold text-slate-700">{regionName}</span>
                </div>
                
                <div className="flex items-center gap-3 text-right">
                    {/* Organic Status */}
                    <div className="flex flex-col items-end">
                        <span className="text-[10px] uppercase font-bold text-slate-400">Органика</span>
                        <div className={`text-lg font-black flex items-center gap-1 ${organicPos > 0 ? 'text-emerald-600' : 'text-slate-300'}`}>
                            {organicPos > 0 ? `#${organicPos}` : '—'}
                            {organicPos > 0 && <CheckCircle2 size={14} />}
                        </div>
                    </div>

                    {/* Ad Status (Only if exists) */}
                    {(adPos > 0 || isBoosted) && (
                        <div className="flex flex-col items-end pl-3 border-l border-slate-200">
                            <span className="text-[10px] uppercase font-bold text-purple-400">Реклама</span>
                            <div className="text-lg font-black text-purple-600 flex items-center gap-1">
                                {adPos > 0 ? `#${adPos}` : 'Авто'}
                                <Zap size={14} fill="currentColor"/>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in">
             <div className="bg-gradient-to-r from-blue-600 to-cyan-500 p-6 rounded-[32px] text-white shadow-xl shadow-cyan-200">
                <h1 className="text-2xl font-black flex items-center gap-2">
                    <TrendingUp className="text-white" /> SEO Tracker
                </h1>
                <p className="text-sm opacity-90 mt-2">Мульти-региональный мониторинг позиций (Geo & Ads).</p>
            </div>

            <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                 <div className="space-y-3 mb-4">
                     <input 
                        value={sku} 
                        onChange={e => setSku(e.target.value)} 
                        placeholder="Артикул (SKU)" 
                        type="number"
                        className="w-full bg-slate-50 rounded-xl p-4 text-sm font-bold outline-none focus:ring-2 ring-cyan-100 transition-all"
                     />
                     <input 
                        value={keyword} 
                        onChange={e => setKeyword(e.target.value)} 
                        placeholder="Ключевой запрос" 
                        className="w-full bg-slate-50 rounded-xl p-4 text-sm font-bold outline-none focus:ring-2 ring-cyan-100 transition-all"
                     />
                 </div>

                 {/* Region Selector */}
                 <div className="mb-4">
                    <label className="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-2 block">Регионы проверки</label>
                    <div className="flex flex-wrap gap-2">
                        {REGIONS.map(r => (
                            <button
                                key={r.id}
                                onClick={() => toggleRegion(r.id)}
                                className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-all border ${
                                    selectedRegions.includes(r.id) 
                                    ? 'bg-cyan-50 border-cyan-200 text-cyan-700' 
                                    : 'bg-white border-slate-100 text-slate-400 hover:border-cyan-100'
                                }`}
                            >
                                {r.name}
                            </button>
                        ))}
                    </div>
                 </div>

                 <button 
                    onClick={handleTrack} 
                    disabled={loading || !sku || !keyword} 
                    className="w-full bg-slate-900 text-white py-4 rounded-xl font-bold text-sm shadow-lg active:scale-95 transition-transform disabled:opacity-70 flex justify-center items-center gap-2"
                 >
                     {loading ? (
                         <><Loader2 className="animate-spin" size={18}/> {statusText}</>
                     ) : (
                         <><Search size={18}/> Проверить позиции</>
                     )}
                 </button>
            </div>

            {/* LIVE RESULT BLOCK */}
            {liveResult && (
                <div className="bg-white p-5 rounded-3xl shadow-sm border border-slate-100 animate-in zoom-in-95">
                    <div className="flex items-center gap-2 mb-4 pb-4 border-b border-slate-50">
                        <div className="bg-emerald-100 text-emerald-600 p-2 rounded-xl">
                            <CheckCircle2 size={24}/>
                        </div>
                        <div>
                            <h3 className="font-bold text-slate-800">Результат проверки</h3>
                            <p className="text-xs text-slate-400">{liveResult.keyword} • SKU {liveResult.sku}</p>
                        </div>
                    </div>

                    <div className="space-y-1">
                        {liveResult.geo_details && Object.entries(liveResult.geo_details).map(([regId, data]) => (
                            <RegionResultCard key={regId} regionId={regId} data={data} />
                        ))}
                    </div>
                </div>
            )}

            {/* HISTORY LIST */}
            <div className="space-y-3">
                <h3 className="font-bold text-slate-400 text-xs uppercase px-2">История проверок</h3>
                {positions.length === 0 ? (
                    <div className="text-center p-8 text-slate-300 border border-dashed border-slate-200 rounded-2xl">
                        История пуста
                    </div>
                ) : (
                    positions.map(p => (
                        <div key={p.id} className="bg-white p-4 rounded-2xl shadow-sm border border-slate-100 flex items-center justify-between">
                            <div className="min-w-0 pr-4">
                                <div className="font-bold text-sm truncate">{p.keyword}</div>
                                <div className="text-[10px] text-slate-400">SKU: {p.sku}</div>
                            </div>
                            <div className="text-right whitespace-nowrap">
                                <div className={`font-black text-lg ${p.position > 0 && p.position <= 10 ? 'text-emerald-500' : 'text-slate-700'}`}>
                                    {p.position > 0 ? `#${p.position}` : '>100'}
                                </div>
                                <div className="text-[9px] text-slate-300">{new Date(p.last_check).toLocaleDateString()}</div>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    )
}

export default SeoTrackerPage;
</file>

<file path="frontend/src/pages/SupplyPage.jsx">
import React, { useState, useEffect } from 'react';
import { 
    Truck, Scale, Loader2, MapPin, ArrowRight, 
    PackageCheck, AlertTriangle, Box, RefreshCw,
    Activity
} from 'lucide-react';
import { API_URL, getTgHeaders } from '../config';

const SupplyPage = () => {
    const [coeffs, setCoeffs] = useState([]);
    const [volume, setVolume] = useState(1000);
    const [calculation, setCalculation] = useState(null);
    const [loading, setLoading] = useState(true); // Default to loading
    const [products, setProducts] = useState([]);
    const [error, setError] = useState(null);

    useEffect(() => {
        fetchData();
    }, []);

    const fetchData = async () => {
        setLoading(true);
        setError(null);
        try {
            const [coeffRes, prodRes] = await Promise.all([
                 fetch(`${API_URL}/api/internal/coefficients`, { headers: getTgHeaders() }),
                 fetch(`${API_URL}/api/internal/products`, { headers: getTgHeaders() })
            ]);

            // Обрабатываем ответы даже если один из них упал
            const cData = coeffRes.ok ? await coeffRes.json() : [];
            const pData = prodRes.ok ? await prodRes.json() : [];
            
            setCoeffs(Array.isArray(cData) ? cData : []);
            setProducts(Array.isArray(pData) ? pData : []);

            // Если оба упали - только тогда ошибка
            if (!coeffRes.ok && !prodRes.ok) {
                // throw new Error("Сервисы недоступны");
            }
        } catch (e) {
            console.error(e);
            setError("Не удалось загрузить данные логистики.");
        } finally {
            setLoading(false);
        }
    };

    const handleCalculate = async () => {
        if (!volume) return;
        setLoading(true); 
        try {
            const res = await fetch(`${API_URL}/api/internal/transit_calc`, {
                method: 'POST',
                headers: getTgHeaders(),
                body: JSON.stringify({ volume: Number(volume), destination: "Koledino" })
            });
            if (res.ok) {
                setCalculation(await res.json());
            }
        } catch(e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    };

    const StockHealthCard = ({ item }) => {
        if (!item.supply || item.supply.status === 'unknown') return null;
        const { status, days_left, metrics, recommendation } = item.supply;
        
        let colorClass = 'bg-slate-50 border-slate-100';
        let textClass = 'text-slate-600';
        let icon = <Box size={16}/>;

        if (status === 'critical' || status === 'out_of_stock') {
            colorClass = 'bg-red-50 border-red-100';
            textClass = 'text-red-700';
            icon = <AlertTriangle size={16} className="text-red-500"/>;
        } else if (status === 'warning') {
            colorClass = 'bg-orange-50 border-orange-100';
            textClass = 'text-orange-700';
            icon = <Truck size={16} className="text-orange-500"/>;
        } else {
            colorClass = 'bg-emerald-50 border-emerald-100';
            textClass = 'text-emerald-700';
            icon = <PackageCheck size={16} className="text-emerald-500"/>;
        }

        const fillPercent = metrics.rop > 0 ? Math.min(100, (metrics.current_stock / (metrics.rop * 1.5)) * 100) : 100;

        return (
            <div className="bg-white p-4 rounded-2xl shadow-sm border border-slate-100 mb-3 animate-in fade-in">
                <div className="flex justify-between items-start mb-2">
                    <div>
                        <div className="font-bold text-sm">SKU {item.sku}</div>
                        <div className="text-[10px] text-slate-400">ROP: {metrics.rop} шт | Safety: {metrics.safety_stock} шт</div>
                    </div>
                    <div className={`px-2 py-1 rounded-lg flex items-center gap-1 text-xs font-bold ${colorClass} ${textClass}`}>
                        {icon} {days_left} дн.
                    </div>
                </div>
                
                <div className="h-2 w-full bg-slate-100 rounded-full overflow-hidden mb-2">
                    <div 
                        className={`h-full rounded-full transition-all duration-500 ${status === 'ok' ? 'bg-emerald-500' : status === 'warning' ? 'bg-orange-500' : 'bg-red-500'}`} 
                        style={{ width: `${fillPercent}%` }}
                    ></div>
                </div>
                
                <div className="text-[10px] text-slate-500 font-medium bg-slate-50 p-2 rounded-lg">
                    💡 {recommendation}
                </div>
            </div>
        );
    };

    if (error) {
         return (
            <div className="p-6 text-center animate-in fade-in h-[80vh] flex flex-col items-center justify-center">
                <AlertTriangle className="mx-auto text-amber-500 mb-2" size={32}/>
                <h3 className="font-bold text-slate-800">Нет связи с сервером</h3>
                <p className="text-sm text-slate-500 mt-2 mb-4">{error}</p>
                <button onClick={fetchData} className="bg-slate-900 text-white px-4 py-2 rounded-xl text-sm font-bold flex items-center gap-2">
                    <RefreshCw size={14} /> Повторить
                </button>
            </div>
        )
    }

    if (loading && coeffs.length === 0 && products.length === 0) {
        return <div className="flex justify-center items-center h-[80vh]"><Loader2 className="animate-spin text-indigo-600" /></div>;
    }

    return (
        <div className="p-4 space-y-6 pb-32 animate-in fade-in">
             <div className="bg-gradient-to-r from-orange-500 to-amber-500 p-6 rounded-[32px] text-white shadow-xl shadow-orange-200 relative overflow-hidden">
                <div className="relative z-10">
                    <h1 className="text-2xl font-black flex items-center gap-2">
                        <Truck className="text-white" /> Supply Chain
                    </h1>
                    <p className="text-sm opacity-90 mt-2 font-medium">Умная логистика</p>
                </div>
                <div className="absolute top-0 right-0 w-32 h-32 bg-white/10 rounded-full -mr-10 -mt-10 blur-2xl"></div>
            </div>

            <div className="bg-white p-6 rounded-3xl border border-slate-100 shadow-sm">
                 <h3 className="font-bold text-slate-800 mb-4 flex items-center gap-2">
                     <Scale size={20} className="text-indigo-600"/> 
                     Калькулятор маршрута
                 </h3>
                 
                 <div className="bg-slate-50 p-4 rounded-2xl mb-4 border border-slate-100">
                    <label className="text-[10px] font-bold text-slate-400 uppercase tracking-wider block mb-2">Объем поставки (литры)</label>
                    <div className="flex items-center gap-2">
                        <input 
                            type="number"
                            value={volume}
                            onChange={e => setVolume(e.target.value)}
                            className="flex-1 bg-white p-3 rounded-xl font-black text-xl outline-none text-slate-800 shadow-sm transition-all focus:ring-2 focus:ring-indigo-500/20"
                        />
                        <button 
                            onClick={handleCalculate} 
                            disabled={loading}
                            className="bg-indigo-600 text-white p-3 rounded-xl active:scale-95 transition-transform shadow-lg shadow-indigo-200 disabled:opacity-50"
                        >
                            {loading && calculation === null ? <Loader2 className="animate-spin"/> : <ArrowRight />}
                        </button>
                    </div>
                 </div>

                 {calculation && (
                     <div className="space-y-3 animate-in slide-in-from-top-4">
                         <div className={`p-4 rounded-2xl border-2 transition-all ${!calculation.is_profitable ? 'border-emerald-500 bg-emerald-50' : 'border-slate-100 opacity-60'}`}>
                             <div className="flex justify-between items-center mb-1">
                                 <span className="font-bold text-sm flex items-center gap-1"><MapPin size={14}/> Коледино (Прямая)</span>
                                 <span className="font-black text-lg">{calculation.direct_cost.toLocaleString()} ₽</span>
                             </div>
                             <div className="text-[10px] text-slate-500">1500₽ база + {volume}л × 30₽</div>
                         </div>

                         <div className={`p-4 rounded-2xl border-2 transition-all ${calculation.is_profitable ? 'border-emerald-500 bg-emerald-50' : 'border-slate-100 opacity-60'}`}>
                             <div className="flex justify-between items-center mb-1">
                                 <span className="font-bold text-sm flex items-center gap-1"><Truck size={14}/> Казань (Транзит)</span>
                                 <span className="font-black text-lg">{calculation.transit_cost.toLocaleString()} ₽</span>
                             </div>
                             <div className="text-[10px] text-slate-500">500₽ база + 1000₽ лог. + {volume}л × 10₽</div>
                             {calculation.is_profitable && (
                                 <div className="mt-2 bg-emerald-200 text-emerald-800 text-xs font-bold px-2 py-1 rounded-lg inline-block">
                                     Выгода: {calculation.benefit.toLocaleString()} ₽
                                 </div>
                             )}
                         </div>
                     </div>
                 )}
            </div>

            {coeffs.length > 0 && (
                 <div className="bg-white p-6 rounded-3xl border border-slate-100 shadow-sm">
                    <h3 className="font-bold text-slate-800 mb-2">Коэффициенты складов (Топ-5)</h3>
                    <div className="overflow-x-auto pb-2">
                        <table className="w-full text-left text-xs">
                            <thead>
                                <tr className="text-slate-400 border-b border-slate-50">
                                    <th className="py-2 pl-2">Склад</th>
                                    <th className="py-2 text-center">Короба</th>
                                    <th className="py-2 text-center">Паллеты</th>
                                </tr>
                            </thead>
                            <tbody>
                                {coeffs.slice(0, 5).map((c, i) => (
                                    <tr key={i} className="border-b border-slate-50 last:border-0 hover:bg-slate-50 transition-colors">
                                        <td className="py-3 pl-2 font-bold text-slate-700">{c.warehouseName}</td>
                                        <td className="py-3 text-center">
                                            <span className={`px-2 py-1 rounded-lg font-bold ${c.boxDeliveryBase !== '-' && c.boxDeliveryBase !== '0' ? 'bg-indigo-50 text-indigo-600' : 'text-slate-400'}`}>
                                                {c.boxDeliveryBase !== '-' ? c.boxDeliveryBase : '—'}
                                            </span>
                                        </td>
                                        <td className="py-3 text-center">
                                            <span className={`px-2 py-1 rounded-lg font-bold ${c.palletDeliveryBase !== '-' && c.palletDeliveryBase !== '0' ? 'bg-purple-50 text-purple-600' : 'text-slate-400'}`}>
                                                {c.palletDeliveryBase !== '-' ? c.palletDeliveryBase : '—'}
                                            </span>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                 </div>
            )}
            
            <div className="px-2">
                <h3 className="font-bold text-lg text-slate-800 flex items-center gap-2 mb-4">
                    <Activity size={20} className="text-emerald-500"/>
                    Здоровье склада (ROP)
                </h3>
                {products.length > 0 ? (
                    products
                        .filter(p => p.supply && p.supply.status !== 'unknown')
                        .map(item => <StockHealthCard key={item.sku} item={item} />)
                ) : (
                    <div className="text-center p-8 text-slate-400 bg-white rounded-3xl border border-dashed border-slate-200">
                        Нет данных для прогноза. <br/>
                        <span className="text-xs">Добавьте API ключ и дождитесь накопления статистики (1-2 дня).</span>
                    </div>
                )}
            </div>
        </div>
    )
}

export default SupplyPage;
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
    content: [
      "./index.html",
      "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }
</file>

<file path="frontend/vercel.json">
{
    "version": 2,
    "cleanUrls": true,
    "rewrites": [
      {
        "source": "/(.*)",
        "destination": "/index.html"
      }
    ]
  }
</file>

<file path="package.json">
{
  "dependencies": {
    "recharts": "^3.6.0"
  }
}
</file>

<file path="PROJECT_DESCRIPTION.md">
# Полное описание проекта UB (WB Analytics Platform)

## Цель проекта

**UB (WB Analytics Platform)** — это полнофункциональная платформа для анализа и мониторинга товаров маркетплейса Wildberries, предназначенная для продавцов и маркетологов. Система позволяет отслеживать динамику цен конкурентов в реальном времени, анализировать отзывы покупателей с помощью искусственного интеллекта для выявления проблемных зон товаров и получения стратегических рекомендаций по улучшению продукта, автоматически генерировать SEO-оптимизированные заголовки и описания товаров на основе ключевых слов и характеристик, вести полную историю изменений цен с графической визуализацией и возможностью экспорта отчетов в PDF формате. Платформа работает как Telegram Web App, обеспечивая удобный доступ с мобильных устройств и полную интеграцию с экосистемой Telegram для продавцов на маркетплейсе Wildberries.

---

## Стек технологий

### Языки программирования:
- **Python 3.9+** — основной язык backend (асинхронный и синхронный код)
- **JavaScript (ES6+)** — язык frontend (без TypeScript)
- **SQL** — запросы к базе данных

### Backend фреймворки и библиотеки:

**Веб-фреймворк:**
- **FastAPI** — современный асинхронный веб-фреймворк для создания REST API
- **Uvicorn** — ASGI сервер для запуска FastAPI приложения

**База данных и ORM:**
- **SQLAlchemy** — ORM для работы с базой данных (поддержка async и sync режимов)
- **asyncpg** — асинхронный драйвер PostgreSQL для FastAPI
- **psycopg2-binary** — синхронный драйвер PostgreSQL для Celery задач
- **greenlet** — поддержка синхронного кода в async контексте

**Очередь задач:**
- **Celery** — распределенная очередь задач для фоновой обработки
- **Redis** — брокер сообщений и бэкенд результатов для Celery

**Парсинг и автоматизация:**
- **Selenium** — автоматизация браузера для парсинга динамического контента
- **Microsoft Edge WebDriver** — драйвер для управления браузером Edge
- **aiohttp** — асинхронный HTTP клиент для параллельных запросов к API WB
- **requests** — синхронный HTTP клиент (для AI API и WB API отзывов)

**Валидация и сериализация:**
- **Pydantic** — валидация данных и схемы (встроено в FastAPI)

**Генерация отчетов:**
- **FPDF2** — генерация PDF отчетов с поддержкой Unicode шрифтов

**Утилиты:**
- **python-dotenv** — управление переменными окружения
- **zipfile** — создание расширений браузера для прокси
- **hmac, hashlib** — криптографическая валидация данных Telegram

### Frontend фреймворки и библиотеки:

**UI библиотека:**
- **React 18** — библиотека для создания пользовательского интерфейса
- **React DOM 18** — рендерер React для веб

**Сборщик и инструменты:**
- **Vite 4.3.9** — сборщик и dev-сервер (быстрая альтернатива Create React App)
- **@vitejs/plugin-react** — плагин Vite для поддержки React

**Стилизация:**
- **Tailwind CSS 3.3.2** — utility-first CSS фреймворк для быстрой стилизации
- **PostCSS 8.4.24** — пост-процессор CSS
- **Autoprefixer 10.4.14** — автоматическое добавление вендорных префиксов CSS

**UI компоненты:**
- **Lucide React 0.284.0** — библиотека иконок (более 1000 иконок)
- **Recharts 2.10.3** — библиотека для построения графиков и диаграмм (AreaChart, LineChart, Tooltip)

### Инфраструктура и инструменты:

**Контейнеризация:**
- **Docker** — контейнеризация приложений
- **Docker Compose 3.8** — оркестрация множественных контейнеров

**База данных:**
- **PostgreSQL 15-alpine** — реляционная база данных для хранения пользователей, товаров и истории

**Кеш и брокер:**
- **Redis alpine** — брокер сообщений для Celery, кеширование, бэкенд результатов задач

**Браузер:**
- **Microsoft Edge Browser** — браузер для Selenium WebDriver (устанавливается в Docker контейнер)
- **Microsoft Edge WebDriver** — драйвер для автоматизации Edge (статический бинарник)

**Хостинг:**
- **Vercel** — хостинг и деплой frontend приложения (SPA с rewrites)

### Внешние API и сервисы:

**Платформы:**
- **Telegram Bot API** — аутентификация пользователей через Telegram Web App (HMAC-SHA256 валидация)
- **Telegram Web App SDK** — JavaScript SDK для интеграции с Telegram (подключается через CDN)

**API маркетплейса:**
- **Wildberries Basket API** — внутренний API для получения статических данных товаров (card.json)
- **Wildberries Feedbacks API** — внутренний API для получения отзывов (feedbacks1.wb.ru, feedbacks2.wb.ru, feedbacks-api.wildberries.ru)

**AI сервисы:**
- **AI API (artemox.com)** — внешний сервис для AI-анализа отзывов и генерации SEO-контента (модель: deepseek-chat, температура: 0.5 для анализа, 0.7 для генерации)

---

## Структура проекта

```
UB/
├── backend/                          # Backend сервисы (Python/FastAPI)
│   ├── __pycache__/                 # Кеш скомпилированных Python файлов
│   ├── parser_service.py            # Сервис парсинга Wildberries v13.1 (Selenium + API + SEO)
│   ├── tasks.py                     # Celery задачи (парсинг, анализ, SEO генерация, обновление цен)
│   ├── analysis_service.py          # Сервис расчета метрик, AI-анализа отзывов и генерации SEO-контента
│   ├── main.py                      # FastAPI приложение (все API endpoints, ~306 строк)
│   ├── auth_service.py              # Сервис аутентификации через Telegram Web App
│   ├── database.py                  # Модели SQLAlchemy (async и sync), настройка подключения к БД
│   ├── celery_app.py                # Конфигурация Celery (Redis, задачи, расписание)
│   ├── requirements.txt             # Python зависимости (14 пакетов)
│   ├── Dockerfile                   # Docker образ для backend (Python 3.9, Edge, WebDriver, шрифты)
│   ├── msedgedriver                 # Бинарный файл Edge WebDriver (~31K строк)
│   └── proxy_ext/                   # Временные файлы расширений браузера
│       └── proxy_auth_plugin.zip    # Автогенерируемое расширение для прокси авторизации
│
├── frontend/                        # Frontend приложение (React/Vite)
│   ├── src/
│   │   ├── App.jsx                  # Главный компонент приложения (~977 строк, 7 страниц, навигация)
│   │   ├── main.jsx                 # Точка входа React приложения
│   │   └── index.css                # Глобальные стили (Tailwind, Telegram themes)
│   ├── index.html                   # HTML шаблон (Telegram Web App SDK подключение)
│   ├── package.json                 # NPM зависимости и скрипты (React, Vite, Tailwind, Recharts)
│   ├── tailwind.config.js           # Конфигурация Tailwind CSS (content paths)
│   ├── postcss.config.js            # Конфигурация PostCSS (Tailwind, Autoprefixer)
│   └── vercel.json                  # Конфигурация деплоя на Vercel (SPA routing rewrites)
│
├── docker-compose.yml               # Docker Compose конфигурация (5 сервисов: db, redis, api, worker, beat)
├── package.json                     # Корневые зависимости (recharts)
├── PROJECT_DESCRIPTION.md           # Документация проекта (этот файл)
└── proxy_ext/                       # Дублирующая директория (возможно устаревшая)
```

### Описание основных директорий:

**backend/** — содержит весь backend код на Python:
- **parser_service.py** (348 строк) — гибридный парсер: статические данные через API (brute-force поиск корзин 01-50), динамические цены через Selenium с WebDriverWait, SEO-данные (название, характеристики, ключевые слова) через async API
- **tasks.py** (147 строк) — Celery задачи: `parse_and_save_sku`, `analyze_reviews_task`, `generate_seo_task`, `update_all_monitored_items` (периодическое обновление)
- **main.py** (306 строк) — FastAPI приложение с 18+ endpoints: мониторинг, AI анализ, SEO генерация, история, PDF отчеты, админ-панель
- **database.py** (75 строк) — 4 модели: User, MonitoredItem, PriceHistory, SearchHistory; поддержка async и sync сессий
- **analysis_service.py** (143 строки) — расчет метрик цен, синхронный AI анализ отзывов и генерация SEO-контента через внешний API (метод `_call_ai` для унификации)
- Используется синхронный код в Celery задачах для работы с БД

**frontend/** — содержит весь frontend код на React:
- **App.jsx** (977 строк) — монолитный компонент с 7 страницами: HomePage, ScannerPage, MonitorPage, SeoGeneratorPage, AIAnalysisPage, HistoryPage, ProfilePage
- Нижняя навигация с 7 вкладками (включая новую "SEO")
- Модальные окна для детального просмотра истории и графиков
- Polling статусов задач с обновлением каждые 3-4 секунды
- Интеграция с Telegram Web App API

**proxy_ext/** — временная директория для расширений браузера (автогенерируется при создании прокси расширения)

---

## Текущий статус

### ✅ Что готово и полностью работает:

1. **Гибридный парсинг данных Wildberries (v13.1):**
   - ✅ Статические данные через API: brute-force поиск card.json по корзинам 01-50 (приоритет: расчетная → 18-50 → 1-17)
   - ✅ Асинхронный параллельный поиск корзин батчами по 15 запросов
   - ✅ Получение названия, бренда, изображения, root_id через card.json
   - ✅ Динамические цены через Selenium: 3 попытки парсинга с увеличенными таймаутами
   - ✅ Улучшенное ожидание загрузки: WebDriverWait до 15 секунд + статическое ожидание 15 секунд
   - ✅ Извлечение цен через JSON (window.staticModel) с fallback на DOM селекторы
   - ✅ Парсинг отзывов через 3 зеркала API WB (feedbacks1, feedbacks2, feedbacks-api)
   - ✅ **SEO-данные**: извлечение названия, категории, характеристик (options) через async метод `get_seo_data`
   - ✅ Обход блокировок через прокси с ротацией сессий (уникальный session ID для каждого запроса)
   - ✅ Обработка ошибок и логирование на всех этапах

2. **Система мониторинга цен:**
   - ✅ Добавление товаров в мониторинг с проверкой лимитов тарифов (Free: 3, PRO: 50, Business: 500)
   - ✅ Автоматическое сохранение истории цен в PostgreSQL
   - ✅ Автоматическое обновление всех товаров каждый час через Celery Beat
   - ✅ Отображение списка товаров с последними ценами
   - ✅ История цен с графиками (AreaChart от Recharts)
   - ✅ Удаление товаров из мониторинга с каскадным удалением истории

3. **AI-анализ отзывов:**
   - ✅ Сбор отзывов через API WB (до 30 для Free, до 100 для PRO/Business)
   - ✅ Анализ через внешний AI API (artemox.com, модель deepseek-chat, температура: 0.5)
   - ✅ Выявление 3 главных минусов товара
   - ✅ Генерация 5 стратегических советов для продавца
   - ✅ Очистка текста от Markdown форматирования
   - ✅ Обработка ошибок API и парсинг JSON из ответа AI

4. **SEO-генератор контента:**
   - ✅ Извлечение ключевых слов из карточки товара (название, категория, характеристики)
   - ✅ Редактирование ключевых слов пользователем (добавление, удаление)
   - ✅ Выбор тона текста (Продающий, Информативный, Дерзкий, Формальный, Дружелюбный)
   - ✅ Генерация SEO-заголовка (до 100 символов) и описания (1000-1500 символов) через AI API
   - ✅ Редактирование сгенерированного контента перед копированием
   - ✅ Копирование заголовка и описания в буфер обмена
   - ✅ Сохранение результатов в истории поисков (тип: 'seo')
   - ✅ Асинхронный метод `get_seo_data` в parser_service для извлечения данных
   - ✅ Celery задача `generate_seo_task` для фоновой генерации контента

5. **Пользовательская система:**
   - ✅ Аутентификация через Telegram Web App (HMAC-SHA256 валидация с проверкой подписи)
   - ✅ Многопользовательская архитектура с полной изоляцией данных
   - ✅ Три тарифных плана: Free (3 товара, история 24ч, AI 30 отзывов), PRO (50 товаров, история 30 дней, AI 100 отзывов, PDF), Business (500 товаров, безлимит AI, приоритет, API)
   - ✅ Система супер-администраторов по telegram_id (SUPER_ADMIN_IDS = [901378787])
   - ✅ Режим отладки (DEBUG_MODE) для локальной разработки
   - ✅ Автоматическое создание пользователя при первом входе
   - ✅ Автоматическое обновление прав супер-админа

6. **История поисков и запросов:**
   - ✅ Сохранение всех запросов в SearchHistory (цена, AI анализ, SEO генерация)
   - ✅ Отображение истории в отдельной вкладке (до 50 последних запросов)
   - ✅ Модальное окно с детальным просмотром результата (поддержка типов: price, ai, seo)
   - ✅ Очистка истории пользователя
   - ✅ JSON сериализация результатов для хранения

7. **Frontend интерфейс (7 страниц):**
   - ✅ **HomePage** — главная страница с баннером и быстрыми действиями
   - ✅ **ScannerPage** — добавление товара с polling статуса задачи (2 секунды)
   - ✅ **MonitorPage** — список товаров, график истории цен в модальном окне
   - ✅ **SeoGeneratorPage** — 3-шаговый процесс: импорт ключевых слов по SKU, редактирование ключевых слов и выбор тона, генерация и редактирование контента
   - ✅ **AIAnalysisPage** — запуск AI анализа с polling результата (3 секунды)
   - ✅ **HistoryPage** — история всех запросов с фильтрацией по типу (price/ai/seo)
   - ✅ **ProfilePage** — профиль пользователя, тарифы, админ-панель (для админов)
   - ✅ Нижняя навигация с 7 вкладками: Главная, Цены, История, Сканер (+), SEO, ИИ, Профиль
   - ✅ Адаптивный дизайн для Telegram Web App
   - ✅ Поддержка темного/светлого режима через CSS переменные Telegram

8. **API endpoints (18+ endpoints):**
   - ✅ Пользовательские: `/api/user/me`, `/api/user/tariffs`, `/api/user/history`, `DELETE /api/user/history`
   - ✅ Мониторинг: `POST /api/monitor/add/{sku}`, `GET /api/monitor/list`, `DELETE /api/monitor/delete/{sku}`, `GET /api/monitor/history/{sku}`, `GET /api/monitor/status/{task_id}`
   - ✅ AI: `POST /api/ai/analyze/{sku}`, `GET /api/ai/result/{task_id}`
   - ✅ **SEO**: `GET /api/seo/parse/{sku}` (извлечение ключевых слов), `POST /api/seo/generate` (генерация контента)
   - ✅ Отчеты: `GET /api/report/pdf/{sku}` (только для PRO и Business тарифов)
   - ✅ Платежи: `POST /api/payment/create`
   - ✅ Админ: `GET /api/admin/stats`
   - ✅ Поддержка токена в заголовке (X-TG-Data) и query параметре (x_tg_data) для PDF скачивания

9. **База данных (4 таблицы):**
   - ✅ **users** — пользователи (telegram_id, username, first_name, is_admin, subscription_plan)
   - ✅ **monitored_items** — отслеживаемые товары (user_id, sku, name, brand)
   - ✅ **price_history** — история цен (item_id, wallet_price, standard_price, base_price, recorded_at)
   - ✅ **search_history** — история поисков (user_id, sku, request_type: 'price'/'ai'/'seo', title, result_json)
   - ✅ Асинхронные запросы для FastAPI (AsyncSession с asyncpg)
   - ✅ Синхронные запросы для Celery (SyncSession с psycopg2-binary)
   - ✅ Каскадное удаление связанных записей (cascade="all, delete-orphan")
   - ✅ Индексы на telegram_id и sku для быстрого поиска
   - ✅ Тип sku изменен на BigInteger для безопасности

10. **PDF отчеты:**
    - ✅ Генерация PDF отчетов по истории цен товара
    - ✅ Поддержка Unicode шрифтов (DejaVu) для корректного отображения русского текста
    - ✅ Таблица с датами и ценами (wallet, standard, base)
    - ✅ Доступно только для PRO и Business тарифов
    - ✅ StreamingResponse для отдачи файла
    - ✅ Исправлена обработка bytes/str в FPDF2

11. **Инфраструктура (Docker Compose):**
    - ✅ 5 сервисов: PostgreSQL (с healthcheck), Redis, API (FastAPI), Worker (Celery), Beat (планировщик)
    - ✅ Автоматический рестарт всех сервисов
    - ✅ Персистентное хранилище для БД (volumes)
    - ✅ Монтирование кода для hot-reload в development
    - ✅ Передача переменных окружения из .env файла
    - ✅ Concurrency=2 для Celery Worker (увеличен для параллельной обработки)
    - ✅ Worker max tasks per child: 50 (увеличен для стабильности)

### 🔄 Что делаем сейчас / В разработке / Планируется:

1. **Оптимизация парсинга:**
   - ✅ Расширенный поиск корзин до 50 (вместо 25) для новых товаров
   - ✅ Параллельный поиск корзин батчами по 15 запросов
   - ✅ Добавлен сбор SEO-данных через async API
   - 📋 Планируется: кеширование корзин товаров для уменьшения запросов

2. **Улучшение производительности:**
   - 📋 Планируется: кеширование часто запрашиваемых данных в Redis
   - 📋 Планируется: оптимизация запросов к БД (добавление индексов, eager loading где нужно)
   - 📋 Планируется: батчинг запросов к API WB

3. **Новая функциональность:**
   - 📋 Планируется: система уведомлений о изменении цен через Telegram Bot
   - 📋 Планируется: расширенная аналитика (тренды цен, прогнозы)
   - 📋 Планируется: экспорт данных в Excel/CSV форматы
   - 📋 Планируется: API для внешних интеграций (webhooks)
   - 📋 Планируется: система оплаты тарифов (интеграция платежных систем)

4. **UI/UX улучшения:**
   - 📋 Планируется: разделение App.jsx на отдельные компоненты и файлы
   - 📋 Планируется: добавление React Router для улучшенной навигации
   - 📋 Планируется: фильтры и сортировки для списка товаров
   - 📋 Планируется: улучшение отображения графиков (дополнительные метрики)
   - 📋 Планируется: переход на TypeScript для frontend

5. **Тестирование:**
   - 📋 Планируется: написание unit-тестов для критичных функций парсинга
   - 📋 Планируется: интеграционные тесты для API endpoints
   - 📋 Планируется: E2E тесты для критичных сценариев пользователя

6. **Безопасность и стабильность:**
   - 🔄 Улучшена обработка ошибок во всех модулях
   - 📋 Планируется: rate limiting для API endpoints
   - 📋 Планируется: мониторинг и алертинг (Sentry, логирование)
   - 📋 Планируется: резервное копирование базы данных

---

## Правила кодирования

### 1. Язык комментариев:
- **Все комментарии пишутся на русском языке** — это основное правило проекта
- Docstrings для функций и классов на русском
- Инлайн комментарии объясняют бизнес-логику на русском
- Исключение: технические комментарии в конфигурационных файлах могут быть на английском

**Примеры:**
```python
# Получаем статику (асинхронно запускаем цикл для requests)
static_info = {"name": f"Товар {sku}", "brand": "WB"}

"""
Извлечение данных для SEO: Название, Категория, Опции (Характеристики).
Асинхронный метод для работы внутри FastAPI.
"""
async def get_seo_data(self, sku: int):
```

### 2. Именование переменных и функций:

**Python:**
- **snake_case** для функций и переменных: `get_product_data()`, `save_price_to_db()`, `user_id`
- **PascalCase** для классов: `SeleniumWBParser`, `AuthService`, `AnalysisService`
- **UPPER_SNAKE_CASE** для констант: `API_URL`, `SUPER_ADMIN_IDS`, `ADMIN_USERNAME`
- Приватные методы начинаются с `_`: `_init_driver()`, `_extract_price()`, `_find_card_json()`, `_call_ai()`

**JavaScript:**
- **camelCase** для функций и переменных: `handleScan()`, `fetchList()`, `activeTab`, `fetchKeywords()`
- **PascalCase** для React компонентов: `HomePage`, `ScannerPage`, `TariffCard`, `HistoryDetailsModal`, `SeoGeneratorPage`
- **UPPER_SNAKE_CASE** для констант: `API_URL`
- Имена компонентов должны быть описательными

### 3. Типизация:

**Python:**
- Используются **type hints** где возможно: `sku: int`, `-> bool`, `data: dict`, `keywords: List[str]`
- Опциональные типы: `user_id: int = None`, `limit: int = 50`
- Возвращаемые типы указываются в docstring или type hints
- Примеры:
  ```python
  def get_product_data(self, sku: int) -> dict:
  async def get_seo_data(self, sku: int) -> dict:
  def generate_product_content(self, keywords: list, tone: str) -> dict:
  ```

**JavaScript:**
- Типизация **не используется** (нет TypeScript)
- Желательно добавлять JSDoc комментарии для сложных функций (пока не применяется)
- Props компонентов передаются напрямую без валидации (нет PropTypes)

### 4. Форматирование кода:

**Python:**
- Следуем **PEP 8**:
  - 4 пробела для отступов (не табы)
  - Максимальная длина строки: **120 символов** (мягкий лимит, допускается превышение для читаемости)
  - Пробелы вокруг операторов: `a = b + c`
  - Пустые строки для разделения логических блоков
- Автоматическое форматирование не настроено, форматирование вручную
- Импорты группируются: стандартная библиотека → сторонние → локальные (с пустыми строками)

**JavaScript:**
- Следуем стандартам **ESLint** (конфигурация не включена, но придерживаемся стиля):
  - 2 пробела для отступов
  - Одинарные кавычки предпочтительны (но используются двойные в проекте)
  - Точка с запятой в конце строки
- Форматирование вручную с соблюдением консистентности

### 5. Структура кода:

- **Один файл — одна ответственность**: каждый модуль делает одну четкую вещь
- **Функции должны быть небольшими** и делать одну задачу
- **Избегаем глубокой вложенности**: максимум 3-4 уровня вложенности
- **Разделение импортов**: стандартная библиотека → сторонние → локальные (с пустыми строками между группами)
- **Логические блоки разделяются** пустыми строками и комментариями

**Пример структуры:**
```python
# Импорты стандартной библиотеки
import os
import json

# Импорты сторонних библиотек
from fastapi import FastAPI
from sqlalchemy import select

# Импорты локальных модулей
from parser_service import parser_service
from database import get_db
```

### 6. Обработка ошибок:

- **Всегда используем try-except** для внешних вызовов (API, БД, файлы, сеть)
- **Логируем все ошибки** с контекстом через logger
- **Не используем голые `except:`** — всегда указываем тип: `except Exception as e:`
- **Возвращаем понятные сообщения** пользователю без утечки технических деталей
- **Используем finally** для очистки ресурсов (закрытие драйверов, сессий БД)

**Примеры:**
```python
try:
    data = await session.get(url)
except Exception as e:
    logger.error(f"Request failed: {e}")
    return None
finally:
    if driver: driver.quit()
```

### 7. Работа с асинхронностью:

- **FastAPI endpoints**: все endpoints используют `async def` для асинхронной обработки
- **База данных в FastAPI**: используется `AsyncSession` с asyncpg драйвером
- **База данных в Celery**: используется `SyncSessionLocal` с psycopg2-binary (Celery задачи синхронные)
- **Celery задачи**: синхронные функции, но могут создавать event loop для вызова async функций:
  ```python
  loop = asyncio.new_event_loop()
  asyncio.set_event_loop(loop)
  result = loop.run_until_complete(async_function())
  loop.close()
  ```
- **HTTP запросы**: `aiohttp` для асинхронных запросов (внутри async функций), `requests` для синхронных (в Celery)
- **SEO парсинг**: используется async метод `get_seo_data` в FastAPI endpoints, прямой `await` без создания нового event loop

### 8. Работа с базой данных:

- **Всегда закрываем сессии**: через `finally` блок или контекстный менеджер
- **Используем транзакции**: `session.commit()` для сохранения, `session.rollback()` при ошибках
- **Проверяем наличие данных**: перед обращением к атрибутам связанных объектов
- **Используем select() вместо query()**: в async контексте (SQLAlchemy 2.0 style)
- **Каскадное удаление**: настроено через `cascade="all, delete-orphan"` для автоматической очистки

**Примеры:**
```python
# Async (FastAPI)
async with AsyncSessionLocal() as session:
    result = await session.execute(select(User))
    user = result.scalars().first()

# Sync (Celery)
session = SyncSessionLocal()
try:
    item = session.query(MonitoredItem).filter(...).first()
    session.commit()
finally:
    session.close()
```

### 9. Логирование:

- **Используем модуль `logging`** вместо `print()` для всех сообщений
- **Настраиваем разные уровни**: INFO для обычных операций, WARNING для предупреждений, ERROR для ошибок
- **Добавляем контекст в логи**: SKU, user_id, task_id, attempt number
- **Используем именованные логгеры**: `logger = logging.getLogger("WB-Parser")`, `logger = logging.getLogger("CeleryWorker")`
- **Формат логов**: `'%(asctime)s | %(levelname)s | [%(name)s] %(message)s'`

**Примеры:**
```python
logger.info(f"--- ПАРСИНГ ЦЕН SKU: {sku} ---")
logger.info(f"--- SEO PARSE SKU: {sku} ---")
logger.warning(f"Wait timeout for price selector attempt {attempt}")
logger.error(f"Price attempt {attempt} error: {e}")
```

### 10. Безопасность:

- **Никогда не логируем чувствительные данные**: токены, пароли, прокси-данные
- **Валидируем все входные данные**: проверка типов, диапазонов, форматов
- **Используем параметризованные запросы**: SQLAlchemy автоматически защищает от SQL injection
- **Проверяем права доступа**: перед выполнением операций (проверка `user.is_admin`, принадлежность товара пользователю)
- **Храним секреты в переменных окружения**: никогда не коммитим `.env` файлы
- **Валидация Telegram данных**: всегда проверяем HMAC подпись перед использованием данных

### 11. Конфигурация и переменные окружения:

- **Все конфигурационные значения** выносятся в переменные окружения
- **Используем `.env` файлы** для локальной разработки (не коммитится в репозиторий)
- **Значения по умолчанию**: предоставляем для опциональных параметров через `os.getenv("KEY", "default")`
- **Примеры переменных**: `DATABASE_URL`, `REDIS_URL`, `BOT_TOKEN`, `AI_API_KEY`, `PROXY_*`, `HEADLESS`, `DEBUG_MODE`

### 12. Работа с Celery:

- **Имена задач**: указываются явно через `name="parse_and_save_sku"` для удобства
- **Обновление статуса**: используем `self.update_state(state='PROGRESS', meta={'status': '...'})` для отслеживания прогресса
- **Синхронный код**: все задачи Celery синхронные, используем sync сессии БД
- **Импорт задач**: указываем в `celery_app.conf.imports = ['tasks']` для автоматического обнаружения
- **Расписание**: настраивается через `beat_schedule` в `celery_app.py`

### 13. Работа с Selenium:

- **Всегда закрываем драйвер**: в `finally` блоке: `if driver: driver.quit()`
- **Используем таймауты**: `driver.set_page_load_timeout(120)` для избежания зависаний
- **Ожидание элементов**: предпочтительно использовать `WebDriverWait` вместо `time.sleep()`
- **Очистка ресурсов**: удаление временных файлов расширений (опционально, так как перезаписываются)
- **Обработка блокировок**: проверка на Kaspersky и другие блокировки с повторными попытками

### 14. Git и коммиты:

- **Сообщения коммитов на русском языке**: "Fix syntax error", "Global update", "bugs fix"
- **Описательные сообщения**: объясняют что изменилось, не просто "update"
- **Используются ветки**: для разработки новых функций (видно из истории)

### 15. Стиль кода Python:

- **Используем list comprehensions** где уместно, но не в ущерб читаемости
- **Тернарные операторы**: допустимы для простых случаев: `wallet = standard if wallet == 0 else wallet`
- **F-strings** для форматирования строк (Python 3.6+): `f"--- ПАРСИНГ ЦЕН SKU: {sku} ---"`
- **Context managers**: используем `with` для файлов, сессий, драйверов где возможно
- **Общие методы**: выносим повторяющуюся логику в отдельные методы (например, `_call_ai` для унификации вызовов AI API)

### 16. Стиль кода JavaScript/React:

- **Функциональные компоненты**: используются везде (хуки, а не классы)
- **Hooks**: `useState`, `useEffect` для управления состоянием и эффектами
- **Условный рендеринг**: `{condition && <Component />}` или тернарный оператор
- **Inline стили**: не используются, только Tailwind CSS классы
- **Обработка событий**: `onClick={() => handleClick()}` или `onClick={handleClick}` если без параметров
- **Многошаговые формы**: используются состояния для отслеживания текущего шага (`step`, `setStep`)

### 17. Именование файлов:

- **Python**: `snake_case.py` для всех файлов: `parser_service.py`, `analysis_service.py`
- **JavaScript**: `camelCase.jsx` или `PascalCase.jsx` для компонентов: `App.jsx`, `main.jsx`
- **Конфигурационные файлы**: стандартные имена: `package.json`, `Dockerfile`, `docker-compose.yml`

### 18. Тестирование:

- **Тесты пока не написаны** — планируется в будущем
- **Ручное тестирование**: основной способ проверки функциональности
- **Логирование используется** для отладки вместо debugger

---

## Переменные окружения

Проект использует файл `.env` в корне проекта (не включен в репозиторий):

```env
# Telegram Bot (обязательно)
BOT_TOKEN=your_telegram_bot_token

# Прокси настройки (обязательно для парсинга)
PROXY_USER=your_proxy_username
PROXY_PASS=your_proxy_password
PROXY_HOST=your_proxy_host
PROXY_PORT=your_proxy_port

# Режим браузера
HEADLESS=True

# База данных (есть значения по умолчанию)
DATABASE_URL=postgresql+asyncpg://postgres:wb_secret_password@db:5432/wb_monitor

# Redis (есть значения по умолчанию)
REDIS_URL=redis://redis:6379/0

# AI API (обязательно для AI анализа и SEO генерации)
AI_API_KEY=your_ai_api_key

# Режим отладки (опционально, для локальной разработки)
DEBUG_MODE=False
```

---

## Быстрый старт

### Запуск через Docker Compose (рекомендуется):

```bash
# 1. Создать .env файл в корне проекта (см. выше)

# 2. Запустить все сервисы
docker-compose up -d

# 3. Просмотр логов
docker-compose logs -f api      # Логи API
docker-compose logs -f worker   # Логи Celery Worker
docker-compose logs -f beat     # Логи Celery Beat

# 4. Остановка
docker-compose down

# 5. Остановка с удалением volumes (удалит БД!)
docker-compose down -v
```

**Сервисы будут доступны:**
- API: `http://localhost:8000`
- API документация: `http://localhost:8000/docs` (Swagger UI)
- PostgreSQL: `localhost:5432`
- Redis: `localhost:6379`

### Локальная разработка:

```bash
# Backend
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn main:app --reload --host 0.0.0.0 --port 8000

# Frontend (в отдельном терминале)
cd frontend
npm install
npm run dev
```

---

## Дополнительные детали

### Версии ключевых компонентов:

- **Python:** 3.9+
- **FastAPI:** последняя версия
- **React:** 18.2.0
- **Selenium:** 4.36.0
- **PostgreSQL:** 15-alpine
- **Redis:** alpine (последняя версия)
- **Celery:** последняя версия

### Особенности реализации:

- **Гибридный парсинг**: статические данные через быстрый API, динамические цены через медленный Selenium
- **Двойная БД сессия**: async для FastAPI, sync для Celery (избегаем проблем с greenlet)
- **Батчинг запросов**: поиск корзин параллельными батчами по 15 для ускорения
- **Расширенный поиск корзин**: до 50 корзин для новых товаров WB
- **Система супер-админов**: жестко заданные telegram_id в коде для доступа к админ-панели
- **SEO-генератор**: 3-шаговый процесс с возможностью редактирования ключевых слов и выбора тона текста
- **Унификация AI-вызовов**: общий метод `_call_ai` для анализа отзывов и генерации SEO-контента

---

**Дата последнего обновления:** 2026  
**Версия документа:** 4.0
</file>

</files>
